{"jsonrpc":"2.0","method":"notifications/tools/list_changed"}
{"jsonrpc":"2.0","method":"notifications/tools/list_changed"}
{"jsonrpc":"2.0","method":"notifications/tools/list_changed"}
{"jsonrpc":"2.0","method":"notifications/tools/list_changed"}
{"jsonrpc":"2.0","method":"notifications/tools/list_changed"}
{"jsonrpc":"2.0","method":"notifications/tools/list_changed"}
{"jsonrpc":"2.0","method":"notifications/tools/list_changed"}
{"jsonrpc":"2.0","method":"notifications/tools/list_changed"}
{"jsonrpc":"2.0","method":"notifications/tools/list_changed"}
{"jsonrpc":"2.0","method":"notifications/tools/list_changed"}
{"jsonrpc":"2.0","method":"notifications/tools/list_changed"}
{"jsonrpc":"2.0","method":"notifications/tools/list_changed"}
{"jsonrpc":"2.0","method":"notifications/tools/list_changed"}
{"jsonrpc":"2.0","method":"notifications/tools/list_changed"}
{"jsonrpc":"2.0","method":"notifications/tools/list_changed"}
{"jsonrpc":"2.0","method":"notifications/tools/list_changed"}
{"jsonrpc":"2.0","method":"notifications/resources/list_changed"}
{"jsonrpc":"2.0","method":"notifications/resources/list_changed"}
{"jsonrpc":"2.0","method":"notifications/resources/list_changed"}
{"jsonrpc":"2.0","method":"notifications/resources/list_changed"}
{"jsonrpc":"2.0","method":"notifications/resources/list_changed"}
{"jsonrpc":"2.0","method":"notifications/prompts/list_changed"}
{"jsonrpc":"2.0","method":"notifications/prompts/list_changed"}
{"jsonrpc":"2.0","method":"notifications/prompts/list_changed"}
{"jsonrpc":"2.0","method":"notifications/prompts/list_changed"}
{"jsonrpc":"2.0","method":"notifications/prompts/list_changed"}
{"jsonrpc":"2.0","method":"notifications/prompts/list_changed"}
{"jsonrpc":"2.0","method":"notifications/prompts/list_changed"}
{"jsonrpc":"2.0","method":"notifications/prompts/list_changed"}
{"jsonrpc":"2.0","id":0,"result":{"protocolVersion":"2024-11-05","capabilities":{"logging":{},"prompts":{"listChanged":true},"resources":{"subscribe":true,"listChanged":true},"tools":{"listChanged":true}},"serverInfo":{"name":"clojure-server","version":"0.1.0"}}}
{"jsonrpc":"2.0","id":1,"result":{"tools":[{"name":"LS","description":"Returns a recursive tree view of files and directories starting from the specified path. The path parameter must be an absolute path, not a relative path. You should generally prefer the `glob_files` and `fx_grep` tools, if you know which directories to search.","inputSchema":{"type":"object","properties":{"path":{"type":"string"},"max_depth":{"type":"integer","description":"Maximum depth to traverse (optional)"},"limit":{"type":"integer","description":"Maximum number of entries to show (default: 100)"}},"required":["path"]}},{"name":"read_file","description":"Smart file reader with pattern-based exploration for Clojure files.\n   \nFor Clojure files (.clj, .cljc, .cljs, .bb):\n\nThis tool defaults to an expandable collapsed view to quickly grab the information you need from a Clojure file.\nIf called without `name_pattern` or `content_pattern` it will return the file content where \nyou will see only function signatures. This gives you a quick overview of the file.\n\nWhen you want to see more, this tool has a grep functionality where you\ncan give patterns to match the names for top level definitions\n`name_pattern` or match the bodies of top level definitions `content_pattern`.\n\nThe functions that match these patterns will be the only functions expanded in collapsed view.\n\nFor defmethod forms:\n- The name includes both the method name and the dispatch value (e.g., \"area :rectangle\")\n- For vector dispatch values, use the exact pattern (e.g., \"dispatch-with-vector \\[:feet :inches\\]\")\n- For qualified/namespaced multimethod names, include the namespace (e.g., \"tool-system/validate-inputs :clojure-eval\")\n\nFor text files (non-Clojure):\n- When `collapsed: true` and a pattern is provided (`content_pattern` or `name_pattern`), shows only lines matching the pattern with 10 lines of context before and after\n\nFor all other file types:\n- Collapsed view will not be applied and will return the raw contents of the file\n\nParameters:\n- path: Path to the file (required)\n- collapsed: Show collapsed view (default: true)\n\nCollapsed View mode function expansion parameters:\n\n- name_pattern: Regex to match function names (e.g., \"validate.*\")\n- content_pattern: Regex to match function content (e.g., \"try|catch\")\n\nExample usage for defmethod forms:\n- Find all implementations of a multimethod: `name_pattern: \"area\"`\n- Find specific dispatch values: `name_pattern: \"area :circle\"`\n- Find vector dispatch values: `name_pattern: \"convert-length \\\\[:feet :inches\\\\]\"`\n- Find namespace-qualified methods: `name_pattern: \"tool-system/validate-inputs\"`\n\nExample usage for text files:\n- Find error messages: `content_pattern: \"ERROR|WARN\"`\n- Find specific log entries: `content_pattern: \"\\\\[2024-01-15.*ERROR\\\\]\"`\n\nNon collapsed view mode respects these parameters:\n\n- line_offset: Line to start reading from (non-collapsed mode only, default: 0)\n- limit: Maximum lines to read (non-collapsed mode only, default: 2000)\n\nBy default, reads up to 2000 lines, truncating lines longer than 1000 characters.","inputSchema":{"type":"object","properties":{"path":{"type":"string","description":"Path to the file to read"},"collapsed":{"type":"boolean","description":"Whether to show collapsed view for Clojure files (default: true)"},"name_pattern":{"type":"string","description":"Pattern to match function names (e.g., \"validate.*\")"},"content_pattern":{"type":"string","description":"Pattern to match function content (e.g., \"try|catch\")"},"line_offset":{"type":"integer","description":"Line to start reading from for raw mode (default: 0)"},"limit":{"type":"integer","description":"Maximum lines to read (default: 2000)"}},"required":["path"]}},{"name":"grep","description":"Fast content search tool that works with any codebase size.\n- Finds the paths to files that have matching contents using regular expressions.\n- Supports full regex syntax (eg. \"log.*Error\", \"function\\s+\\w+\", etc.).\n- Filter files by pattern with the include parameter (eg. \"*.js\", \"*.{ts,tsx}\").\n- Returns matching file paths sorted by modification time.\n- Use this tool when you need to find files containing specific patterns.\n- When you are doing an open ended search that may require multiple rounds of globbing and grepping, use the `dispatch_agent` tool instead","inputSchema":{"type":"object","properties":{"path":{"type":"string","description":"The directory to search in. Defaults to the current working directory."},"pattern":{"type":"string","description":"The regular expression pattern to search for in file contents"},"include":{"type":"string","description":"File pattern to include in the search (e.g. \"*.clj\", \"*.{clj,cljs}\")"},"max_results":{"type":"integer","description":"Maximum number of results to return (default: 1000)"}},"required":["pattern"]}},{"name":"glob_files","description":"Fast file pattern matching tool that works with any codebase size.\n - Supports glob patterns like \"**/*.clj\" or \"src/**/*.cljs\".\n - Returns matching file paths sorted by modification time (most recent first).\n - Use this tool when you need to find files by name patterns.\n - When you are doing an open ended search that may require multiple rounds of globbing and grepping, use the `dispatch_agent` tool instead","inputSchema":{"type":"object","properties":{"path":{"type":"string","description":"Root directory to start the search from (defaults to current working directory)"},"pattern":{"type":"string","description":"Glob pattern (e.g. \"**/*.clj\", \"src/**/*.tsx\")"},"max_results":{"type":"integer","description":"Maximum number of results to return (default: 1000)"}},"required":["pattern"]}},{"name":"think","description":"Use the tool to think about something. It will not obtain new information or make any changes to the repository, but just log the thought. Use it when complex reasoning or brainstorming is needed. \nCommon use cases:\n* when having difficulty finding/reading the files you need\n* when having difficulty writing out code\n* when having difficulty using the tools or the clojure tools\n* When exploring a repository and discovering the source of a bug, call this tool to brainstorm several unique ways of fixing the bug, and assess which change(s) are likely to be simplest and most effective.\n* After receiving test results, use this tool to brainstorm ways to fix failing tests.\n* When planning a complex refactoring, use this tool to outline different approaches and their tradeoffs.\n* When designing a new feature, use this tool to think through architecture decisions and implementation details.\n* When debugging a complex issue, use this tool to organize your thoughts and hypotheses.\nThe tool simply logs your thought process for better transparency and does not execute any code or make changes.","inputSchema":{"type":"object","properties":{"thought":{"type":"string","description":"The thought to log"}},"required":["thought"]}},{"name":"scratch_pad","description":"A persistent scratch pad for storing structured data between tool calls. Accepts any JSON value (objects, arrays, strings, numbers, booleans, null) and stores them at nested paths using set_path, get_path, delete_path operations.\n\nTHIS IS YOUR GO-TO TOOL FOR PLANNING.\n\nYour persistent workspace for planning, organizing thoughts, and maintaining state across tool invocations.\n\nThis tool can be used to:\n * develop and track multi-step plans\n * maintain task lists and task tracking\n * store intermediate results between operations\n * keep notes about your current approach or strategy\n * maintain a list of files or resources to process\n * build up complex data structures incrementally\n * share context between different tool calls\n * any other persistent storage needs during your work\n\nThe scratch pad is for persistent storage and state management, not for formatting output. Display information directly in your chat responses. However, when the scratch pad contains user-relevant state (like tasks lists or tracked progress), you should retrieve and display updates after modifications.\n\nUse the scratch pad when you need to:\n- Track progress across multiple tool calls\n- Build data structures incrementally  \n- Maintain state between operations\n- Store intermediate results for later use\n\nDon't use the scratch pad to:\n- Format text for display\n- Store static information just to retrieve and show it\n- Replace direct chat responses\n\nCORE OPERATIONS:\n- set_path: Store a value (not null) at a path, returns the parent container\n- get_path: Retrieve a value from a path, returns the value or nil\n- delete_path: Remove only the leaf value from a path, returns a confirmation message\n- inspect: Display the entire structure (or a specific path) with truncation at specified depth\n\nWARNING: null values can not be stored in the scratch pad, if you attempt to store a null value the set_path will fail.\n\nTRACKING PLANS WITH TASK LISTS:\n\nRecommended schema for a Task:\n{\n  task: \"Description of the task\",\n  done: false,\n  priority: \"high\", // optional: \"high\", \"medium\", \"low\"\n  context: \"Additional details\", // optional\n  subtasks: [  // optional: array of subtask objects\n    {task: \"Subtask 1\", done: false},\n    {task: \"Subtask 2\", done: true}\n  ]\n}\n\nFirst add multiple tasks items at once as an array:\n- Entire array:\n  op: set_path\n  path: [\"tasks\"]\n  value: [\n    {task: \"Write tests\", done: false, priority: \"high\"},\n    {task: \"Review PR\", done: false, priority: \"high\"},\n    {task: \"Update docs\", done: false, priority: \"medium\", subtasks: [\n      {task: \"Update API docs\", done: false},\n      {task: \"Update README\", done: false}\n    ]}\n  ]\n  explanation: Adding multiple tasks at once\n\nAdding tasks items:\n- First item:\n  op: set_path\n  path: [\"tasks\", 3]\n  value: {task: \"Run tests\", done: false}\n  explanation: Adding write tests task\n\n- Next item:\n  op: set_path\n  path: [\"tasks\", 4]\n  value: {task: \"Notify user\", done: false, priority: \"high\"}\n  explanation: Adding high priority task\n\nChecking off completed tasks:\n- Mark as done:\n  op: set_path\n  path: [\"tasks\", 0, \"done\"]\n  value: true\n  explanation: Completed writing tests\n\n- Mark subtask as done:\n  op: set_path\n  path: [\"tasks\", 2, \"subtasks\", 0, \"done\"]\n  value: true\n  explanation: Completed API docs update\n\nAdding a new task to the array:\n- Append to array:\n  op: set_path\n  path: [\"tasks\", 3]\n  value: {task: \"Deploy to production\", done: false, priority: \"high\"}\n  explanation: Adding deployment task\n\nViewing tasks:\n- All tasks:\n  op: get_path\n  path: [\"tasks\"]\n  explanation: Get all tasks\n\n- Specific task:\n  op: get_path\n  path: [\"tasks\", 0]\n  explanation: Checking first task details\n\n- View with depth limit:\n  op: inspect\n  path: [\"tasks\"]\n  depth: 2\n  explanation: View tasks with limited nesting","inputSchema":{"type":"object","properties":{"op":{"type":"string","enum":["set_path","get_path","delete_path","inspect"],"description":"The operation to perform:\n * set_path: set a value at a path\n * get_path: retrieve a value at a path\n * delete_path: remove the value at the path from the data structure\n * inspect: view the datastructure (or a specific path within it) up to a certain depth\n"},"path":{"type":"array","items":{"type":"string"},"description":"Path to the data location (array of string or number keys) - used for set_path, get_path, delete_path, and optionally inspect"},"value":{"description":"Value to store (for set_path). Can be ANY JSON value EXCEPT null: object, array, string, number, boolean.","type":"object"},"explanation":{"type":"string","description":"Explanation of why this operation is being performed"},"depth":{"type":"number","description":"(Optional) For inspect operation: Maximum depth to display (default: 5). Must be a positive integer."}},"required":["op","explanation"]}},{"name":"clojure_eval","description":"Takes a Clojure Expression and evaluates it in the current namespace. For example, providing \"(+ 1 2)\" will evaluate to 3.\n\nThis tool is intended to execute Clojure code. This is very helpful for verifying that code is working as expected. It's also helpful for REPL driven development.\n\nIf you send multiple expressions they will all be evaluated individually and their output will be clearly partitioned.\n\nIf the returned value is too long it will be truncated.\n\nIMPORTANT: When using `require` to reload namespaces ALWAYS use `:reload` to ensure you get the latest version of files.\n\nREPL helper functions are automatically loaded in the 'clj-mcp.repl-tools' namespace, providing convenient namespace and symbol exploration:\n\nNamespace/Symbol inspection functions:\n  clj-mcp.repl-tools/list-ns           - List all available namespaces\n  clj-mcp.repl-tools/list-vars         - List all vars in namespace\n  clj-mcp.repl-tools/doc-symbol        - Show documentation for symbol\n  clj-mcp.repl-tools/source-symbol     - Show source code for symbol\n  clj-mcp.repl-tools/find-symbols      - Find symbols matching pattern\n  clj-mcp.repl-tools/complete          - Find completions for prefix\n  clj-mcp.repl-tools/help              - Show this help message\n\nExamples:\n  (clj-mcp.repl-tools/list-ns)                     ; List all namespaces\n  (clj-mcp.repl-tools/list-vars 'clojure.string)   ; List functions in clojure.string\n  (clj-mcp.repl-tools/doc-symbol 'map)             ; Show documentation for map\n  (clj-mcp.repl-tools/source-symbol 'map)          ; Show source code for map\n  (clj-mcp.repl-tools/find-symbols \"seq\")          ; Find symbols containing \"seq\"\n  (clj-mcp.repl-tools/complete \"clojure.string/j\") ; Find completions for prefix","inputSchema":{"type":"object","properties":{"code":{"type":"string","description":"The Clojure code to evaluate."}},"required":["code"]}},{"name":"bash","description":"Execute bash shell commands on the host system.\n\nExamples:\n1. List files: bash(command: \"ls -la\")\n2. Find text in files: bash(command: \"grep -r 'pattern' /path/to/search\")\n3. With working directory: bash(command: \"ls -la\", working_directory: \"/tmp\")\n4. With timeout: bash(command: \"sleep 10\", timeout_ms: 5000)\n5. Git commands \n\nFor long running processes like running tests increase the timeout_ms so that the process can complete.\n\nNote: Non-zero exit codes are NOT treated as tool errors - check exit_code\nin the response to determine command success.","inputSchema":{"type":"object","properties":{"command":{"type":"string","description":"The shell command to execute"},"working_directory":{"type":"string","description":"Directory to run the command in (optional)"},"timeout_ms":{"type":"integer","description":"Maximum execution time in milliseconds (optional, default: 30000)"}},"required":["command"]}},{"name":"clojure_edit","description":"Edits a top-level form (`defn`, `def`, `defmethod`, `ns`, `deftest`) in a Clojure file using the specified operation.\n   \nPREFER this unified tool over generic file editing tools for Clojure files (`.clj` `.cljs` `.cljc` `.bb`)\n\nThis tool MAKES it EASIER to match a definition that exists in the file AS you only have to match the type of definition `form_type` and the complete identifier `form_identifier` of the definition. This prevents the repeated mismatch errors that occur when trying match an entire string of text for replacement.\nThis tool validates the structure of the Clojure code that is being inserted into the file and will provide linting feedback for things such as parenthetical errors.\nThis tool reduces the number of tokens that need to be generated.\n \nWARNING: you will receive errors if the syntax is wrong, the most common error is an extra or missing parenthesis in the `content`, so be careful with parenthesis.\n\n   Operations:\n   - \"replace\": Replaces the form with new content\n   - \"insert_before\": Inserts content before the form\n   - \"insert_after\": Inserts content after the form\n   \n   The form is identified by its type (defn, def, deftest, s/def, ns, defmethod etc.) and complete identifier.\n   \n   Example: Replace a function definition:\n   - file_path: \"/path/to/file.clj\"\n   - form_identifier: \"example-fn\"\n   - form_type: \"defn\"\n   - operation: \"replace\"\n   - content: \"(defn example-fn [x] (* x 2))\"\n   \n   Example: Insert a helper function before a function:\n   - file_path: \"/path/to/file.clj\"\n   - form_identifier: \"example-fn\"\n   - form_type: \"defn\"\n   - operation: \"insert_before\"\n   - content: \"(defn helper-fn [x] (* x 2))\"\n   \n   Example: Insert a test after a function:\n   - file_path: \"/path/to/file.clj\"\n   - form_identifier: \"example-fn\"\n   - form_type: \"defn\"\n   - operation: \"insert_after\"\n   - content: \"(deftest example-fn-test\n  (is (= 4 (example-fn 2))))\"\n   \nNote: For `defmethod` forms, be sure to include the dispatch value (`area :rectangle` or `qualified/area :rectangle`) in the `form_identifier`. Many `defmethod` definitions have qualified names (they include a namespace alias in their identifier like `shape/area`), so it's crucial to use the complete identifier that appears in the file.\n\n   Example: Replace a specific `defmethod` implementation:\n   - file_path: \"/path/to/file.clj\"\n   - form_identifier: \"shape/area :square\"\n   - form_type: \"defmethod\"\n   - operation: \"replace\"\n   - content: \"(defmethod shape/area :square [{:keys [w h]}] (* w h))\"\n\n   Example: Work with vector dispatch values:\n   - file_path: \"/path/to/file.clj\"\n   - form_identifier: \"convert-length [:feet :inches]\"\n   - form_type: \"defmethod\"\n   - operation: \"insert_before\"\n   - content: \"(def inches-per-foot 12)\"\n\n   The tool will find the form, perform the requested operation, and format the result.\n   It returns a diff showing the changes made to the file.","inputSchema":{"type":"object","properties":{"file_path":{"type":"string","description":"Path to the file containing the form to edit"},"form_identifier":{"type":"string","description":"Complete identifier of the form (e.g., function name, \"shape/area\", or \"convert-length [:feet :inches]\")"},"form_type":{"type":"string","description":"Type of the form (e.g., \"defn\", \"def\", \"ns\")"},"operation":{"type":"string","enum":["replace","insert_before","insert_after"],"description":"The editing operation to perform"},"content":{"type":"string","description":"New content to use for the operation"}},"required":["file_path","form_identifier","form_type","operation","content"]}},{"name":"clojure_edit_replace_sexp","description":"Edits a file by finding and replacing specific s-expressions.\n\nUse this tool for targeted edits of sub-expressions within forms. For complete top-level form replacements, prefer specialized tools like `clojure_edit_replace_definition` and friends.\n\nKEY BENEFITS:\n- Syntax-aware matching that understands Clojure code structure\n- Ignores whitespace differences by default, focusing on actual code meaning\n- Matches expressions regardless of formatting, indentation, or spacing\n- Prevents errors from mismatched text or irrelevant formatting differences\n- Can find and replace all occurrences with replace_all: true\n\nCONSTRAINTS:\n- match_form must contain only a SINGLE s-expression (error otherwise)\n- Requires syntactically valid Clojure expressions in both match_form and new_form\n\nWARNING: You will receive errors if the syntax is wrong. The most common error is an extra or missing parenthesis in either match_form or new_form, so count your parentheses carefully!\n\nCOMMON APPLICATIONS:\n- Renaming symbols throughout the file: {\"match_form\": \"old-name\", \"new_form\": \"new-name\", \"replace_all\": true}\n- Editing special forms like if/cond/let/when within functions:\n  * Changing if branches: {\"match_form\": \"(if condition expr1 expr2)\", \"new_form\": \"(if condition (do expr1) expr2)\"}\n  * Enhancing let bindings: {\"match_form\": \"(let [x 10] (+ x 2))\", \"new_form\": \"(let [x 10 y 20] (+ x y))\"}\n  * Converting cond to case: {\"match_form\": \"(cond (= x :a) \\\"A\\\" (= x :b) \\\"B\\\")\", \"new_form\": \"(case x :a \\\"A\\\" :b \\\"B\\\")\"}\n- Modifying nested function calls: {\"match_form\": \"(str (+ a b))\", \"new_form\": \"(str (+ a b c))\"}\n- Changing anonymous function syntax: {\"match_form\": \"#(update % :count inc)\", \"new_form\": \"(fn [x] (update x :count inc))\"}\n\nOther Examples:\n- Replace a calculation: {\"match_form\": \"(+ x 2)\", \"new_form\": \"(+ x 10)\"}\n  * Will match regardless of spaces: (+ x 2), (+   x   2), etc.\n- Delete an expression: {\"match_form\": \"(println debug-info)\", \"new_form\": \"\"}\n- Edit anonymous function: {\"match_form\": \"#(inc %)\", \"new_form\": \"#(+ % 2)\"}\n- Replace multiple occurrences: {\"match_form\": \"(inc x)\", \"new_form\": \"(+ x 1)\", \"replace_all\": true}\n\nReturns a diff showing the changes made to the file.","inputSchema":{"type":"object","properties":{"file_path":{"type":"string","description":"Path to the file to edit"},"match_form":{"type":"string","description":"The s-expression to find and replace (include # for anonymous functions)"},"new_form":{"type":"string","description":"The s-expression to replace with"},"replace_all":{"type":"boolean","description":"Whether to replace all occurrences (default: false)"}},"required":["file_path","match_form","new_form"]}},{"name":"file_edit","description":"Edit a file by replacing a specific text string with a new one. For safety, this tool requires that the string to replace appears exactly once in the file. \n\nFIRST: the clojure_edit tool is prefered because they use precise structural rewrite-clj editing. They also incorporate linting and ensure balance parenthesis.\n\nWHEN the clojure_edit tool won't work or you have a small easy edit \n\nPREFER the file_write tool for replacing more than half a file, this saves on tokens\n\nFor Clojure files (.clj, .cljs, .cljc, .edn):\n- Content will be linted for syntax errors before writing\n- Content will be formatted according to Clojure standards\n- Writing will fail if linting detects syntax errors\n\nTo make a file edit, provide the file_path, old_string (the text to replace), and new_string (the replacement text). The old_string must uniquely identify the specific instance you want to change, so include several lines of context before and after the change point. To create a new file, use file_write instead.","inputSchema":{"type":"object","properties":{"file_path":{"type":"string","description":"The absolute path to the file to modify (must be absolute, not relative)"},"old_string":{"type":"string","description":"The text to replace (must match the file contents exactly, including all whitespace and indentation)."},"new_string":{"type":"string","description":"The edited text to replace the old_string"}},"required":["file_path","old_string","new_string"]}},{"name":"file_write","description":"Write a file to the local filesystem. Overwrites the existing file if there is one.\n\nFor Clojure files (.clj, .cljs, .cljc, .edn):\n- Content will be linted for syntax errors before writing\n- Content will be formatted according to Clojure standards\n- Writing will fail if linting detects syntax errors\n\nFor other file types:\n- Content is written directly without linting or formatting\n\nIMPORTANT SAFETY FEATURE:\n- If the file has been modified since it was last read, writing will fail\n- You must use read_file to get the current content before editing a file\n- This prevents accidental overwrites of external changes\n\nReturns information about whether the file was created or updated, along with a diff \nshowing the changes made.\n\nBefore using this tool:\n1. Use the read_file tool to understand the file's contents and context\n2. Directory Verification (only applicable when creating new files):\n   - Use the list_directory tool to verify the parent directory exists and is the correct location\n3. For Clojure files, ensure code is syntactically correct\n\n# Example:\n# file_write(\n#   file_path: \"/absolute/path/to/file.clj\",\n#   content: \"(ns my.namespace)\\n\\n(defn my-function [x]\\n  (* x 2))\"\n# )","inputSchema":{"type":"object","properties":{"file_path":{"type":"string","description":"The absolute path to the file to write (must be absolute, not relative)"},"content":{"type":"string","description":"The content to write to the file"}},"required":["file_path","content"]}},{"name":"clojure_inspect_project","description":"Analyzes and provides detailed information about a Clojure project's structure, \nincluding dependencies, source files, namespaces, and environment details.\n\nThis tool helps you understand project organization without having to manually \nexplore multiple configuration files. It works with both deps.edn and Leiningen projects.\n\nThe tool provides information about:\n- Project environment (working directory, Clojure version, Java version)\n- Source and test paths\n- Dependencies and their versions\n- Aliases and their configurations\n- Available namespaces\n- Source file structure\n\nUse this tool to quickly get oriented in an unfamiliar Clojure codebase or to \nget a high-level overview of your current project.\n\n# Example:\nclojure_inspect_project()","inputSchema":{"type":"object","properties":{"explanation":{"type":"string","description":"Short explanation why you chose this tool"}},"required":["explanation"]}},{"name":"dispatch_agent","description":"Launch a new agent that has access to read-only tools. When you are searching for a keyword or file and are not confident that you will find the right match on the first try, use the Agent tool to perform the search for you. For example:\n\n- If you are searching for a keyword like \"config\" or \"logger\", the Agent tool is appropriate\n- If you want to read a specific file path, use the read_file or glob_files tool instead of the Agent tool, to find the match more quickly\n- If you are searching for a specific class definition like \"class Foo\", use the glob_files tool instead, to find the match more quickly\n\nUsage notes:\n1. Launch multiple agents concurrently whenever possible, to maximize performance; to do that, use a single message with multiple `agent` tool uses\n2. When the agent is done, it will return a single message back to you. The result returned by the agent is not visible to the user. To show the user the result, you should send a text message back to the user with a concise summary of the result.\n3. Each agent invocation is stateless. You will not be able to send additional messages to the agent, nor will the agent be able to communicate with you outside of its final report. Therefore, your prompt should contain a highly detailed task description for the agent to perform autonomously and you should specify exactly what information the agent should return back to you in its final and only message to you.\n4. The agent's outputs should generally be trusted","inputSchema":{"type":"object","properties":{"prompt":{"type":"string","description":"The prompt to send to the agent"}},"required":["prompt"]}},{"name":"architect","description":"Your go-to tool for any technical or coding task. Analyzes requirements and breaks them down into clear, actionable implementation steps. Use this whenever you need help planning how to implement a feature, solve a technical problem, or structure your code.","inputSchema":{"type":"object","properties":{"prompt":{"type":"string","description":"The technical request or coding task to analyze"},"context":{"type":"string","description":"Optional context from previous conversation or system state"}},"required":["prompt"]}},{"name":"code_critique","description":"Starts an interactive code review conversation that provides constructive feedback on your Clojure code.\n  \n  HOW TO USE THIS TOOL:\n  1. Submit your Clojure code for initial critique\n  2. Review the suggestions and implement improvements\n  3. Test your revised code in the REPL\n  4. Submit the updated code for additional feedback\n  5. Continue this cycle until the critique is satisfied\n  \n  This tool initiates a feedback loop where you:\n  - Receive detailed analysis of your code\n  - Implement suggested improvements\n  - Test and verify changes\n  - Get follow-up critique on your revisions\n  \n  The critique examines:\n  - Adherence to Clojure style conventions\n  - Functional programming best practices\n  - Performance optimizations\n  - Readability and maintainability improvements\n  - Idiomatic Clojure patterns\n  \n  Example conversation flow:\n  - You: Submit initial function implementation\n  - Tool: Provides feedback on style and structure\n  - You: Revise code based on suggestions and test in REPL\n  - Tool: Reviews updates and suggests further refinements\n  - Repeat until code quality goals are achieved\n  \n  Perfect for iterative learning and continuous code improvement.","inputSchema":{"type":"object","properties":{"code":{"type":"string","description":"The Clojure code to analyze and critique"},"context":{"type":"string","description":"Optional context from previous conversation or system state"}},"required":["code"]}}]}}
{"jsonrpc":"2.0","id":2,"result":{"resources":[{"uri":"custom://llm-code-style","name":"LLM_CODE_STYLE.md","description":"Guidelines for writing Clojure code for the current project hosting the REPL","mimeType":"text/markdown"},{"uri":"custom://project-summary","name":"PROJECT_SUMMARY.md","description":"A Clojure project summary document for the project hosting the REPL, this is intended to provide the LLM with important context to start.","mimeType":"text/markdown"},{"uri":"custom://claude","name":"CLAUDE.md","description":"The Claude instructions document for the current project hosting the REPL","mimeType":"text/markdown"},{"uri":"custom://readme","name":"README.md","description":"A README document for the current Clojure project hosting the REPL","mimeType":"text/markdown"},{"uri":"custom://project-info","name":"Clojure Project Info","description":"Information about the current Clojure project structure, attached REPL environment and dependencies","mimeType":"text/markdown"}]}}
{"jsonrpc":"2.0","id":3,"result":{"prompts":[{"name":"ACT/scratch_pad_load","description":"Loads a file into the scratch pad state. Returns status messages and a shallow inspect of the loaded data.","arguments":[{"name":"file_path","description":"Optional file path: default scratch_pad.edn","required":false}]},{"name":"clojure_repl_system_prompt","description":"Provides instructions and guidelines for Clojure development, including style and best practices.","arguments":[]},{"name":"create-update-project-summary","description":"Generates a prompt instructing the LLM to create a summary of a project.","arguments":[]},{"name":"chat-session-summarize","description":"Instructs the assistant to create a summary of the current chat session and store it in the scratch pad. `chat_session_key` is optional and will default to `chat_session_summary`","arguments":[{"name":"chat_session_key","description":"[Optional] key to store the session summary in","required":false}]},{"name":"ACT/scratch_pad_save_as","description":"Saves the current scratch pad state to a specified file.","arguments":[{"name":"file_path","description":"File path: relative to .clojure-mcp/ directory","required":true}]},{"name":"chat-session-resume","description":"Instructs the assistant to resume a previous chat session by loading context from the scratch pad. `chat_session_key` is optional and will default to `chat_session_summary`","arguments":[{"name":"chat_session_key","description":"[Optional] key where session summary is stored","required":false}]},{"name":"ACT/add-dir","description":"Adds a directory to the allowed-directories list, giving the LLM access to it","arguments":[{"name":"directory","description":"Directory path to add (can be relative or absolute)","required":true}]},{"name":"plan-and-execute","description":"Use the scratch pad tool to plan and execute an change","arguments":[]}]}}
{"jsonrpc":"2.0","id":4,"result":{"description":"Resume conversation from key: chat_session_summary","messages":[{"role":"user","content":{"type":"text","text":"We are continuing a previous chat session, can you the read the following context\n* read the PROJECT_SUMMARY.md file\n* call the clojure_inspect_project tool\nAlso we stored information about our last conversation in the scratch_pad [\"chat_session_summary\"]  path so can you call scratch_pad with get_path [\"chat_session_summary\"] to see what we were working on previously.\nAfter doing this provide a very brief (8 lines) summary of where we are and then wait for my instructions."}}]}}
{"jsonrpc":"2.0","id":5,"result":{"content":[{"type":"text","text":"### /Users/stepbeek/HappyValley/wick/PROJECT_SUMMARY.md\n```md\n# Project Summary: Wick\n\n## Overview\nWick is a full-stack Clojure web application built with a modern, functional architecture. It features a Ring-based HTTP server with Reitit routing, PostgreSQL database integration with HikariCP connection pooling, background job processing with Proletarian, and ClojureScript frontend components using Stimulus controllers. The application follows a clean system lifecycle approach with proper startup/shutdown procedures.\n\n## Architecture\n\n### System Lifecycle\nThe application uses a centralized system management approach in `example.system`:\n- **Environment**: Loads configuration from `.env` files using dotenv-java\n- **Database**: PostgreSQL with HikariCP connection pooling and Flyway migrations\n- **Background Jobs**: Proletarian worker system for async job processing  \n- **HTTP Server**: Jetty server with Ring handlers and middleware\n- **Development**: Conditional handler reloading in development mode\n\n### Request Flow\n1. Jetty server receives HTTP requests\n2. Ring middleware stack processes requests (security, params, sessions, etc.)\n3. Reitit router matches routes and dispatches to handlers\n4. Handlers generate responses using Hiccup for HTML\n5. Static assets served from resources with resource handler\n\n## Key File Structure\n\n### Core Application Files\n- **`src/example/main.clj`** - Application entry point with `-main` function\n- **`src/example/system.clj`** - System lifecycle management (start/stop components)\n- **`src/example/routes.clj`** - Main routing configuration using Reitit\n- **`src/example/middleware.clj`** - Ring middleware stack definition\n\n### Feature Modules\n- **`src/example/hello/routes.clj`** - Hello world route handlers\n- **`src/example/goodbye/routes.clj`** - Goodbye route handlers  \n- **`src/example/static/routes.clj`** - Static asset route configuration\n- **`src/example/page_html/core.clj`** - HTML page generation utilities\n- **`src/example/jobs.clj`** - Background job definitions and processing\n\n### Database & Migrations\n- **`src/example/database/migrations.clj`** - Flyway database migration runner\n\n### Frontend Components\n- **`src/example/frontend/app.cljs`** - Main ClojureScript application\n- **`src/example/frontend/stimulus/core.cljs`** - Stimulus framework integration\n- **`src/example/frontend/stimulus/controller/greetcontroller.cljs`** - Sample Stimulus controller\n- **`assets/public/js/manifest.edn`** - Frontend asset manifest\n\n### Testing\n- **`test/example/test_system.clj`** - System-level test utilities\n- **`test/example/page_html/core_test.clj`** - HTML generation tests\n- **`test/example/math_test.clj`** - Sample unit tests\n\n## Dependencies & Tools\n\n### Core Web Stack\n- **Ring 1.13.0** - HTTP server abstraction and middleware\n- **Reitit 0.7.2** - Fast, data-driven router for Ring\n- **Hiccup 2.0.0-RC3** - HTML generation from Clojure data structures\n- **ring-defaults 0.5.0** - Sensible Ring middleware defaults\n- **ring-refresh 0.2.0** - Auto browser refresh for development ⚠️ *Not yet integrated*\n\n### Database & Persistence  \n- **next.jdbc 1.3.955** - Modern JDBC wrapper for Clojure\n- **PostgreSQL 42.7.4** - PostgreSQL JDBC driver\n- **HikariCP 6.0.0** - High-performance connection pool\n- **HoneySQL 2.6.1203** - DSL for generating SQL from Clojure data\n- **Flyway 11.7.2** - Database migration tool\n\n### Background Processing\n- **Proletarian 1.0.86-alpha** - PostgreSQL-backed job queue for Clojure\n\n### Frontend & Assets\n- **Shadow-CLJS 2.28.18** - ClojureScript build tool (dev dependency)\n- **Beholder 1.0.2** - File watching for CSS builds (dev dependency)\n\n### Development & Testing\n- **nREPL 1.3.0** - Interactive development server (port 7888)\n- **Kaocha 1.91.1392** - Comprehensive test runner\n- **TestContainers 1.20.3** - Integration testing with Docker PostgreSQL\n- **cljfmt 0.13.0** - Code formatting tool (:format alias)\n- **clj-kondo 2024.09.27** - Linting tool (:lint alias)\n\n### Utilities\n- **Cheshire 5.13.0** - JSON encoding/decoding\n- **dotenv-java 3.0.2** - Environment variable management\n- **tools.logging 1.3.0** - Logging facade with slf4j-simple 2.0.16\n\n## Available Commands\n\n### Development\n```bash\n# Start development server with nREPL\nclj -M:dev\n\n# Format code\nclj -M:format\n\n# Lint code  \nclj -M:lint\n\n# Run tests\nclj -M:dev -m kaocha.runner\n```\n\n### Production\n```bash\n# Run application\nclj -M -m example.main\n```\n\n## Implementation Patterns & Conventions\n\n### System Management\n- Uses qualified keywords with `::` for system component keys\n- Implements proper start/stop lifecycle with resource cleanup\n- Environment-aware handler construction (development vs production)\n\n### Request Handling\n- Middleware applied as vector of functions in `example.middleware`\n- Routes defined as nested data structures for Reitit\n- Handlers receive system context for database/worker access\n- Comprehensive security middleware (CSRF, XSS, clickjacking protection)\n\n### Database Access\n- Connection pooling with HikariCP for production scalability\n- Migration-first approach using Flyway on startup\n- Modern next.jdbc for database interactions\n\n### Frontend Integration  \n- ClojureScript compiled with Shadow-CLJS\n- Stimulus controllers for progressive enhancement\n- Asset manifest for production builds\n\n### Background Jobs\n- PostgreSQL-backed job queue using Proletarian\n- JSON serialization for job payloads\n- System context passed to job processors\n\n## Development Workflow\n\n### Getting Started\n1. Set up `.env` file with database credentials and configuration\n2. Start PostgreSQL database\n3. Run `clj -M:dev` to start development server with nREPL\n4. Connect to nREPL on port 7888 for interactive development\n5. Access application at configured PORT\n\n### Development Features\n- **Hot Reloading**: Development mode uses var indirection for handler reloading\n- **Auto Refresh**: ring-refresh dependency available but not yet integrated\n- **File Watching**: Beholder watches for CSS changes\n- **Interactive Development**: nREPL server for REPL-driven development\n\n### Testing Strategy\n- TestContainers for integration tests with real PostgreSQL\n- Kaocha as test runner with comprehensive reporting  \n- Separate test system setup in `test/example/test_system.clj`\n\n## Extension Points\n\n### Adding New Routes\n1. Create new route namespace following `example.hello.routes` pattern\n2. Add route to main routes vector in `example.routes/routes`\n3. Routes receive system context for database/worker access\n\n### Database Changes\n1. Add Flyway migration SQL files to resources\n2. Migrations run automatically on system startup\n3. Use next.jdbc and HoneySQL for queries\n\n### Background Jobs\n1. Define job processing functions in `example.jobs`\n2. Jobs receive system context and serialized payloads\n3. Use Proletarian worker API to enqueue jobs\n\n### Frontend Components\n1. Add new Stimulus controllers following existing pattern\n2. Update Shadow-CLJS configuration for new build targets\n3. Use Hiccup for server-side HTML generation\n\n### Middleware Integration\n1. Add new middleware functions to `example.middleware/standard-html-route-middleware` vector\n2. Middleware has access to system components via destructuring\n3. Follow Ring middleware patterns (functions returning functions)\n\n## Ring-Refresh Integration Status\n\n**Current Status**: ring-refresh is added as a dependency but not yet integrated into the middleware stack.\n\n**Integration Required**: \n1. Add `ring.middleware.refresh/wrap-refresh` to the middleware stack in development mode\n2. Consider conditional application only in development environment\n3. Ensure proper ordering in middleware chain (typically near the end)\n\n**Benefits**: Automatic browser refresh when Clojure files change, improving development experience.\n```"}],"isError":false}}
{"jsonrpc":"2.0","id":6,"result":{"content":[{"type":"text","text":"\nClojure Project Information:\n==============================\n\nEnvironment:\n• Working Directory: /Users/stepbeek/HappyValley/wick\n• Project Type: deps.edn\n• Clojure Version: 1.12.0\n• Java Version: 21.0.2\n\nSource Paths:\n• src\n• res\n• assets\n\nTest Paths:\n• test\n\nOther Relevant Accessible Directories:\n• /Users/stepbeek/HappyValley/wick\n\nDependencies:\n• cheshire/cheshire => {:mvn/version \"5.13.0\"}\n• com.github.seancorfield/honeysql => {:mvn/version \"2.6.1203\"}\n• com.github.seancorfield/next.jdbc => {:mvn/version \"1.3.955\"}\n• com.zaxxer/HikariCP => {:mvn/version \"6.0.0\"}\n• hiccup/hiccup => {:mvn/version \"2.0.0-RC3\"}\n• io.github.cdimascio/dotenv-java => {:mvn/version \"3.0.2\"}\n• metosin/reitit-ring => {:mvn/version \"0.7.2\"}\n• msolli/proletarian => {:mvn/version \"1.0.86-alpha\"}\n• org.clojure/clojure => {:mvn/version \"1.12.0\"}\n• org.clojure/tools.logging => {:mvn/version \"1.3.0\"}\n• org.flywaydb/flyway-core => {:mvn/version \"11.7.2\"}\n• org.flywaydb/flyway-database-postgresql => {:mvn/version \"11.7.2\"}\n• org.postgresql/postgresql => {:mvn/version \"42.7.4\"}\n• org.slf4j/slf4j-simple => {:mvn/version \"2.0.16\"}\n• ring/ring => {:mvn/version \"1.13.0\"}\n• ring/ring-defaults => {:mvn/version \"0.5.0\"}\n• ring-refresh/ring-refresh => {:mvn/version \"0.2.0\"}\n\nAliases:\n• :dev : {:extra-paths [\"dev\" \"test\"], :extra-deps {nrepl/nrepl {:mvn/version \"1.3.0\"}, lambdaisland/kaocha {:mvn/version \"1.91.1392\"}, thheller/shadow-cljs {:mvn/version \"2.28.18\"}, com.nextjournal/beholder {:mvn/version \"1.0.2\"}, org.testcontainers/postgresql {:mvn/version \"1.20.3\"}}, :jvm-opts [\"-Djdk.attach.allowAttachSelf\"], :main-opts [\"-m\" \"nrepl.cmdline\" \"--port\" \"7888\"]}\n• :format : {:deps {dev.weavejester/cljfmt {:mvn/version \"0.13.0\"}}}\n• :lint : {:deps {clj-kondo/clj-kondo {:mvn/version \"2024.09.27\"}}}\n\nNamespaces (16):\n• src.example.database.migrations\n• src.example.frontend.app\n• src.example.frontend.stimulus.controller.greetcontroller\n• src.example.frontend.stimulus.core\n• src.example.goodbye.routes\n• src.example.hello.routes\n• src.example.jobs\n• src.example.main\n• src.example.middleware\n• src.example.page-html.core\n• src.example.routes\n• src.example.static.routes\n• src.example.system\n• test.example.math-test\n• test.example.page-html.core-test\n• test.example.test-system\n\nProject Structure (17 files):\n• assets/public/js/manifest.edn\n• src/example/database/migrations.clj\n• src/example/frontend/app.cljs\n• src/example/frontend/stimulus/controller/greetcontroller.cljs\n• src/example/frontend/stimulus/core.cljs\n• src/example/goodbye/routes.clj\n• src/example/hello/routes.clj\n• src/example/jobs.clj\n• src/example/main.clj\n• src/example/middleware.clj\n• src/example/page_html/core.clj\n• src/example/routes.clj\n• src/example/static/routes.clj\n• src/example/system.clj\n• test/example/math_test.clj\n• test/example/page_html/core_test.clj\n• test/example/test_system.clj\n"}],"isError":false}}
{"jsonrpc":"2.0","id":7,"result":{"content":[{"type":"text","text":"nil"}],"isError":false}}
{"jsonrpc":"2.0","id":8,"result":{"description":"Resume conversation from key: chat_session_summary","messages":[{"role":"user","content":{"type":"text","text":"We are continuing a previous chat session, can you the read the following context\n* read the PROJECT_SUMMARY.md file\n* call the clojure_inspect_project tool\nAlso we stored information about our last conversation in the scratch_pad [\"chat_session_summary\"]  path so can you call scratch_pad with get_path [\"chat_session_summary\"] to see what we were working on previously.\nAfter doing this provide a very brief (8 lines) summary of where we are and then wait for my instructions."}}]}}
{"jsonrpc":"2.0","id":9,"result":{"content":[{"type":"text","text":"### /Users/stepbeek/HappyValley/wick/PROJECT_SUMMARY.md\n```md\n# Project Summary: Wick\n\n## Overview\nWick is a full-stack Clojure web application built with a modern, functional architecture. It features a Ring-based HTTP server with Reitit routing, PostgreSQL database integration with HikariCP connection pooling, background job processing with Proletarian, and ClojureScript frontend components using Stimulus controllers. The application follows a clean system lifecycle approach with proper startup/shutdown procedures.\n\n## Architecture\n\n### System Lifecycle\nThe application uses a centralized system management approach in `example.system`:\n- **Environment**: Loads configuration from `.env` files using dotenv-java\n- **Database**: PostgreSQL with HikariCP connection pooling and Flyway migrations\n- **Background Jobs**: Proletarian worker system for async job processing  \n- **HTTP Server**: Jetty server with Ring handlers and middleware\n- **Development**: Conditional handler reloading in development mode\n\n### Request Flow\n1. Jetty server receives HTTP requests\n2. Ring middleware stack processes requests (security, params, sessions, etc.)\n3. Reitit router matches routes and dispatches to handlers\n4. Handlers generate responses using Hiccup for HTML\n5. Static assets served from resources with resource handler\n\n## Key File Structure\n\n### Core Application Files\n- **`src/example/main.clj`** - Application entry point with `-main` function\n- **`src/example/system.clj`** - System lifecycle management (start/stop components)\n- **`src/example/routes.clj`** - Main routing configuration using Reitit\n- **`src/example/middleware.clj`** - Ring middleware stack definition\n\n### Feature Modules\n- **`src/example/hello/routes.clj`** - Hello world route handlers\n- **`src/example/goodbye/routes.clj`** - Goodbye route handlers  \n- **`src/example/static/routes.clj`** - Static asset route configuration\n- **`src/example/page_html/core.clj`** - HTML page generation utilities\n- **`src/example/jobs.clj`** - Background job definitions and processing\n\n### Database & Migrations\n- **`src/example/database/migrations.clj`** - Flyway database migration runner\n\n### Frontend Components\n- **`src/example/frontend/app.cljs`** - Main ClojureScript application\n- **`src/example/frontend/stimulus/core.cljs`** - Stimulus framework integration\n- **`src/example/frontend/stimulus/controller/greetcontroller.cljs`** - Sample Stimulus controller\n- **`assets/public/js/manifest.edn`** - Frontend asset manifest\n\n### Testing\n- **`test/example/test_system.clj`** - System-level test utilities\n- **`test/example/page_html/core_test.clj`** - HTML generation tests\n- **`test/example/math_test.clj`** - Sample unit tests\n\n## Dependencies & Tools\n\n### Core Web Stack\n- **Ring 1.13.0** - HTTP server abstraction and middleware\n- **Reitit 0.7.2** - Fast, data-driven router for Ring\n- **Hiccup 2.0.0-RC3** - HTML generation from Clojure data structures\n- **ring-defaults 0.5.0** - Sensible Ring middleware defaults\n- **ring-refresh 0.2.0** - Auto browser refresh for development ⚠️ *Not yet integrated*\n\n### Database & Persistence  \n- **next.jdbc 1.3.955** - Modern JDBC wrapper for Clojure\n- **PostgreSQL 42.7.4** - PostgreSQL JDBC driver\n- **HikariCP 6.0.0** - High-performance connection pool\n- **HoneySQL 2.6.1203** - DSL for generating SQL from Clojure data\n- **Flyway 11.7.2** - Database migration tool\n\n### Background Processing\n- **Proletarian 1.0.86-alpha** - PostgreSQL-backed job queue for Clojure\n\n### Frontend & Assets\n- **Shadow-CLJS 2.28.18** - ClojureScript build tool (dev dependency)\n- **Beholder 1.0.2** - File watching for CSS builds (dev dependency)\n\n### Development & Testing\n- **nREPL 1.3.0** - Interactive development server (port 7888)\n- **Kaocha 1.91.1392** - Comprehensive test runner\n- **TestContainers 1.20.3** - Integration testing with Docker PostgreSQL\n- **cljfmt 0.13.0** - Code formatting tool (:format alias)\n- **clj-kondo 2024.09.27** - Linting tool (:lint alias)\n\n### Utilities\n- **Cheshire 5.13.0** - JSON encoding/decoding\n- **dotenv-java 3.0.2** - Environment variable management\n- **tools.logging 1.3.0** - Logging facade with slf4j-simple 2.0.16\n\n## Available Commands\n\n### Development\n```bash\n# Start development server with nREPL\nclj -M:dev\n\n# Format code\nclj -M:format\n\n# Lint code  \nclj -M:lint\n\n# Run tests\nclj -M:dev -m kaocha.runner\n```\n\n### Production\n```bash\n# Run application\nclj -M -m example.main\n```\n\n## Implementation Patterns & Conventions\n\n### System Management\n- Uses qualified keywords with `::` for system component keys\n- Implements proper start/stop lifecycle with resource cleanup\n- Environment-aware handler construction (development vs production)\n\n### Request Handling\n- Middleware applied as vector of functions in `example.middleware`\n- Routes defined as nested data structures for Reitit\n- Handlers receive system context for database/worker access\n- Comprehensive security middleware (CSRF, XSS, clickjacking protection)\n\n### Database Access\n- Connection pooling with HikariCP for production scalability\n- Migration-first approach using Flyway on startup\n- Modern next.jdbc for database interactions\n\n### Frontend Integration  \n- ClojureScript compiled with Shadow-CLJS\n- Stimulus controllers for progressive enhancement\n- Asset manifest for production builds\n\n### Background Jobs\n- PostgreSQL-backed job queue using Proletarian\n- JSON serialization for job payloads\n- System context passed to job processors\n\n## Development Workflow\n\n### Getting Started\n1. Set up `.env` file with database credentials and configuration\n2. Start PostgreSQL database\n3. Run `clj -M:dev` to start development server with nREPL\n4. Connect to nREPL on port 7888 for interactive development\n5. Access application at configured PORT\n\n### Development Features\n- **Hot Reloading**: Development mode uses var indirection for handler reloading\n- **Auto Refresh**: ring-refresh dependency available but not yet integrated\n- **File Watching**: Beholder watches for CSS changes\n- **Interactive Development**: nREPL server for REPL-driven development\n\n### Testing Strategy\n- TestContainers for integration tests with real PostgreSQL\n- Kaocha as test runner with comprehensive reporting  \n- Separate test system setup in `test/example/test_system.clj`\n\n## Extension Points\n\n### Adding New Routes\n1. Create new route namespace following `example.hello.routes` pattern\n2. Add route to main routes vector in `example.routes/routes`\n3. Routes receive system context for database/worker access\n\n### Database Changes\n1. Add Flyway migration SQL files to resources\n2. Migrations run automatically on system startup\n3. Use next.jdbc and HoneySQL for queries\n\n### Background Jobs\n1. Define job processing functions in `example.jobs`\n2. Jobs receive system context and serialized payloads\n3. Use Proletarian worker API to enqueue jobs\n\n### Frontend Components\n1. Add new Stimulus controllers following existing pattern\n2. Update Shadow-CLJS configuration for new build targets\n3. Use Hiccup for server-side HTML generation\n\n### Middleware Integration\n1. Add new middleware functions to `example.middleware/standard-html-route-middleware` vector\n2. Middleware has access to system components via destructuring\n3. Follow Ring middleware patterns (functions returning functions)\n\n## Ring-Refresh Integration Status\n\n**Current Status**: ring-refresh is added as a dependency but not yet integrated into the middleware stack.\n\n**Integration Required**: \n1. Add `ring.middleware.refresh/wrap-refresh` to the middleware stack in development mode\n2. Consider conditional application only in development environment\n3. Ensure proper ordering in middleware chain (typically near the end)\n\n**Benefits**: Automatic browser refresh when Clojure files change, improving development experience.\n```"}],"isError":false}}
{"jsonrpc":"2.0","id":10,"result":{"content":[{"type":"text","text":"\nClojure Project Information:\n==============================\n\nEnvironment:\n• Working Directory: /Users/stepbeek/HappyValley/wick\n• Project Type: deps.edn\n• Clojure Version: 1.12.0\n• Java Version: 21.0.2\n\nSource Paths:\n• src\n• res\n• assets\n\nTest Paths:\n• test\n\nOther Relevant Accessible Directories:\n• /Users/stepbeek/HappyValley/wick\n\nDependencies:\n• cheshire/cheshire => {:mvn/version \"5.13.0\"}\n• com.github.seancorfield/honeysql => {:mvn/version \"2.6.1203\"}\n• com.github.seancorfield/next.jdbc => {:mvn/version \"1.3.955\"}\n• com.zaxxer/HikariCP => {:mvn/version \"6.0.0\"}\n• hiccup/hiccup => {:mvn/version \"2.0.0-RC3\"}\n• io.github.cdimascio/dotenv-java => {:mvn/version \"3.0.2\"}\n• metosin/reitit-ring => {:mvn/version \"0.7.2\"}\n• msolli/proletarian => {:mvn/version \"1.0.86-alpha\"}\n• org.clojure/clojure => {:mvn/version \"1.12.0\"}\n• org.clojure/tools.logging => {:mvn/version \"1.3.0\"}\n• org.flywaydb/flyway-core => {:mvn/version \"11.7.2\"}\n• org.flywaydb/flyway-database-postgresql => {:mvn/version \"11.7.2\"}\n• org.postgresql/postgresql => {:mvn/version \"42.7.4\"}\n• org.slf4j/slf4j-simple => {:mvn/version \"2.0.16\"}\n• ring/ring => {:mvn/version \"1.13.0\"}\n• ring/ring-defaults => {:mvn/version \"0.5.0\"}\n• ring-refresh/ring-refresh => {:mvn/version \"0.2.0\"}\n\nAliases:\n• :dev : {:extra-paths [\"dev\" \"test\"], :extra-deps {nrepl/nrepl {:mvn/version \"1.3.0\"}, lambdaisland/kaocha {:mvn/version \"1.91.1392\"}, thheller/shadow-cljs {:mvn/version \"2.28.18\"}, com.nextjournal/beholder {:mvn/version \"1.0.2\"}, org.testcontainers/postgresql {:mvn/version \"1.20.3\"}}, :jvm-opts [\"-Djdk.attach.allowAttachSelf\"], :main-opts [\"-m\" \"nrepl.cmdline\" \"--port\" \"7888\"]}\n• :format : {:deps {dev.weavejester/cljfmt {:mvn/version \"0.13.0\"}}}\n• :lint : {:deps {clj-kondo/clj-kondo {:mvn/version \"2024.09.27\"}}}\n\nNamespaces (16):\n• src.example.database.migrations\n• src.example.frontend.app\n• src.example.frontend.stimulus.controller.greetcontroller\n• src.example.frontend.stimulus.core\n• src.example.goodbye.routes\n• src.example.hello.routes\n• src.example.jobs\n• src.example.main\n• src.example.middleware\n• src.example.page-html.core\n• src.example.routes\n• src.example.static.routes\n• src.example.system\n• test.example.math-test\n• test.example.page-html.core-test\n• test.example.test-system\n\nProject Structure (17 files):\n• assets/public/js/manifest.edn\n• src/example/database/migrations.clj\n• src/example/frontend/app.cljs\n• src/example/frontend/stimulus/controller/greetcontroller.cljs\n• src/example/frontend/stimulus/core.cljs\n• src/example/goodbye/routes.clj\n• src/example/hello/routes.clj\n• src/example/jobs.clj\n• src/example/main.clj\n• src/example/middleware.clj\n• src/example/page_html/core.clj\n• src/example/routes.clj\n• src/example/static/routes.clj\n• src/example/system.clj\n• test/example/math_test.clj\n• test/example/page_html/core_test.clj\n• test/example/test_system.clj\n"}],"isError":false}}
{"jsonrpc":"2.0","id":11,"result":{"content":[{"type":"text","text":"nil"}],"isError":false}}
{"jsonrpc":"2.0","id":12,"result":{"content":[{"type":"text","text":"Exit code: 0"}],"isError":false}}
{"jsonrpc":"2.0","id":13,"result":{"tools":[{"name":"LS","description":"Returns a recursive tree view of files and directories starting from the specified path. The path parameter must be an absolute path, not a relative path. You should generally prefer the `glob_files` and `fx_grep` tools, if you know which directories to search.","inputSchema":{"type":"object","properties":{"path":{"type":"string"},"max_depth":{"type":"integer","description":"Maximum depth to traverse (optional)"},"limit":{"type":"integer","description":"Maximum number of entries to show (default: 100)"}},"required":["path"]}},{"name":"read_file","description":"Smart file reader with pattern-based exploration for Clojure files.\n   \nFor Clojure files (.clj, .cljc, .cljs, .bb):\n\nThis tool defaults to an expandable collapsed view to quickly grab the information you need from a Clojure file.\nIf called without `name_pattern` or `content_pattern` it will return the file content where \nyou will see only function signatures. This gives you a quick overview of the file.\n\nWhen you want to see more, this tool has a grep functionality where you\ncan give patterns to match the names for top level definitions\n`name_pattern` or match the bodies of top level definitions `content_pattern`.\n\nThe functions that match these patterns will be the only functions expanded in collapsed view.\n\nFor defmethod forms:\n- The name includes both the method name and the dispatch value (e.g., \"area :rectangle\")\n- For vector dispatch values, use the exact pattern (e.g., \"dispatch-with-vector \\[:feet :inches\\]\")\n- For qualified/namespaced multimethod names, include the namespace (e.g., \"tool-system/validate-inputs :clojure-eval\")\n\nFor text files (non-Clojure):\n- When `collapsed: true` and a pattern is provided (`content_pattern` or `name_pattern`), shows only lines matching the pattern with 10 lines of context before and after\n\nFor all other file types:\n- Collapsed view will not be applied and will return the raw contents of the file\n\nParameters:\n- path: Path to the file (required)\n- collapsed: Show collapsed view (default: true)\n\nCollapsed View mode function expansion parameters:\n\n- name_pattern: Regex to match function names (e.g., \"validate.*\")\n- content_pattern: Regex to match function content (e.g., \"try|catch\")\n\nExample usage for defmethod forms:\n- Find all implementations of a multimethod: `name_pattern: \"area\"`\n- Find specific dispatch values: `name_pattern: \"area :circle\"`\n- Find vector dispatch values: `name_pattern: \"convert-length \\\\[:feet :inches\\\\]\"`\n- Find namespace-qualified methods: `name_pattern: \"tool-system/validate-inputs\"`\n\nExample usage for text files:\n- Find error messages: `content_pattern: \"ERROR|WARN\"`\n- Find specific log entries: `content_pattern: \"\\\\[2024-01-15.*ERROR\\\\]\"`\n\nNon collapsed view mode respects these parameters:\n\n- line_offset: Line to start reading from (non-collapsed mode only, default: 0)\n- limit: Maximum lines to read (non-collapsed mode only, default: 2000)\n\nBy default, reads up to 2000 lines, truncating lines longer than 1000 characters.","inputSchema":{"type":"object","properties":{"path":{"type":"string","description":"Path to the file to read"},"collapsed":{"type":"boolean","description":"Whether to show collapsed view for Clojure files (default: true)"},"name_pattern":{"type":"string","description":"Pattern to match function names (e.g., \"validate.*\")"},"content_pattern":{"type":"string","description":"Pattern to match function content (e.g., \"try|catch\")"},"line_offset":{"type":"integer","description":"Line to start reading from for raw mode (default: 0)"},"limit":{"type":"integer","description":"Maximum lines to read (default: 2000)"}},"required":["path"]}},{"name":"grep","description":"Fast content search tool that works with any codebase size.\n- Finds the paths to files that have matching contents using regular expressions.\n- Supports full regex syntax (eg. \"log.*Error\", \"function\\s+\\w+\", etc.).\n- Filter files by pattern with the include parameter (eg. \"*.js\", \"*.{ts,tsx}\").\n- Returns matching file paths sorted by modification time.\n- Use this tool when you need to find files containing specific patterns.\n- When you are doing an open ended search that may require multiple rounds of globbing and grepping, use the `dispatch_agent` tool instead","inputSchema":{"type":"object","properties":{"path":{"type":"string","description":"The directory to search in. Defaults to the current working directory."},"pattern":{"type":"string","description":"The regular expression pattern to search for in file contents"},"include":{"type":"string","description":"File pattern to include in the search (e.g. \"*.clj\", \"*.{clj,cljs}\")"},"max_results":{"type":"integer","description":"Maximum number of results to return (default: 1000)"}},"required":["pattern"]}},{"name":"glob_files","description":"Fast file pattern matching tool that works with any codebase size.\n - Supports glob patterns like \"**/*.clj\" or \"src/**/*.cljs\".\n - Returns matching file paths sorted by modification time (most recent first).\n - Use this tool when you need to find files by name patterns.\n - When you are doing an open ended search that may require multiple rounds of globbing and grepping, use the `dispatch_agent` tool instead","inputSchema":{"type":"object","properties":{"path":{"type":"string","description":"Root directory to start the search from (defaults to current working directory)"},"pattern":{"type":"string","description":"Glob pattern (e.g. \"**/*.clj\", \"src/**/*.tsx\")"},"max_results":{"type":"integer","description":"Maximum number of results to return (default: 1000)"}},"required":["pattern"]}},{"name":"think","description":"Use the tool to think about something. It will not obtain new information or make any changes to the repository, but just log the thought. Use it when complex reasoning or brainstorming is needed. \nCommon use cases:\n* when having difficulty finding/reading the files you need\n* when having difficulty writing out code\n* when having difficulty using the tools or the clojure tools\n* When exploring a repository and discovering the source of a bug, call this tool to brainstorm several unique ways of fixing the bug, and assess which change(s) are likely to be simplest and most effective.\n* After receiving test results, use this tool to brainstorm ways to fix failing tests.\n* When planning a complex refactoring, use this tool to outline different approaches and their tradeoffs.\n* When designing a new feature, use this tool to think through architecture decisions and implementation details.\n* When debugging a complex issue, use this tool to organize your thoughts and hypotheses.\nThe tool simply logs your thought process for better transparency and does not execute any code or make changes.","inputSchema":{"type":"object","properties":{"thought":{"type":"string","description":"The thought to log"}},"required":["thought"]}},{"name":"scratch_pad","description":"A persistent scratch pad for storing structured data between tool calls. Accepts any JSON value (objects, arrays, strings, numbers, booleans, null) and stores them at nested paths using set_path, get_path, delete_path operations.\n\nTHIS IS YOUR GO-TO TOOL FOR PLANNING.\n\nYour persistent workspace for planning, organizing thoughts, and maintaining state across tool invocations.\n\nThis tool can be used to:\n * develop and track multi-step plans\n * maintain task lists and task tracking\n * store intermediate results between operations\n * keep notes about your current approach or strategy\n * maintain a list of files or resources to process\n * build up complex data structures incrementally\n * share context between different tool calls\n * any other persistent storage needs during your work\n\nThe scratch pad is for persistent storage and state management, not for formatting output. Display information directly in your chat responses. However, when the scratch pad contains user-relevant state (like tasks lists or tracked progress), you should retrieve and display updates after modifications.\n\nUse the scratch pad when you need to:\n- Track progress across multiple tool calls\n- Build data structures incrementally  \n- Maintain state between operations\n- Store intermediate results for later use\n\nDon't use the scratch pad to:\n- Format text for display\n- Store static information just to retrieve and show it\n- Replace direct chat responses\n\nCORE OPERATIONS:\n- set_path: Store a value (not null) at a path, returns the parent container\n- get_path: Retrieve a value from a path, returns the value or nil\n- delete_path: Remove only the leaf value from a path, returns a confirmation message\n- inspect: Display the entire structure (or a specific path) with truncation at specified depth\n\nWARNING: null values can not be stored in the scratch pad, if you attempt to store a null value the set_path will fail.\n\nTRACKING PLANS WITH TASK LISTS:\n\nRecommended schema for a Task:\n{\n  task: \"Description of the task\",\n  done: false,\n  priority: \"high\", // optional: \"high\", \"medium\", \"low\"\n  context: \"Additional details\", // optional\n  subtasks: [  // optional: array of subtask objects\n    {task: \"Subtask 1\", done: false},\n    {task: \"Subtask 2\", done: true}\n  ]\n}\n\nFirst add multiple tasks items at once as an array:\n- Entire array:\n  op: set_path\n  path: [\"tasks\"]\n  value: [\n    {task: \"Write tests\", done: false, priority: \"high\"},\n    {task: \"Review PR\", done: false, priority: \"high\"},\n    {task: \"Update docs\", done: false, priority: \"medium\", subtasks: [\n      {task: \"Update API docs\", done: false},\n      {task: \"Update README\", done: false}\n    ]}\n  ]\n  explanation: Adding multiple tasks at once\n\nAdding tasks items:\n- First item:\n  op: set_path\n  path: [\"tasks\", 3]\n  value: {task: \"Run tests\", done: false}\n  explanation: Adding write tests task\n\n- Next item:\n  op: set_path\n  path: [\"tasks\", 4]\n  value: {task: \"Notify user\", done: false, priority: \"high\"}\n  explanation: Adding high priority task\n\nChecking off completed tasks:\n- Mark as done:\n  op: set_path\n  path: [\"tasks\", 0, \"done\"]\n  value: true\n  explanation: Completed writing tests\n\n- Mark subtask as done:\n  op: set_path\n  path: [\"tasks\", 2, \"subtasks\", 0, \"done\"]\n  value: true\n  explanation: Completed API docs update\n\nAdding a new task to the array:\n- Append to array:\n  op: set_path\n  path: [\"tasks\", 3]\n  value: {task: \"Deploy to production\", done: false, priority: \"high\"}\n  explanation: Adding deployment task\n\nViewing tasks:\n- All tasks:\n  op: get_path\n  path: [\"tasks\"]\n  explanation: Get all tasks\n\n- Specific task:\n  op: get_path\n  path: [\"tasks\", 0]\n  explanation: Checking first task details\n\n- View with depth limit:\n  op: inspect\n  path: [\"tasks\"]\n  depth: 2\n  explanation: View tasks with limited nesting","inputSchema":{"type":"object","properties":{"op":{"type":"string","enum":["set_path","get_path","delete_path","inspect"],"description":"The operation to perform:\n * set_path: set a value at a path\n * get_path: retrieve a value at a path\n * delete_path: remove the value at the path from the data structure\n * inspect: view the datastructure (or a specific path within it) up to a certain depth\n"},"path":{"type":"array","items":{"type":"string"},"description":"Path to the data location (array of string or number keys) - used for set_path, get_path, delete_path, and optionally inspect"},"value":{"description":"Value to store (for set_path). Can be ANY JSON value EXCEPT null: object, array, string, number, boolean.","type":"object"},"explanation":{"type":"string","description":"Explanation of why this operation is being performed"},"depth":{"type":"number","description":"(Optional) For inspect operation: Maximum depth to display (default: 5). Must be a positive integer."}},"required":["op","explanation"]}},{"name":"clojure_eval","description":"Takes a Clojure Expression and evaluates it in the current namespace. For example, providing \"(+ 1 2)\" will evaluate to 3.\n\nThis tool is intended to execute Clojure code. This is very helpful for verifying that code is working as expected. It's also helpful for REPL driven development.\n\nIf you send multiple expressions they will all be evaluated individually and their output will be clearly partitioned.\n\nIf the returned value is too long it will be truncated.\n\nIMPORTANT: When using `require` to reload namespaces ALWAYS use `:reload` to ensure you get the latest version of files.\n\nREPL helper functions are automatically loaded in the 'clj-mcp.repl-tools' namespace, providing convenient namespace and symbol exploration:\n\nNamespace/Symbol inspection functions:\n  clj-mcp.repl-tools/list-ns           - List all available namespaces\n  clj-mcp.repl-tools/list-vars         - List all vars in namespace\n  clj-mcp.repl-tools/doc-symbol        - Show documentation for symbol\n  clj-mcp.repl-tools/source-symbol     - Show source code for symbol\n  clj-mcp.repl-tools/find-symbols      - Find symbols matching pattern\n  clj-mcp.repl-tools/complete          - Find completions for prefix\n  clj-mcp.repl-tools/help              - Show this help message\n\nExamples:\n  (clj-mcp.repl-tools/list-ns)                     ; List all namespaces\n  (clj-mcp.repl-tools/list-vars 'clojure.string)   ; List functions in clojure.string\n  (clj-mcp.repl-tools/doc-symbol 'map)             ; Show documentation for map\n  (clj-mcp.repl-tools/source-symbol 'map)          ; Show source code for map\n  (clj-mcp.repl-tools/find-symbols \"seq\")          ; Find symbols containing \"seq\"\n  (clj-mcp.repl-tools/complete \"clojure.string/j\") ; Find completions for prefix","inputSchema":{"type":"object","properties":{"code":{"type":"string","description":"The Clojure code to evaluate."}},"required":["code"]}},{"name":"bash","description":"Execute bash shell commands on the host system.\n\nExamples:\n1. List files: bash(command: \"ls -la\")\n2. Find text in files: bash(command: \"grep -r 'pattern' /path/to/search\")\n3. With working directory: bash(command: \"ls -la\", working_directory: \"/tmp\")\n4. With timeout: bash(command: \"sleep 10\", timeout_ms: 5000)\n5. Git commands \n\nFor long running processes like running tests increase the timeout_ms so that the process can complete.\n\nNote: Non-zero exit codes are NOT treated as tool errors - check exit_code\nin the response to determine command success.","inputSchema":{"type":"object","properties":{"command":{"type":"string","description":"The shell command to execute"},"working_directory":{"type":"string","description":"Directory to run the command in (optional)"},"timeout_ms":{"type":"integer","description":"Maximum execution time in milliseconds (optional, default: 30000)"}},"required":["command"]}},{"name":"clojure_edit","description":"Edits a top-level form (`defn`, `def`, `defmethod`, `ns`, `deftest`) in a Clojure file using the specified operation.\n   \nPREFER this unified tool over generic file editing tools for Clojure files (`.clj` `.cljs` `.cljc` `.bb`)\n\nThis tool MAKES it EASIER to match a definition that exists in the file AS you only have to match the type of definition `form_type` and the complete identifier `form_identifier` of the definition. This prevents the repeated mismatch errors that occur when trying match an entire string of text for replacement.\nThis tool validates the structure of the Clojure code that is being inserted into the file and will provide linting feedback for things such as parenthetical errors.\nThis tool reduces the number of tokens that need to be generated.\n \nWARNING: you will receive errors if the syntax is wrong, the most common error is an extra or missing parenthesis in the `content`, so be careful with parenthesis.\n\n   Operations:\n   - \"replace\": Replaces the form with new content\n   - \"insert_before\": Inserts content before the form\n   - \"insert_after\": Inserts content after the form\n   \n   The form is identified by its type (defn, def, deftest, s/def, ns, defmethod etc.) and complete identifier.\n   \n   Example: Replace a function definition:\n   - file_path: \"/path/to/file.clj\"\n   - form_identifier: \"example-fn\"\n   - form_type: \"defn\"\n   - operation: \"replace\"\n   - content: \"(defn example-fn [x] (* x 2))\"\n   \n   Example: Insert a helper function before a function:\n   - file_path: \"/path/to/file.clj\"\n   - form_identifier: \"example-fn\"\n   - form_type: \"defn\"\n   - operation: \"insert_before\"\n   - content: \"(defn helper-fn [x] (* x 2))\"\n   \n   Example: Insert a test after a function:\n   - file_path: \"/path/to/file.clj\"\n   - form_identifier: \"example-fn\"\n   - form_type: \"defn\"\n   - operation: \"insert_after\"\n   - content: \"(deftest example-fn-test\n  (is (= 4 (example-fn 2))))\"\n   \nNote: For `defmethod` forms, be sure to include the dispatch value (`area :rectangle` or `qualified/area :rectangle`) in the `form_identifier`. Many `defmethod` definitions have qualified names (they include a namespace alias in their identifier like `shape/area`), so it's crucial to use the complete identifier that appears in the file.\n\n   Example: Replace a specific `defmethod` implementation:\n   - file_path: \"/path/to/file.clj\"\n   - form_identifier: \"shape/area :square\"\n   - form_type: \"defmethod\"\n   - operation: \"replace\"\n   - content: \"(defmethod shape/area :square [{:keys [w h]}] (* w h))\"\n\n   Example: Work with vector dispatch values:\n   - file_path: \"/path/to/file.clj\"\n   - form_identifier: \"convert-length [:feet :inches]\"\n   - form_type: \"defmethod\"\n   - operation: \"insert_before\"\n   - content: \"(def inches-per-foot 12)\"\n\n   The tool will find the form, perform the requested operation, and format the result.\n   It returns a diff showing the changes made to the file.","inputSchema":{"type":"object","properties":{"file_path":{"type":"string","description":"Path to the file containing the form to edit"},"form_identifier":{"type":"string","description":"Complete identifier of the form (e.g., function name, \"shape/area\", or \"convert-length [:feet :inches]\")"},"form_type":{"type":"string","description":"Type of the form (e.g., \"defn\", \"def\", \"ns\")"},"operation":{"type":"string","enum":["replace","insert_before","insert_after"],"description":"The editing operation to perform"},"content":{"type":"string","description":"New content to use for the operation"}},"required":["file_path","form_identifier","form_type","operation","content"]}},{"name":"clojure_edit_replace_sexp","description":"Edits a file by finding and replacing specific s-expressions.\n\nUse this tool for targeted edits of sub-expressions within forms. For complete top-level form replacements, prefer specialized tools like `clojure_edit_replace_definition` and friends.\n\nKEY BENEFITS:\n- Syntax-aware matching that understands Clojure code structure\n- Ignores whitespace differences by default, focusing on actual code meaning\n- Matches expressions regardless of formatting, indentation, or spacing\n- Prevents errors from mismatched text or irrelevant formatting differences\n- Can find and replace all occurrences with replace_all: true\n\nCONSTRAINTS:\n- match_form must contain only a SINGLE s-expression (error otherwise)\n- Requires syntactically valid Clojure expressions in both match_form and new_form\n\nWARNING: You will receive errors if the syntax is wrong. The most common error is an extra or missing parenthesis in either match_form or new_form, so count your parentheses carefully!\n\nCOMMON APPLICATIONS:\n- Renaming symbols throughout the file: {\"match_form\": \"old-name\", \"new_form\": \"new-name\", \"replace_all\": true}\n- Editing special forms like if/cond/let/when within functions:\n  * Changing if branches: {\"match_form\": \"(if condition expr1 expr2)\", \"new_form\": \"(if condition (do expr1) expr2)\"}\n  * Enhancing let bindings: {\"match_form\": \"(let [x 10] (+ x 2))\", \"new_form\": \"(let [x 10 y 20] (+ x y))\"}\n  * Converting cond to case: {\"match_form\": \"(cond (= x :a) \\\"A\\\" (= x :b) \\\"B\\\")\", \"new_form\": \"(case x :a \\\"A\\\" :b \\\"B\\\")\"}\n- Modifying nested function calls: {\"match_form\": \"(str (+ a b))\", \"new_form\": \"(str (+ a b c))\"}\n- Changing anonymous function syntax: {\"match_form\": \"#(update % :count inc)\", \"new_form\": \"(fn [x] (update x :count inc))\"}\n\nOther Examples:\n- Replace a calculation: {\"match_form\": \"(+ x 2)\", \"new_form\": \"(+ x 10)\"}\n  * Will match regardless of spaces: (+ x 2), (+   x   2), etc.\n- Delete an expression: {\"match_form\": \"(println debug-info)\", \"new_form\": \"\"}\n- Edit anonymous function: {\"match_form\": \"#(inc %)\", \"new_form\": \"#(+ % 2)\"}\n- Replace multiple occurrences: {\"match_form\": \"(inc x)\", \"new_form\": \"(+ x 1)\", \"replace_all\": true}\n\nReturns a diff showing the changes made to the file.","inputSchema":{"type":"object","properties":{"file_path":{"type":"string","description":"Path to the file to edit"},"match_form":{"type":"string","description":"The s-expression to find and replace (include # for anonymous functions)"},"new_form":{"type":"string","description":"The s-expression to replace with"},"replace_all":{"type":"boolean","description":"Whether to replace all occurrences (default: false)"}},"required":["file_path","match_form","new_form"]}},{"name":"file_edit","description":"Edit a file by replacing a specific text string with a new one. For safety, this tool requires that the string to replace appears exactly once in the file. \n\nFIRST: the clojure_edit tool is prefered because they use precise structural rewrite-clj editing. They also incorporate linting and ensure balance parenthesis.\n\nWHEN the clojure_edit tool won't work or you have a small easy edit \n\nPREFER the file_write tool for replacing more than half a file, this saves on tokens\n\nFor Clojure files (.clj, .cljs, .cljc, .edn):\n- Content will be linted for syntax errors before writing\n- Content will be formatted according to Clojure standards\n- Writing will fail if linting detects syntax errors\n\nTo make a file edit, provide the file_path, old_string (the text to replace), and new_string (the replacement text). The old_string must uniquely identify the specific instance you want to change, so include several lines of context before and after the change point. To create a new file, use file_write instead.","inputSchema":{"type":"object","properties":{"file_path":{"type":"string","description":"The absolute path to the file to modify (must be absolute, not relative)"},"old_string":{"type":"string","description":"The text to replace (must match the file contents exactly, including all whitespace and indentation)."},"new_string":{"type":"string","description":"The edited text to replace the old_string"}},"required":["file_path","old_string","new_string"]}},{"name":"file_write","description":"Write a file to the local filesystem. Overwrites the existing file if there is one.\n\nFor Clojure files (.clj, .cljs, .cljc, .edn):\n- Content will be linted for syntax errors before writing\n- Content will be formatted according to Clojure standards\n- Writing will fail if linting detects syntax errors\n\nFor other file types:\n- Content is written directly without linting or formatting\n\nIMPORTANT SAFETY FEATURE:\n- If the file has been modified since it was last read, writing will fail\n- You must use read_file to get the current content before editing a file\n- This prevents accidental overwrites of external changes\n\nReturns information about whether the file was created or updated, along with a diff \nshowing the changes made.\n\nBefore using this tool:\n1. Use the read_file tool to understand the file's contents and context\n2. Directory Verification (only applicable when creating new files):\n   - Use the list_directory tool to verify the parent directory exists and is the correct location\n3. For Clojure files, ensure code is syntactically correct\n\n# Example:\n# file_write(\n#   file_path: \"/absolute/path/to/file.clj\",\n#   content: \"(ns my.namespace)\\n\\n(defn my-function [x]\\n  (* x 2))\"\n# )","inputSchema":{"type":"object","properties":{"file_path":{"type":"string","description":"The absolute path to the file to write (must be absolute, not relative)"},"content":{"type":"string","description":"The content to write to the file"}},"required":["file_path","content"]}},{"name":"clojure_inspect_project","description":"Analyzes and provides detailed information about a Clojure project's structure, \nincluding dependencies, source files, namespaces, and environment details.\n\nThis tool helps you understand project organization without having to manually \nexplore multiple configuration files. It works with both deps.edn and Leiningen projects.\n\nThe tool provides information about:\n- Project environment (working directory, Clojure version, Java version)\n- Source and test paths\n- Dependencies and their versions\n- Aliases and their configurations\n- Available namespaces\n- Source file structure\n\nUse this tool to quickly get oriented in an unfamiliar Clojure codebase or to \nget a high-level overview of your current project.\n\n# Example:\nclojure_inspect_project()","inputSchema":{"type":"object","properties":{"explanation":{"type":"string","description":"Short explanation why you chose this tool"}},"required":["explanation"]}},{"name":"dispatch_agent","description":"Launch a new agent that has access to read-only tools. When you are searching for a keyword or file and are not confident that you will find the right match on the first try, use the Agent tool to perform the search for you. For example:\n\n- If you are searching for a keyword like \"config\" or \"logger\", the Agent tool is appropriate\n- If you want to read a specific file path, use the read_file or glob_files tool instead of the Agent tool, to find the match more quickly\n- If you are searching for a specific class definition like \"class Foo\", use the glob_files tool instead, to find the match more quickly\n\nUsage notes:\n1. Launch multiple agents concurrently whenever possible, to maximize performance; to do that, use a single message with multiple `agent` tool uses\n2. When the agent is done, it will return a single message back to you. The result returned by the agent is not visible to the user. To show the user the result, you should send a text message back to the user with a concise summary of the result.\n3. Each agent invocation is stateless. You will not be able to send additional messages to the agent, nor will the agent be able to communicate with you outside of its final report. Therefore, your prompt should contain a highly detailed task description for the agent to perform autonomously and you should specify exactly what information the agent should return back to you in its final and only message to you.\n4. The agent's outputs should generally be trusted","inputSchema":{"type":"object","properties":{"prompt":{"type":"string","description":"The prompt to send to the agent"}},"required":["prompt"]}},{"name":"architect","description":"Your go-to tool for any technical or coding task. Analyzes requirements and breaks them down into clear, actionable implementation steps. Use this whenever you need help planning how to implement a feature, solve a technical problem, or structure your code.","inputSchema":{"type":"object","properties":{"prompt":{"type":"string","description":"The technical request or coding task to analyze"},"context":{"type":"string","description":"Optional context from previous conversation or system state"}},"required":["prompt"]}},{"name":"code_critique","description":"Starts an interactive code review conversation that provides constructive feedback on your Clojure code.\n  \n  HOW TO USE THIS TOOL:\n  1. Submit your Clojure code for initial critique\n  2. Review the suggestions and implement improvements\n  3. Test your revised code in the REPL\n  4. Submit the updated code for additional feedback\n  5. Continue this cycle until the critique is satisfied\n  \n  This tool initiates a feedback loop where you:\n  - Receive detailed analysis of your code\n  - Implement suggested improvements\n  - Test and verify changes\n  - Get follow-up critique on your revisions\n  \n  The critique examines:\n  - Adherence to Clojure style conventions\n  - Functional programming best practices\n  - Performance optimizations\n  - Readability and maintainability improvements\n  - Idiomatic Clojure patterns\n  \n  Example conversation flow:\n  - You: Submit initial function implementation\n  - Tool: Provides feedback on style and structure\n  - You: Revise code based on suggestions and test in REPL\n  - Tool: Reviews updates and suggests further refinements\n  - Repeat until code quality goals are achieved\n  \n  Perfect for iterative learning and continuous code improvement.","inputSchema":{"type":"object","properties":{"code":{"type":"string","description":"The Clojure code to analyze and critique"},"context":{"type":"string","description":"Optional context from previous conversation or system state"}},"required":["code"]}}]}}
{"jsonrpc":"2.0","id":14,"result":{"resources":[{"uri":"custom://llm-code-style","name":"LLM_CODE_STYLE.md","description":"Guidelines for writing Clojure code for the current project hosting the REPL","mimeType":"text/markdown"},{"uri":"custom://project-summary","name":"PROJECT_SUMMARY.md","description":"A Clojure project summary document for the project hosting the REPL, this is intended to provide the LLM with important context to start.","mimeType":"text/markdown"},{"uri":"custom://claude","name":"CLAUDE.md","description":"The Claude instructions document for the current project hosting the REPL","mimeType":"text/markdown"},{"uri":"custom://readme","name":"README.md","description":"A README document for the current Clojure project hosting the REPL","mimeType":"text/markdown"},{"uri":"custom://project-info","name":"Clojure Project Info","description":"Information about the current Clojure project structure, attached REPL environment and dependencies","mimeType":"text/markdown"}]}}
{"jsonrpc":"2.0","id":15,"result":{"prompts":[{"name":"ACT/scratch_pad_load","description":"Loads a file into the scratch pad state. Returns status messages and a shallow inspect of the loaded data.","arguments":[{"name":"file_path","description":"Optional file path: default scratch_pad.edn","required":false}]},{"name":"clojure_repl_system_prompt","description":"Provides instructions and guidelines for Clojure development, including style and best practices.","arguments":[]},{"name":"create-update-project-summary","description":"Generates a prompt instructing the LLM to create a summary of a project.","arguments":[]},{"name":"chat-session-summarize","description":"Instructs the assistant to create a summary of the current chat session and store it in the scratch pad. `chat_session_key` is optional and will default to `chat_session_summary`","arguments":[{"name":"chat_session_key","description":"[Optional] key to store the session summary in","required":false}]},{"name":"ACT/scratch_pad_save_as","description":"Saves the current scratch pad state to a specified file.","arguments":[{"name":"file_path","description":"File path: relative to .clojure-mcp/ directory","required":true}]},{"name":"chat-session-resume","description":"Instructs the assistant to resume a previous chat session by loading context from the scratch pad. `chat_session_key` is optional and will default to `chat_session_summary`","arguments":[{"name":"chat_session_key","description":"[Optional] key where session summary is stored","required":false}]},{"name":"ACT/add-dir","description":"Adds a directory to the allowed-directories list, giving the LLM access to it","arguments":[{"name":"directory","description":"Directory path to add (can be relative or absolute)","required":true}]},{"name":"plan-and-execute","description":"Use the scratch pad tool to plan and execute an change","arguments":[]}]}}
{"jsonrpc":"2.0","id":16,"result":{"content":[{"type":"text","text":"# THIS IS A COLLAPSED VIEW /Users/stepbeek/HappyValley/wick/src/example/system.clj\nSet `collapsed: false` to view the entire file\nMatching name_pattern: \"port|PORT\" (0 expanded, 13 collapsed)\n*** `/Users/stepbeek/HappyValley/wick/src/example/system.clj`\n```clojure\n(ns example.system\n  (:require [example.database.migrations :as db-migrations]\n            [example.jobs :as jobs]\n            [example.routes :as routes]\n            [next.jdbc.connection :as connection]\n            [proletarian.worker :as worker]\n            [ring.adapter.jetty :as jetty]\n            [ring.middleware.session.cookie :as session-cookie])\n  (:import (com.zaxxer.hikari HikariDataSource)\n           (io.github.cdimascio.dotenv Dotenv)\n           (org.eclipse.jetty.server Server)))\n\n(set! *warn-on-reflection* ...)\n\n(defn start-env [] ...)\n\n(defn start-cookie-store [] ...)\n\n(defn db-config [env] ...)\n\n(defn start-db [{::keys [env]}] ...)\n\n(defn stop-db [db] ...)\n\n(defn start-worker [{::keys [db] :as system}] ...)\n\n(defn stop-worker [worker] ...)\n\n(defn start-server [{::keys [env] :as system}] ...)\n\n(defn stop-server [server] ...)\n\n(defn start-system [] ...)\n\n(defn stop-system [system] ...)\n```\n\n## `read_file` Tool Usage Tips\n\n- Use `name_pattern` with regex to match function names (e.g., \"validate.*\")\n- Use `content_pattern` to find code containing specific text (e.g., \"try|catch\")\n- For defmethod forms: Include the dispatch value (e.g., \"area :rectangle\" or \"dispatch-with-vector \\[:feet :inches\\]\")\n- For namespaced methods: Include namespace (e.g., \"tool-system/validate-inputs :clojure-eval\")\n- For spec forms: Pattern match on keywords (e.g., \"::user\" or \":domain/user\")\n- Reader conditionals display with platform syntax: #?(:clj ...)\n- Set `collapsed: false` to view the entire file\n"}],"isError":false}}
{"jsonrpc":"2.0","id":17,"result":{"content":[{"type":"text","text":"# THIS IS A COLLAPSED VIEW /Users/stepbeek/HappyValley/wick/src/example/system.clj\nSet `collapsed: false` to view the entire file\nMatching name_pattern: \"start-server\" (1 expanded, 12 collapsed)\n*** `/Users/stepbeek/HappyValley/wick/src/example/system.clj`\n```clojure\n(ns example.system\n  (:require [example.database.migrations :as db-migrations]\n            [example.jobs :as jobs]\n            [example.routes :as routes]\n            [next.jdbc.connection :as connection]\n            [proletarian.worker :as worker]\n            [ring.adapter.jetty :as jetty]\n            [ring.middleware.session.cookie :as session-cookie])\n  (:import (com.zaxxer.hikari HikariDataSource)\n           (io.github.cdimascio.dotenv Dotenv)\n           (org.eclipse.jetty.server Server)))\n\n(set! *warn-on-reflection* ...)\n\n(defn start-env [] ...)\n\n(defn start-cookie-store [] ...)\n\n(defn db-config [env] ...)\n\n(defn start-db [{::keys [env]}] ...)\n\n(defn stop-db [db] ...)\n\n(defn start-worker [{::keys [db] :as system}] ...)\n\n(defn stop-worker [worker] ...)\n\n(defn start-server\n  [{::keys [env] :as system}]\n  (let [handler (if (= (Dotenv/.get env \"ENVIRONMENT\") \"development\")\n                  (partial #'routes/root-handler system)\n                  (routes/root-handler system))]\n    (jetty/run-jetty\n     handler\n     {:port  (Long/parseLong (Dotenv/.get env \"PORT\"))\n      :join? false})))\n\n(defn stop-server [server] ...)\n\n(defn start-system [] ...)\n\n(defn stop-system [system] ...)\n```\n\n## `read_file` Tool Usage Tips\n\n- Use `name_pattern` with regex to match function names (e.g., \"validate.*\")\n- Use `content_pattern` to find code containing specific text (e.g., \"try|catch\")\n- For defmethod forms: Include the dispatch value (e.g., \"area :rectangle\" or \"dispatch-with-vector \\[:feet :inches\\]\")\n- For namespaced methods: Include namespace (e.g., \"tool-system/validate-inputs :clojure-eval\")\n- For spec forms: Pattern match on keywords (e.g., \"::user\" or \":domain/user\")\n- Reader conditionals display with platform syntax: #?(:clj ...)\n- Set `collapsed: false` to view the entire file\n"}],"isError":false}}
{"jsonrpc":"2.0","id":18,"result":{"content":[{"type":"text","text":"Exit code: 0"},{"type":"text","text":"Standard output:\n-rw-r--r--@   1 stepbeek  staff     143 30 Apr 21:15 .env\n"}],"isError":false}}
{"jsonrpc":"2.0","id":19,"result":{"tools":[{"name":"LS","description":"Returns a recursive tree view of files and directories starting from the specified path. The path parameter must be an absolute path, not a relative path. You should generally prefer the `glob_files` and `fx_grep` tools, if you know which directories to search.","inputSchema":{"type":"object","properties":{"path":{"type":"string"},"max_depth":{"type":"integer","description":"Maximum depth to traverse (optional)"},"limit":{"type":"integer","description":"Maximum number of entries to show (default: 100)"}},"required":["path"]}},{"name":"read_file","description":"Smart file reader with pattern-based exploration for Clojure files.\n   \nFor Clojure files (.clj, .cljc, .cljs, .bb):\n\nThis tool defaults to an expandable collapsed view to quickly grab the information you need from a Clojure file.\nIf called without `name_pattern` or `content_pattern` it will return the file content where \nyou will see only function signatures. This gives you a quick overview of the file.\n\nWhen you want to see more, this tool has a grep functionality where you\ncan give patterns to match the names for top level definitions\n`name_pattern` or match the bodies of top level definitions `content_pattern`.\n\nThe functions that match these patterns will be the only functions expanded in collapsed view.\n\nFor defmethod forms:\n- The name includes both the method name and the dispatch value (e.g., \"area :rectangle\")\n- For vector dispatch values, use the exact pattern (e.g., \"dispatch-with-vector \\[:feet :inches\\]\")\n- For qualified/namespaced multimethod names, include the namespace (e.g., \"tool-system/validate-inputs :clojure-eval\")\n\nFor text files (non-Clojure):\n- When `collapsed: true` and a pattern is provided (`content_pattern` or `name_pattern`), shows only lines matching the pattern with 10 lines of context before and after\n\nFor all other file types:\n- Collapsed view will not be applied and will return the raw contents of the file\n\nParameters:\n- path: Path to the file (required)\n- collapsed: Show collapsed view (default: true)\n\nCollapsed View mode function expansion parameters:\n\n- name_pattern: Regex to match function names (e.g., \"validate.*\")\n- content_pattern: Regex to match function content (e.g., \"try|catch\")\n\nExample usage for defmethod forms:\n- Find all implementations of a multimethod: `name_pattern: \"area\"`\n- Find specific dispatch values: `name_pattern: \"area :circle\"`\n- Find vector dispatch values: `name_pattern: \"convert-length \\\\[:feet :inches\\\\]\"`\n- Find namespace-qualified methods: `name_pattern: \"tool-system/validate-inputs\"`\n\nExample usage for text files:\n- Find error messages: `content_pattern: \"ERROR|WARN\"`\n- Find specific log entries: `content_pattern: \"\\\\[2024-01-15.*ERROR\\\\]\"`\n\nNon collapsed view mode respects these parameters:\n\n- line_offset: Line to start reading from (non-collapsed mode only, default: 0)\n- limit: Maximum lines to read (non-collapsed mode only, default: 2000)\n\nBy default, reads up to 2000 lines, truncating lines longer than 1000 characters.","inputSchema":{"type":"object","properties":{"path":{"type":"string","description":"Path to the file to read"},"collapsed":{"type":"boolean","description":"Whether to show collapsed view for Clojure files (default: true)"},"name_pattern":{"type":"string","description":"Pattern to match function names (e.g., \"validate.*\")"},"content_pattern":{"type":"string","description":"Pattern to match function content (e.g., \"try|catch\")"},"line_offset":{"type":"integer","description":"Line to start reading from for raw mode (default: 0)"},"limit":{"type":"integer","description":"Maximum lines to read (default: 2000)"}},"required":["path"]}},{"name":"grep","description":"Fast content search tool that works with any codebase size.\n- Finds the paths to files that have matching contents using regular expressions.\n- Supports full regex syntax (eg. \"log.*Error\", \"function\\s+\\w+\", etc.).\n- Filter files by pattern with the include parameter (eg. \"*.js\", \"*.{ts,tsx}\").\n- Returns matching file paths sorted by modification time.\n- Use this tool when you need to find files containing specific patterns.\n- When you are doing an open ended search that may require multiple rounds of globbing and grepping, use the `dispatch_agent` tool instead","inputSchema":{"type":"object","properties":{"path":{"type":"string","description":"The directory to search in. Defaults to the current working directory."},"pattern":{"type":"string","description":"The regular expression pattern to search for in file contents"},"include":{"type":"string","description":"File pattern to include in the search (e.g. \"*.clj\", \"*.{clj,cljs}\")"},"max_results":{"type":"integer","description":"Maximum number of results to return (default: 1000)"}},"required":["pattern"]}},{"name":"glob_files","description":"Fast file pattern matching tool that works with any codebase size.\n - Supports glob patterns like \"**/*.clj\" or \"src/**/*.cljs\".\n - Returns matching file paths sorted by modification time (most recent first).\n - Use this tool when you need to find files by name patterns.\n - When you are doing an open ended search that may require multiple rounds of globbing and grepping, use the `dispatch_agent` tool instead","inputSchema":{"type":"object","properties":{"path":{"type":"string","description":"Root directory to start the search from (defaults to current working directory)"},"pattern":{"type":"string","description":"Glob pattern (e.g. \"**/*.clj\", \"src/**/*.tsx\")"},"max_results":{"type":"integer","description":"Maximum number of results to return (default: 1000)"}},"required":["pattern"]}},{"name":"think","description":"Use the tool to think about something. It will not obtain new information or make any changes to the repository, but just log the thought. Use it when complex reasoning or brainstorming is needed. \nCommon use cases:\n* when having difficulty finding/reading the files you need\n* when having difficulty writing out code\n* when having difficulty using the tools or the clojure tools\n* When exploring a repository and discovering the source of a bug, call this tool to brainstorm several unique ways of fixing the bug, and assess which change(s) are likely to be simplest and most effective.\n* After receiving test results, use this tool to brainstorm ways to fix failing tests.\n* When planning a complex refactoring, use this tool to outline different approaches and their tradeoffs.\n* When designing a new feature, use this tool to think through architecture decisions and implementation details.\n* When debugging a complex issue, use this tool to organize your thoughts and hypotheses.\nThe tool simply logs your thought process for better transparency and does not execute any code or make changes.","inputSchema":{"type":"object","properties":{"thought":{"type":"string","description":"The thought to log"}},"required":["thought"]}},{"name":"scratch_pad","description":"A persistent scratch pad for storing structured data between tool calls. Accepts any JSON value (objects, arrays, strings, numbers, booleans, null) and stores them at nested paths using set_path, get_path, delete_path operations.\n\nTHIS IS YOUR GO-TO TOOL FOR PLANNING.\n\nYour persistent workspace for planning, organizing thoughts, and maintaining state across tool invocations.\n\nThis tool can be used to:\n * develop and track multi-step plans\n * maintain task lists and task tracking\n * store intermediate results between operations\n * keep notes about your current approach or strategy\n * maintain a list of files or resources to process\n * build up complex data structures incrementally\n * share context between different tool calls\n * any other persistent storage needs during your work\n\nThe scratch pad is for persistent storage and state management, not for formatting output. Display information directly in your chat responses. However, when the scratch pad contains user-relevant state (like tasks lists or tracked progress), you should retrieve and display updates after modifications.\n\nUse the scratch pad when you need to:\n- Track progress across multiple tool calls\n- Build data structures incrementally  \n- Maintain state between operations\n- Store intermediate results for later use\n\nDon't use the scratch pad to:\n- Format text for display\n- Store static information just to retrieve and show it\n- Replace direct chat responses\n\nCORE OPERATIONS:\n- set_path: Store a value (not null) at a path, returns the parent container\n- get_path: Retrieve a value from a path, returns the value or nil\n- delete_path: Remove only the leaf value from a path, returns a confirmation message\n- inspect: Display the entire structure (or a specific path) with truncation at specified depth\n\nWARNING: null values can not be stored in the scratch pad, if you attempt to store a null value the set_path will fail.\n\nTRACKING PLANS WITH TASK LISTS:\n\nRecommended schema for a Task:\n{\n  task: \"Description of the task\",\n  done: false,\n  priority: \"high\", // optional: \"high\", \"medium\", \"low\"\n  context: \"Additional details\", // optional\n  subtasks: [  // optional: array of subtask objects\n    {task: \"Subtask 1\", done: false},\n    {task: \"Subtask 2\", done: true}\n  ]\n}\n\nFirst add multiple tasks items at once as an array:\n- Entire array:\n  op: set_path\n  path: [\"tasks\"]\n  value: [\n    {task: \"Write tests\", done: false, priority: \"high\"},\n    {task: \"Review PR\", done: false, priority: \"high\"},\n    {task: \"Update docs\", done: false, priority: \"medium\", subtasks: [\n      {task: \"Update API docs\", done: false},\n      {task: \"Update README\", done: false}\n    ]}\n  ]\n  explanation: Adding multiple tasks at once\n\nAdding tasks items:\n- First item:\n  op: set_path\n  path: [\"tasks\", 3]\n  value: {task: \"Run tests\", done: false}\n  explanation: Adding write tests task\n\n- Next item:\n  op: set_path\n  path: [\"tasks\", 4]\n  value: {task: \"Notify user\", done: false, priority: \"high\"}\n  explanation: Adding high priority task\n\nChecking off completed tasks:\n- Mark as done:\n  op: set_path\n  path: [\"tasks\", 0, \"done\"]\n  value: true\n  explanation: Completed writing tests\n\n- Mark subtask as done:\n  op: set_path\n  path: [\"tasks\", 2, \"subtasks\", 0, \"done\"]\n  value: true\n  explanation: Completed API docs update\n\nAdding a new task to the array:\n- Append to array:\n  op: set_path\n  path: [\"tasks\", 3]\n  value: {task: \"Deploy to production\", done: false, priority: \"high\"}\n  explanation: Adding deployment task\n\nViewing tasks:\n- All tasks:\n  op: get_path\n  path: [\"tasks\"]\n  explanation: Get all tasks\n\n- Specific task:\n  op: get_path\n  path: [\"tasks\", 0]\n  explanation: Checking first task details\n\n- View with depth limit:\n  op: inspect\n  path: [\"tasks\"]\n  depth: 2\n  explanation: View tasks with limited nesting","inputSchema":{"type":"object","properties":{"op":{"type":"string","enum":["set_path","get_path","delete_path","inspect"],"description":"The operation to perform:\n * set_path: set a value at a path\n * get_path: retrieve a value at a path\n * delete_path: remove the value at the path from the data structure\n * inspect: view the datastructure (or a specific path within it) up to a certain depth\n"},"path":{"type":"array","items":{"type":"string"},"description":"Path to the data location (array of string or number keys) - used for set_path, get_path, delete_path, and optionally inspect"},"value":{"description":"Value to store (for set_path). Can be ANY JSON value EXCEPT null: object, array, string, number, boolean.","type":"object"},"explanation":{"type":"string","description":"Explanation of why this operation is being performed"},"depth":{"type":"number","description":"(Optional) For inspect operation: Maximum depth to display (default: 5). Must be a positive integer."}},"required":["op","explanation"]}},{"name":"clojure_eval","description":"Takes a Clojure Expression and evaluates it in the current namespace. For example, providing \"(+ 1 2)\" will evaluate to 3.\n\nThis tool is intended to execute Clojure code. This is very helpful for verifying that code is working as expected. It's also helpful for REPL driven development.\n\nIf you send multiple expressions they will all be evaluated individually and their output will be clearly partitioned.\n\nIf the returned value is too long it will be truncated.\n\nIMPORTANT: When using `require` to reload namespaces ALWAYS use `:reload` to ensure you get the latest version of files.\n\nREPL helper functions are automatically loaded in the 'clj-mcp.repl-tools' namespace, providing convenient namespace and symbol exploration:\n\nNamespace/Symbol inspection functions:\n  clj-mcp.repl-tools/list-ns           - List all available namespaces\n  clj-mcp.repl-tools/list-vars         - List all vars in namespace\n  clj-mcp.repl-tools/doc-symbol        - Show documentation for symbol\n  clj-mcp.repl-tools/source-symbol     - Show source code for symbol\n  clj-mcp.repl-tools/find-symbols      - Find symbols matching pattern\n  clj-mcp.repl-tools/complete          - Find completions for prefix\n  clj-mcp.repl-tools/help              - Show this help message\n\nExamples:\n  (clj-mcp.repl-tools/list-ns)                     ; List all namespaces\n  (clj-mcp.repl-tools/list-vars 'clojure.string)   ; List functions in clojure.string\n  (clj-mcp.repl-tools/doc-symbol 'map)             ; Show documentation for map\n  (clj-mcp.repl-tools/source-symbol 'map)          ; Show source code for map\n  (clj-mcp.repl-tools/find-symbols \"seq\")          ; Find symbols containing \"seq\"\n  (clj-mcp.repl-tools/complete \"clojure.string/j\") ; Find completions for prefix","inputSchema":{"type":"object","properties":{"code":{"type":"string","description":"The Clojure code to evaluate."}},"required":["code"]}},{"name":"bash","description":"Execute bash shell commands on the host system.\n\nExamples:\n1. List files: bash(command: \"ls -la\")\n2. Find text in files: bash(command: \"grep -r 'pattern' /path/to/search\")\n3. With working directory: bash(command: \"ls -la\", working_directory: \"/tmp\")\n4. With timeout: bash(command: \"sleep 10\", timeout_ms: 5000)\n5. Git commands \n\nFor long running processes like running tests increase the timeout_ms so that the process can complete.\n\nNote: Non-zero exit codes are NOT treated as tool errors - check exit_code\nin the response to determine command success.","inputSchema":{"type":"object","properties":{"command":{"type":"string","description":"The shell command to execute"},"working_directory":{"type":"string","description":"Directory to run the command in (optional)"},"timeout_ms":{"type":"integer","description":"Maximum execution time in milliseconds (optional, default: 30000)"}},"required":["command"]}},{"name":"clojure_edit","description":"Edits a top-level form (`defn`, `def`, `defmethod`, `ns`, `deftest`) in a Clojure file using the specified operation.\n   \nPREFER this unified tool over generic file editing tools for Clojure files (`.clj` `.cljs` `.cljc` `.bb`)\n\nThis tool MAKES it EASIER to match a definition that exists in the file AS you only have to match the type of definition `form_type` and the complete identifier `form_identifier` of the definition. This prevents the repeated mismatch errors that occur when trying match an entire string of text for replacement.\nThis tool validates the structure of the Clojure code that is being inserted into the file and will provide linting feedback for things such as parenthetical errors.\nThis tool reduces the number of tokens that need to be generated.\n \nWARNING: you will receive errors if the syntax is wrong, the most common error is an extra or missing parenthesis in the `content`, so be careful with parenthesis.\n\n   Operations:\n   - \"replace\": Replaces the form with new content\n   - \"insert_before\": Inserts content before the form\n   - \"insert_after\": Inserts content after the form\n   \n   The form is identified by its type (defn, def, deftest, s/def, ns, defmethod etc.) and complete identifier.\n   \n   Example: Replace a function definition:\n   - file_path: \"/path/to/file.clj\"\n   - form_identifier: \"example-fn\"\n   - form_type: \"defn\"\n   - operation: \"replace\"\n   - content: \"(defn example-fn [x] (* x 2))\"\n   \n   Example: Insert a helper function before a function:\n   - file_path: \"/path/to/file.clj\"\n   - form_identifier: \"example-fn\"\n   - form_type: \"defn\"\n   - operation: \"insert_before\"\n   - content: \"(defn helper-fn [x] (* x 2))\"\n   \n   Example: Insert a test after a function:\n   - file_path: \"/path/to/file.clj\"\n   - form_identifier: \"example-fn\"\n   - form_type: \"defn\"\n   - operation: \"insert_after\"\n   - content: \"(deftest example-fn-test\n  (is (= 4 (example-fn 2))))\"\n   \nNote: For `defmethod` forms, be sure to include the dispatch value (`area :rectangle` or `qualified/area :rectangle`) in the `form_identifier`. Many `defmethod` definitions have qualified names (they include a namespace alias in their identifier like `shape/area`), so it's crucial to use the complete identifier that appears in the file.\n\n   Example: Replace a specific `defmethod` implementation:\n   - file_path: \"/path/to/file.clj\"\n   - form_identifier: \"shape/area :square\"\n   - form_type: \"defmethod\"\n   - operation: \"replace\"\n   - content: \"(defmethod shape/area :square [{:keys [w h]}] (* w h))\"\n\n   Example: Work with vector dispatch values:\n   - file_path: \"/path/to/file.clj\"\n   - form_identifier: \"convert-length [:feet :inches]\"\n   - form_type: \"defmethod\"\n   - operation: \"insert_before\"\n   - content: \"(def inches-per-foot 12)\"\n\n   The tool will find the form, perform the requested operation, and format the result.\n   It returns a diff showing the changes made to the file.","inputSchema":{"type":"object","properties":{"file_path":{"type":"string","description":"Path to the file containing the form to edit"},"form_identifier":{"type":"string","description":"Complete identifier of the form (e.g., function name, \"shape/area\", or \"convert-length [:feet :inches]\")"},"form_type":{"type":"string","description":"Type of the form (e.g., \"defn\", \"def\", \"ns\")"},"operation":{"type":"string","enum":["replace","insert_before","insert_after"],"description":"The editing operation to perform"},"content":{"type":"string","description":"New content to use for the operation"}},"required":["file_path","form_identifier","form_type","operation","content"]}},{"name":"clojure_edit_replace_sexp","description":"Edits a file by finding and replacing specific s-expressions.\n\nUse this tool for targeted edits of sub-expressions within forms. For complete top-level form replacements, prefer specialized tools like `clojure_edit_replace_definition` and friends.\n\nKEY BENEFITS:\n- Syntax-aware matching that understands Clojure code structure\n- Ignores whitespace differences by default, focusing on actual code meaning\n- Matches expressions regardless of formatting, indentation, or spacing\n- Prevents errors from mismatched text or irrelevant formatting differences\n- Can find and replace all occurrences with replace_all: true\n\nCONSTRAINTS:\n- match_form must contain only a SINGLE s-expression (error otherwise)\n- Requires syntactically valid Clojure expressions in both match_form and new_form\n\nWARNING: You will receive errors if the syntax is wrong. The most common error is an extra or missing parenthesis in either match_form or new_form, so count your parentheses carefully!\n\nCOMMON APPLICATIONS:\n- Renaming symbols throughout the file: {\"match_form\": \"old-name\", \"new_form\": \"new-name\", \"replace_all\": true}\n- Editing special forms like if/cond/let/when within functions:\n  * Changing if branches: {\"match_form\": \"(if condition expr1 expr2)\", \"new_form\": \"(if condition (do expr1) expr2)\"}\n  * Enhancing let bindings: {\"match_form\": \"(let [x 10] (+ x 2))\", \"new_form\": \"(let [x 10 y 20] (+ x y))\"}\n  * Converting cond to case: {\"match_form\": \"(cond (= x :a) \\\"A\\\" (= x :b) \\\"B\\\")\", \"new_form\": \"(case x :a \\\"A\\\" :b \\\"B\\\")\"}\n- Modifying nested function calls: {\"match_form\": \"(str (+ a b))\", \"new_form\": \"(str (+ a b c))\"}\n- Changing anonymous function syntax: {\"match_form\": \"#(update % :count inc)\", \"new_form\": \"(fn [x] (update x :count inc))\"}\n\nOther Examples:\n- Replace a calculation: {\"match_form\": \"(+ x 2)\", \"new_form\": \"(+ x 10)\"}\n  * Will match regardless of spaces: (+ x 2), (+   x   2), etc.\n- Delete an expression: {\"match_form\": \"(println debug-info)\", \"new_form\": \"\"}\n- Edit anonymous function: {\"match_form\": \"#(inc %)\", \"new_form\": \"#(+ % 2)\"}\n- Replace multiple occurrences: {\"match_form\": \"(inc x)\", \"new_form\": \"(+ x 1)\", \"replace_all\": true}\n\nReturns a diff showing the changes made to the file.","inputSchema":{"type":"object","properties":{"file_path":{"type":"string","description":"Path to the file to edit"},"match_form":{"type":"string","description":"The s-expression to find and replace (include # for anonymous functions)"},"new_form":{"type":"string","description":"The s-expression to replace with"},"replace_all":{"type":"boolean","description":"Whether to replace all occurrences (default: false)"}},"required":["file_path","match_form","new_form"]}},{"name":"file_edit","description":"Edit a file by replacing a specific text string with a new one. For safety, this tool requires that the string to replace appears exactly once in the file. \n\nFIRST: the clojure_edit tool is prefered because they use precise structural rewrite-clj editing. They also incorporate linting and ensure balance parenthesis.\n\nWHEN the clojure_edit tool won't work or you have a small easy edit \n\nPREFER the file_write tool for replacing more than half a file, this saves on tokens\n\nFor Clojure files (.clj, .cljs, .cljc, .edn):\n- Content will be linted for syntax errors before writing\n- Content will be formatted according to Clojure standards\n- Writing will fail if linting detects syntax errors\n\nTo make a file edit, provide the file_path, old_string (the text to replace), and new_string (the replacement text). The old_string must uniquely identify the specific instance you want to change, so include several lines of context before and after the change point. To create a new file, use file_write instead.","inputSchema":{"type":"object","properties":{"file_path":{"type":"string","description":"The absolute path to the file to modify (must be absolute, not relative)"},"old_string":{"type":"string","description":"The text to replace (must match the file contents exactly, including all whitespace and indentation)."},"new_string":{"type":"string","description":"The edited text to replace the old_string"}},"required":["file_path","old_string","new_string"]}},{"name":"file_write","description":"Write a file to the local filesystem. Overwrites the existing file if there is one.\n\nFor Clojure files (.clj, .cljs, .cljc, .edn):\n- Content will be linted for syntax errors before writing\n- Content will be formatted according to Clojure standards\n- Writing will fail if linting detects syntax errors\n\nFor other file types:\n- Content is written directly without linting or formatting\n\nIMPORTANT SAFETY FEATURE:\n- If the file has been modified since it was last read, writing will fail\n- You must use read_file to get the current content before editing a file\n- This prevents accidental overwrites of external changes\n\nReturns information about whether the file was created or updated, along with a diff \nshowing the changes made.\n\nBefore using this tool:\n1. Use the read_file tool to understand the file's contents and context\n2. Directory Verification (only applicable when creating new files):\n   - Use the list_directory tool to verify the parent directory exists and is the correct location\n3. For Clojure files, ensure code is syntactically correct\n\n# Example:\n# file_write(\n#   file_path: \"/absolute/path/to/file.clj\",\n#   content: \"(ns my.namespace)\\n\\n(defn my-function [x]\\n  (* x 2))\"\n# )","inputSchema":{"type":"object","properties":{"file_path":{"type":"string","description":"The absolute path to the file to write (must be absolute, not relative)"},"content":{"type":"string","description":"The content to write to the file"}},"required":["file_path","content"]}},{"name":"clojure_inspect_project","description":"Analyzes and provides detailed information about a Clojure project's structure, \nincluding dependencies, source files, namespaces, and environment details.\n\nThis tool helps you understand project organization without having to manually \nexplore multiple configuration files. It works with both deps.edn and Leiningen projects.\n\nThe tool provides information about:\n- Project environment (working directory, Clojure version, Java version)\n- Source and test paths\n- Dependencies and their versions\n- Aliases and their configurations\n- Available namespaces\n- Source file structure\n\nUse this tool to quickly get oriented in an unfamiliar Clojure codebase or to \nget a high-level overview of your current project.\n\n# Example:\nclojure_inspect_project()","inputSchema":{"type":"object","properties":{"explanation":{"type":"string","description":"Short explanation why you chose this tool"}},"required":["explanation"]}},{"name":"dispatch_agent","description":"Launch a new agent that has access to read-only tools. When you are searching for a keyword or file and are not confident that you will find the right match on the first try, use the Agent tool to perform the search for you. For example:\n\n- If you are searching for a keyword like \"config\" or \"logger\", the Agent tool is appropriate\n- If you want to read a specific file path, use the read_file or glob_files tool instead of the Agent tool, to find the match more quickly\n- If you are searching for a specific class definition like \"class Foo\", use the glob_files tool instead, to find the match more quickly\n\nUsage notes:\n1. Launch multiple agents concurrently whenever possible, to maximize performance; to do that, use a single message with multiple `agent` tool uses\n2. When the agent is done, it will return a single message back to you. The result returned by the agent is not visible to the user. To show the user the result, you should send a text message back to the user with a concise summary of the result.\n3. Each agent invocation is stateless. You will not be able to send additional messages to the agent, nor will the agent be able to communicate with you outside of its final report. Therefore, your prompt should contain a highly detailed task description for the agent to perform autonomously and you should specify exactly what information the agent should return back to you in its final and only message to you.\n4. The agent's outputs should generally be trusted","inputSchema":{"type":"object","properties":{"prompt":{"type":"string","description":"The prompt to send to the agent"}},"required":["prompt"]}},{"name":"architect","description":"Your go-to tool for any technical or coding task. Analyzes requirements and breaks them down into clear, actionable implementation steps. Use this whenever you need help planning how to implement a feature, solve a technical problem, or structure your code.","inputSchema":{"type":"object","properties":{"prompt":{"type":"string","description":"The technical request or coding task to analyze"},"context":{"type":"string","description":"Optional context from previous conversation or system state"}},"required":["prompt"]}},{"name":"code_critique","description":"Starts an interactive code review conversation that provides constructive feedback on your Clojure code.\n  \n  HOW TO USE THIS TOOL:\n  1. Submit your Clojure code for initial critique\n  2. Review the suggestions and implement improvements\n  3. Test your revised code in the REPL\n  4. Submit the updated code for additional feedback\n  5. Continue this cycle until the critique is satisfied\n  \n  This tool initiates a feedback loop where you:\n  - Receive detailed analysis of your code\n  - Implement suggested improvements\n  - Test and verify changes\n  - Get follow-up critique on your revisions\n  \n  The critique examines:\n  - Adherence to Clojure style conventions\n  - Functional programming best practices\n  - Performance optimizations\n  - Readability and maintainability improvements\n  - Idiomatic Clojure patterns\n  \n  Example conversation flow:\n  - You: Submit initial function implementation\n  - Tool: Provides feedback on style and structure\n  - You: Revise code based on suggestions and test in REPL\n  - Tool: Reviews updates and suggests further refinements\n  - Repeat until code quality goals are achieved\n  \n  Perfect for iterative learning and continuous code improvement.","inputSchema":{"type":"object","properties":{"code":{"type":"string","description":"The Clojure code to analyze and critique"},"context":{"type":"string","description":"Optional context from previous conversation or system state"}},"required":["code"]}}]}}
{"jsonrpc":"2.0","id":20,"result":{"resources":[{"uri":"custom://llm-code-style","name":"LLM_CODE_STYLE.md","description":"Guidelines for writing Clojure code for the current project hosting the REPL","mimeType":"text/markdown"},{"uri":"custom://project-summary","name":"PROJECT_SUMMARY.md","description":"A Clojure project summary document for the project hosting the REPL, this is intended to provide the LLM with important context to start.","mimeType":"text/markdown"},{"uri":"custom://claude","name":"CLAUDE.md","description":"The Claude instructions document for the current project hosting the REPL","mimeType":"text/markdown"},{"uri":"custom://readme","name":"README.md","description":"A README document for the current Clojure project hosting the REPL","mimeType":"text/markdown"},{"uri":"custom://project-info","name":"Clojure Project Info","description":"Information about the current Clojure project structure, attached REPL environment and dependencies","mimeType":"text/markdown"}]}}
{"jsonrpc":"2.0","id":21,"result":{"prompts":[{"name":"ACT/scratch_pad_load","description":"Loads a file into the scratch pad state. Returns status messages and a shallow inspect of the loaded data.","arguments":[{"name":"file_path","description":"Optional file path: default scratch_pad.edn","required":false}]},{"name":"clojure_repl_system_prompt","description":"Provides instructions and guidelines for Clojure development, including style and best practices.","arguments":[]},{"name":"create-update-project-summary","description":"Generates a prompt instructing the LLM to create a summary of a project.","arguments":[]},{"name":"chat-session-summarize","description":"Instructs the assistant to create a summary of the current chat session and store it in the scratch pad. `chat_session_key` is optional and will default to `chat_session_summary`","arguments":[{"name":"chat_session_key","description":"[Optional] key to store the session summary in","required":false}]},{"name":"ACT/scratch_pad_save_as","description":"Saves the current scratch pad state to a specified file.","arguments":[{"name":"file_path","description":"File path: relative to .clojure-mcp/ directory","required":true}]},{"name":"chat-session-resume","description":"Instructs the assistant to resume a previous chat session by loading context from the scratch pad. `chat_session_key` is optional and will default to `chat_session_summary`","arguments":[{"name":"chat_session_key","description":"[Optional] key where session summary is stored","required":false}]},{"name":"ACT/add-dir","description":"Adds a directory to the allowed-directories list, giving the LLM access to it","arguments":[{"name":"directory","description":"Directory path to add (can be relative or absolute)","required":true}]},{"name":"plan-and-execute","description":"Use the scratch pad tool to plan and execute an change","arguments":[]}]}}
{"jsonrpc":"2.0","id":22,"result":{"tools":[{"name":"LS","description":"Returns a recursive tree view of files and directories starting from the specified path. The path parameter must be an absolute path, not a relative path. You should generally prefer the `glob_files` and `fx_grep` tools, if you know which directories to search.","inputSchema":{"type":"object","properties":{"path":{"type":"string"},"max_depth":{"type":"integer","description":"Maximum depth to traverse (optional)"},"limit":{"type":"integer","description":"Maximum number of entries to show (default: 100)"}},"required":["path"]}},{"name":"read_file","description":"Smart file reader with pattern-based exploration for Clojure files.\n   \nFor Clojure files (.clj, .cljc, .cljs, .bb):\n\nThis tool defaults to an expandable collapsed view to quickly grab the information you need from a Clojure file.\nIf called without `name_pattern` or `content_pattern` it will return the file content where \nyou will see only function signatures. This gives you a quick overview of the file.\n\nWhen you want to see more, this tool has a grep functionality where you\ncan give patterns to match the names for top level definitions\n`name_pattern` or match the bodies of top level definitions `content_pattern`.\n\nThe functions that match these patterns will be the only functions expanded in collapsed view.\n\nFor defmethod forms:\n- The name includes both the method name and the dispatch value (e.g., \"area :rectangle\")\n- For vector dispatch values, use the exact pattern (e.g., \"dispatch-with-vector \\[:feet :inches\\]\")\n- For qualified/namespaced multimethod names, include the namespace (e.g., \"tool-system/validate-inputs :clojure-eval\")\n\nFor text files (non-Clojure):\n- When `collapsed: true` and a pattern is provided (`content_pattern` or `name_pattern`), shows only lines matching the pattern with 10 lines of context before and after\n\nFor all other file types:\n- Collapsed view will not be applied and will return the raw contents of the file\n\nParameters:\n- path: Path to the file (required)\n- collapsed: Show collapsed view (default: true)\n\nCollapsed View mode function expansion parameters:\n\n- name_pattern: Regex to match function names (e.g., \"validate.*\")\n- content_pattern: Regex to match function content (e.g., \"try|catch\")\n\nExample usage for defmethod forms:\n- Find all implementations of a multimethod: `name_pattern: \"area\"`\n- Find specific dispatch values: `name_pattern: \"area :circle\"`\n- Find vector dispatch values: `name_pattern: \"convert-length \\\\[:feet :inches\\\\]\"`\n- Find namespace-qualified methods: `name_pattern: \"tool-system/validate-inputs\"`\n\nExample usage for text files:\n- Find error messages: `content_pattern: \"ERROR|WARN\"`\n- Find specific log entries: `content_pattern: \"\\\\[2024-01-15.*ERROR\\\\]\"`\n\nNon collapsed view mode respects these parameters:\n\n- line_offset: Line to start reading from (non-collapsed mode only, default: 0)\n- limit: Maximum lines to read (non-collapsed mode only, default: 2000)\n\nBy default, reads up to 2000 lines, truncating lines longer than 1000 characters.","inputSchema":{"type":"object","properties":{"path":{"type":"string","description":"Path to the file to read"},"collapsed":{"type":"boolean","description":"Whether to show collapsed view for Clojure files (default: true)"},"name_pattern":{"type":"string","description":"Pattern to match function names (e.g., \"validate.*\")"},"content_pattern":{"type":"string","description":"Pattern to match function content (e.g., \"try|catch\")"},"line_offset":{"type":"integer","description":"Line to start reading from for raw mode (default: 0)"},"limit":{"type":"integer","description":"Maximum lines to read (default: 2000)"}},"required":["path"]}},{"name":"grep","description":"Fast content search tool that works with any codebase size.\n- Finds the paths to files that have matching contents using regular expressions.\n- Supports full regex syntax (eg. \"log.*Error\", \"function\\s+\\w+\", etc.).\n- Filter files by pattern with the include parameter (eg. \"*.js\", \"*.{ts,tsx}\").\n- Returns matching file paths sorted by modification time.\n- Use this tool when you need to find files containing specific patterns.\n- When you are doing an open ended search that may require multiple rounds of globbing and grepping, use the `dispatch_agent` tool instead","inputSchema":{"type":"object","properties":{"path":{"type":"string","description":"The directory to search in. Defaults to the current working directory."},"pattern":{"type":"string","description":"The regular expression pattern to search for in file contents"},"include":{"type":"string","description":"File pattern to include in the search (e.g. \"*.clj\", \"*.{clj,cljs}\")"},"max_results":{"type":"integer","description":"Maximum number of results to return (default: 1000)"}},"required":["pattern"]}},{"name":"glob_files","description":"Fast file pattern matching tool that works with any codebase size.\n - Supports glob patterns like \"**/*.clj\" or \"src/**/*.cljs\".\n - Returns matching file paths sorted by modification time (most recent first).\n - Use this tool when you need to find files by name patterns.\n - When you are doing an open ended search that may require multiple rounds of globbing and grepping, use the `dispatch_agent` tool instead","inputSchema":{"type":"object","properties":{"path":{"type":"string","description":"Root directory to start the search from (defaults to current working directory)"},"pattern":{"type":"string","description":"Glob pattern (e.g. \"**/*.clj\", \"src/**/*.tsx\")"},"max_results":{"type":"integer","description":"Maximum number of results to return (default: 1000)"}},"required":["pattern"]}},{"name":"think","description":"Use the tool to think about something. It will not obtain new information or make any changes to the repository, but just log the thought. Use it when complex reasoning or brainstorming is needed. \nCommon use cases:\n* when having difficulty finding/reading the files you need\n* when having difficulty writing out code\n* when having difficulty using the tools or the clojure tools\n* When exploring a repository and discovering the source of a bug, call this tool to brainstorm several unique ways of fixing the bug, and assess which change(s) are likely to be simplest and most effective.\n* After receiving test results, use this tool to brainstorm ways to fix failing tests.\n* When planning a complex refactoring, use this tool to outline different approaches and their tradeoffs.\n* When designing a new feature, use this tool to think through architecture decisions and implementation details.\n* When debugging a complex issue, use this tool to organize your thoughts and hypotheses.\nThe tool simply logs your thought process for better transparency and does not execute any code or make changes.","inputSchema":{"type":"object","properties":{"thought":{"type":"string","description":"The thought to log"}},"required":["thought"]}},{"name":"scratch_pad","description":"A persistent scratch pad for storing structured data between tool calls. Accepts any JSON value (objects, arrays, strings, numbers, booleans, null) and stores them at nested paths using set_path, get_path, delete_path operations.\n\nTHIS IS YOUR GO-TO TOOL FOR PLANNING.\n\nYour persistent workspace for planning, organizing thoughts, and maintaining state across tool invocations.\n\nThis tool can be used to:\n * develop and track multi-step plans\n * maintain task lists and task tracking\n * store intermediate results between operations\n * keep notes about your current approach or strategy\n * maintain a list of files or resources to process\n * build up complex data structures incrementally\n * share context between different tool calls\n * any other persistent storage needs during your work\n\nThe scratch pad is for persistent storage and state management, not for formatting output. Display information directly in your chat responses. However, when the scratch pad contains user-relevant state (like tasks lists or tracked progress), you should retrieve and display updates after modifications.\n\nUse the scratch pad when you need to:\n- Track progress across multiple tool calls\n- Build data structures incrementally  \n- Maintain state between operations\n- Store intermediate results for later use\n\nDon't use the scratch pad to:\n- Format text for display\n- Store static information just to retrieve and show it\n- Replace direct chat responses\n\nCORE OPERATIONS:\n- set_path: Store a value (not null) at a path, returns the parent container\n- get_path: Retrieve a value from a path, returns the value or nil\n- delete_path: Remove only the leaf value from a path, returns a confirmation message\n- inspect: Display the entire structure (or a specific path) with truncation at specified depth\n\nWARNING: null values can not be stored in the scratch pad, if you attempt to store a null value the set_path will fail.\n\nTRACKING PLANS WITH TASK LISTS:\n\nRecommended schema for a Task:\n{\n  task: \"Description of the task\",\n  done: false,\n  priority: \"high\", // optional: \"high\", \"medium\", \"low\"\n  context: \"Additional details\", // optional\n  subtasks: [  // optional: array of subtask objects\n    {task: \"Subtask 1\", done: false},\n    {task: \"Subtask 2\", done: true}\n  ]\n}\n\nFirst add multiple tasks items at once as an array:\n- Entire array:\n  op: set_path\n  path: [\"tasks\"]\n  value: [\n    {task: \"Write tests\", done: false, priority: \"high\"},\n    {task: \"Review PR\", done: false, priority: \"high\"},\n    {task: \"Update docs\", done: false, priority: \"medium\", subtasks: [\n      {task: \"Update API docs\", done: false},\n      {task: \"Update README\", done: false}\n    ]}\n  ]\n  explanation: Adding multiple tasks at once\n\nAdding tasks items:\n- First item:\n  op: set_path\n  path: [\"tasks\", 3]\n  value: {task: \"Run tests\", done: false}\n  explanation: Adding write tests task\n\n- Next item:\n  op: set_path\n  path: [\"tasks\", 4]\n  value: {task: \"Notify user\", done: false, priority: \"high\"}\n  explanation: Adding high priority task\n\nChecking off completed tasks:\n- Mark as done:\n  op: set_path\n  path: [\"tasks\", 0, \"done\"]\n  value: true\n  explanation: Completed writing tests\n\n- Mark subtask as done:\n  op: set_path\n  path: [\"tasks\", 2, \"subtasks\", 0, \"done\"]\n  value: true\n  explanation: Completed API docs update\n\nAdding a new task to the array:\n- Append to array:\n  op: set_path\n  path: [\"tasks\", 3]\n  value: {task: \"Deploy to production\", done: false, priority: \"high\"}\n  explanation: Adding deployment task\n\nViewing tasks:\n- All tasks:\n  op: get_path\n  path: [\"tasks\"]\n  explanation: Get all tasks\n\n- Specific task:\n  op: get_path\n  path: [\"tasks\", 0]\n  explanation: Checking first task details\n\n- View with depth limit:\n  op: inspect\n  path: [\"tasks\"]\n  depth: 2\n  explanation: View tasks with limited nesting","inputSchema":{"type":"object","properties":{"op":{"type":"string","enum":["set_path","get_path","delete_path","inspect"],"description":"The operation to perform:\n * set_path: set a value at a path\n * get_path: retrieve a value at a path\n * delete_path: remove the value at the path from the data structure\n * inspect: view the datastructure (or a specific path within it) up to a certain depth\n"},"path":{"type":"array","items":{"type":"string"},"description":"Path to the data location (array of string or number keys) - used for set_path, get_path, delete_path, and optionally inspect"},"value":{"description":"Value to store (for set_path). Can be ANY JSON value EXCEPT null: object, array, string, number, boolean.","type":"object"},"explanation":{"type":"string","description":"Explanation of why this operation is being performed"},"depth":{"type":"number","description":"(Optional) For inspect operation: Maximum depth to display (default: 5). Must be a positive integer."}},"required":["op","explanation"]}},{"name":"clojure_eval","description":"Takes a Clojure Expression and evaluates it in the current namespace. For example, providing \"(+ 1 2)\" will evaluate to 3.\n\nThis tool is intended to execute Clojure code. This is very helpful for verifying that code is working as expected. It's also helpful for REPL driven development.\n\nIf you send multiple expressions they will all be evaluated individually and their output will be clearly partitioned.\n\nIf the returned value is too long it will be truncated.\n\nIMPORTANT: When using `require` to reload namespaces ALWAYS use `:reload` to ensure you get the latest version of files.\n\nREPL helper functions are automatically loaded in the 'clj-mcp.repl-tools' namespace, providing convenient namespace and symbol exploration:\n\nNamespace/Symbol inspection functions:\n  clj-mcp.repl-tools/list-ns           - List all available namespaces\n  clj-mcp.repl-tools/list-vars         - List all vars in namespace\n  clj-mcp.repl-tools/doc-symbol        - Show documentation for symbol\n  clj-mcp.repl-tools/source-symbol     - Show source code for symbol\n  clj-mcp.repl-tools/find-symbols      - Find symbols matching pattern\n  clj-mcp.repl-tools/complete          - Find completions for prefix\n  clj-mcp.repl-tools/help              - Show this help message\n\nExamples:\n  (clj-mcp.repl-tools/list-ns)                     ; List all namespaces\n  (clj-mcp.repl-tools/list-vars 'clojure.string)   ; List functions in clojure.string\n  (clj-mcp.repl-tools/doc-symbol 'map)             ; Show documentation for map\n  (clj-mcp.repl-tools/source-symbol 'map)          ; Show source code for map\n  (clj-mcp.repl-tools/find-symbols \"seq\")          ; Find symbols containing \"seq\"\n  (clj-mcp.repl-tools/complete \"clojure.string/j\") ; Find completions for prefix","inputSchema":{"type":"object","properties":{"code":{"type":"string","description":"The Clojure code to evaluate."}},"required":["code"]}},{"name":"bash","description":"Execute bash shell commands on the host system.\n\nExamples:\n1. List files: bash(command: \"ls -la\")\n2. Find text in files: bash(command: \"grep -r 'pattern' /path/to/search\")\n3. With working directory: bash(command: \"ls -la\", working_directory: \"/tmp\")\n4. With timeout: bash(command: \"sleep 10\", timeout_ms: 5000)\n5. Git commands \n\nFor long running processes like running tests increase the timeout_ms so that the process can complete.\n\nNote: Non-zero exit codes are NOT treated as tool errors - check exit_code\nin the response to determine command success.","inputSchema":{"type":"object","properties":{"command":{"type":"string","description":"The shell command to execute"},"working_directory":{"type":"string","description":"Directory to run the command in (optional)"},"timeout_ms":{"type":"integer","description":"Maximum execution time in milliseconds (optional, default: 30000)"}},"required":["command"]}},{"name":"clojure_edit","description":"Edits a top-level form (`defn`, `def`, `defmethod`, `ns`, `deftest`) in a Clojure file using the specified operation.\n   \nPREFER this unified tool over generic file editing tools for Clojure files (`.clj` `.cljs` `.cljc` `.bb`)\n\nThis tool MAKES it EASIER to match a definition that exists in the file AS you only have to match the type of definition `form_type` and the complete identifier `form_identifier` of the definition. This prevents the repeated mismatch errors that occur when trying match an entire string of text for replacement.\nThis tool validates the structure of the Clojure code that is being inserted into the file and will provide linting feedback for things such as parenthetical errors.\nThis tool reduces the number of tokens that need to be generated.\n \nWARNING: you will receive errors if the syntax is wrong, the most common error is an extra or missing parenthesis in the `content`, so be careful with parenthesis.\n\n   Operations:\n   - \"replace\": Replaces the form with new content\n   - \"insert_before\": Inserts content before the form\n   - \"insert_after\": Inserts content after the form\n   \n   The form is identified by its type (defn, def, deftest, s/def, ns, defmethod etc.) and complete identifier.\n   \n   Example: Replace a function definition:\n   - file_path: \"/path/to/file.clj\"\n   - form_identifier: \"example-fn\"\n   - form_type: \"defn\"\n   - operation: \"replace\"\n   - content: \"(defn example-fn [x] (* x 2))\"\n   \n   Example: Insert a helper function before a function:\n   - file_path: \"/path/to/file.clj\"\n   - form_identifier: \"example-fn\"\n   - form_type: \"defn\"\n   - operation: \"insert_before\"\n   - content: \"(defn helper-fn [x] (* x 2))\"\n   \n   Example: Insert a test after a function:\n   - file_path: \"/path/to/file.clj\"\n   - form_identifier: \"example-fn\"\n   - form_type: \"defn\"\n   - operation: \"insert_after\"\n   - content: \"(deftest example-fn-test\n  (is (= 4 (example-fn 2))))\"\n   \nNote: For `defmethod` forms, be sure to include the dispatch value (`area :rectangle` or `qualified/area :rectangle`) in the `form_identifier`. Many `defmethod` definitions have qualified names (they include a namespace alias in their identifier like `shape/area`), so it's crucial to use the complete identifier that appears in the file.\n\n   Example: Replace a specific `defmethod` implementation:\n   - file_path: \"/path/to/file.clj\"\n   - form_identifier: \"shape/area :square\"\n   - form_type: \"defmethod\"\n   - operation: \"replace\"\n   - content: \"(defmethod shape/area :square [{:keys [w h]}] (* w h))\"\n\n   Example: Work with vector dispatch values:\n   - file_path: \"/path/to/file.clj\"\n   - form_identifier: \"convert-length [:feet :inches]\"\n   - form_type: \"defmethod\"\n   - operation: \"insert_before\"\n   - content: \"(def inches-per-foot 12)\"\n\n   The tool will find the form, perform the requested operation, and format the result.\n   It returns a diff showing the changes made to the file.","inputSchema":{"type":"object","properties":{"file_path":{"type":"string","description":"Path to the file containing the form to edit"},"form_identifier":{"type":"string","description":"Complete identifier of the form (e.g., function name, \"shape/area\", or \"convert-length [:feet :inches]\")"},"form_type":{"type":"string","description":"Type of the form (e.g., \"defn\", \"def\", \"ns\")"},"operation":{"type":"string","enum":["replace","insert_before","insert_after"],"description":"The editing operation to perform"},"content":{"type":"string","description":"New content to use for the operation"}},"required":["file_path","form_identifier","form_type","operation","content"]}},{"name":"clojure_edit_replace_sexp","description":"Edits a file by finding and replacing specific s-expressions.\n\nUse this tool for targeted edits of sub-expressions within forms. For complete top-level form replacements, prefer specialized tools like `clojure_edit_replace_definition` and friends.\n\nKEY BENEFITS:\n- Syntax-aware matching that understands Clojure code structure\n- Ignores whitespace differences by default, focusing on actual code meaning\n- Matches expressions regardless of formatting, indentation, or spacing\n- Prevents errors from mismatched text or irrelevant formatting differences\n- Can find and replace all occurrences with replace_all: true\n\nCONSTRAINTS:\n- match_form must contain only a SINGLE s-expression (error otherwise)\n- Requires syntactically valid Clojure expressions in both match_form and new_form\n\nWARNING: You will receive errors if the syntax is wrong. The most common error is an extra or missing parenthesis in either match_form or new_form, so count your parentheses carefully!\n\nCOMMON APPLICATIONS:\n- Renaming symbols throughout the file: {\"match_form\": \"old-name\", \"new_form\": \"new-name\", \"replace_all\": true}\n- Editing special forms like if/cond/let/when within functions:\n  * Changing if branches: {\"match_form\": \"(if condition expr1 expr2)\", \"new_form\": \"(if condition (do expr1) expr2)\"}\n  * Enhancing let bindings: {\"match_form\": \"(let [x 10] (+ x 2))\", \"new_form\": \"(let [x 10 y 20] (+ x y))\"}\n  * Converting cond to case: {\"match_form\": \"(cond (= x :a) \\\"A\\\" (= x :b) \\\"B\\\")\", \"new_form\": \"(case x :a \\\"A\\\" :b \\\"B\\\")\"}\n- Modifying nested function calls: {\"match_form\": \"(str (+ a b))\", \"new_form\": \"(str (+ a b c))\"}\n- Changing anonymous function syntax: {\"match_form\": \"#(update % :count inc)\", \"new_form\": \"(fn [x] (update x :count inc))\"}\n\nOther Examples:\n- Replace a calculation: {\"match_form\": \"(+ x 2)\", \"new_form\": \"(+ x 10)\"}\n  * Will match regardless of spaces: (+ x 2), (+   x   2), etc.\n- Delete an expression: {\"match_form\": \"(println debug-info)\", \"new_form\": \"\"}\n- Edit anonymous function: {\"match_form\": \"#(inc %)\", \"new_form\": \"#(+ % 2)\"}\n- Replace multiple occurrences: {\"match_form\": \"(inc x)\", \"new_form\": \"(+ x 1)\", \"replace_all\": true}\n\nReturns a diff showing the changes made to the file.","inputSchema":{"type":"object","properties":{"file_path":{"type":"string","description":"Path to the file to edit"},"match_form":{"type":"string","description":"The s-expression to find and replace (include # for anonymous functions)"},"new_form":{"type":"string","description":"The s-expression to replace with"},"replace_all":{"type":"boolean","description":"Whether to replace all occurrences (default: false)"}},"required":["file_path","match_form","new_form"]}},{"name":"file_edit","description":"Edit a file by replacing a specific text string with a new one. For safety, this tool requires that the string to replace appears exactly once in the file. \n\nFIRST: the clojure_edit tool is prefered because they use precise structural rewrite-clj editing. They also incorporate linting and ensure balance parenthesis.\n\nWHEN the clojure_edit tool won't work or you have a small easy edit \n\nPREFER the file_write tool for replacing more than half a file, this saves on tokens\n\nFor Clojure files (.clj, .cljs, .cljc, .edn):\n- Content will be linted for syntax errors before writing\n- Content will be formatted according to Clojure standards\n- Writing will fail if linting detects syntax errors\n\nTo make a file edit, provide the file_path, old_string (the text to replace), and new_string (the replacement text). The old_string must uniquely identify the specific instance you want to change, so include several lines of context before and after the change point. To create a new file, use file_write instead.","inputSchema":{"type":"object","properties":{"file_path":{"type":"string","description":"The absolute path to the file to modify (must be absolute, not relative)"},"old_string":{"type":"string","description":"The text to replace (must match the file contents exactly, including all whitespace and indentation)."},"new_string":{"type":"string","description":"The edited text to replace the old_string"}},"required":["file_path","old_string","new_string"]}},{"name":"file_write","description":"Write a file to the local filesystem. Overwrites the existing file if there is one.\n\nFor Clojure files (.clj, .cljs, .cljc, .edn):\n- Content will be linted for syntax errors before writing\n- Content will be formatted according to Clojure standards\n- Writing will fail if linting detects syntax errors\n\nFor other file types:\n- Content is written directly without linting or formatting\n\nIMPORTANT SAFETY FEATURE:\n- If the file has been modified since it was last read, writing will fail\n- You must use read_file to get the current content before editing a file\n- This prevents accidental overwrites of external changes\n\nReturns information about whether the file was created or updated, along with a diff \nshowing the changes made.\n\nBefore using this tool:\n1. Use the read_file tool to understand the file's contents and context\n2. Directory Verification (only applicable when creating new files):\n   - Use the list_directory tool to verify the parent directory exists and is the correct location\n3. For Clojure files, ensure code is syntactically correct\n\n# Example:\n# file_write(\n#   file_path: \"/absolute/path/to/file.clj\",\n#   content: \"(ns my.namespace)\\n\\n(defn my-function [x]\\n  (* x 2))\"\n# )","inputSchema":{"type":"object","properties":{"file_path":{"type":"string","description":"The absolute path to the file to write (must be absolute, not relative)"},"content":{"type":"string","description":"The content to write to the file"}},"required":["file_path","content"]}},{"name":"clojure_inspect_project","description":"Analyzes and provides detailed information about a Clojure project's structure, \nincluding dependencies, source files, namespaces, and environment details.\n\nThis tool helps you understand project organization without having to manually \nexplore multiple configuration files. It works with both deps.edn and Leiningen projects.\n\nThe tool provides information about:\n- Project environment (working directory, Clojure version, Java version)\n- Source and test paths\n- Dependencies and their versions\n- Aliases and their configurations\n- Available namespaces\n- Source file structure\n\nUse this tool to quickly get oriented in an unfamiliar Clojure codebase or to \nget a high-level overview of your current project.\n\n# Example:\nclojure_inspect_project()","inputSchema":{"type":"object","properties":{"explanation":{"type":"string","description":"Short explanation why you chose this tool"}},"required":["explanation"]}},{"name":"dispatch_agent","description":"Launch a new agent that has access to read-only tools. When you are searching for a keyword or file and are not confident that you will find the right match on the first try, use the Agent tool to perform the search for you. For example:\n\n- If you are searching for a keyword like \"config\" or \"logger\", the Agent tool is appropriate\n- If you want to read a specific file path, use the read_file or glob_files tool instead of the Agent tool, to find the match more quickly\n- If you are searching for a specific class definition like \"class Foo\", use the glob_files tool instead, to find the match more quickly\n\nUsage notes:\n1. Launch multiple agents concurrently whenever possible, to maximize performance; to do that, use a single message with multiple `agent` tool uses\n2. When the agent is done, it will return a single message back to you. The result returned by the agent is not visible to the user. To show the user the result, you should send a text message back to the user with a concise summary of the result.\n3. Each agent invocation is stateless. You will not be able to send additional messages to the agent, nor will the agent be able to communicate with you outside of its final report. Therefore, your prompt should contain a highly detailed task description for the agent to perform autonomously and you should specify exactly what information the agent should return back to you in its final and only message to you.\n4. The agent's outputs should generally be trusted","inputSchema":{"type":"object","properties":{"prompt":{"type":"string","description":"The prompt to send to the agent"}},"required":["prompt"]}},{"name":"architect","description":"Your go-to tool for any technical or coding task. Analyzes requirements and breaks them down into clear, actionable implementation steps. Use this whenever you need help planning how to implement a feature, solve a technical problem, or structure your code.","inputSchema":{"type":"object","properties":{"prompt":{"type":"string","description":"The technical request or coding task to analyze"},"context":{"type":"string","description":"Optional context from previous conversation or system state"}},"required":["prompt"]}},{"name":"code_critique","description":"Starts an interactive code review conversation that provides constructive feedback on your Clojure code.\n  \n  HOW TO USE THIS TOOL:\n  1. Submit your Clojure code for initial critique\n  2. Review the suggestions and implement improvements\n  3. Test your revised code in the REPL\n  4. Submit the updated code for additional feedback\n  5. Continue this cycle until the critique is satisfied\n  \n  This tool initiates a feedback loop where you:\n  - Receive detailed analysis of your code\n  - Implement suggested improvements\n  - Test and verify changes\n  - Get follow-up critique on your revisions\n  \n  The critique examines:\n  - Adherence to Clojure style conventions\n  - Functional programming best practices\n  - Performance optimizations\n  - Readability and maintainability improvements\n  - Idiomatic Clojure patterns\n  \n  Example conversation flow:\n  - You: Submit initial function implementation\n  - Tool: Provides feedback on style and structure\n  - You: Revise code based on suggestions and test in REPL\n  - Tool: Reviews updates and suggests further refinements\n  - Repeat until code quality goals are achieved\n  \n  Perfect for iterative learning and continuous code improvement.","inputSchema":{"type":"object","properties":{"code":{"type":"string","description":"The Clojure code to analyze and critique"},"context":{"type":"string","description":"Optional context from previous conversation or system state"}},"required":["code"]}}]}}
{"jsonrpc":"2.0","id":23,"result":{"resources":[{"uri":"custom://llm-code-style","name":"LLM_CODE_STYLE.md","description":"Guidelines for writing Clojure code for the current project hosting the REPL","mimeType":"text/markdown"},{"uri":"custom://project-summary","name":"PROJECT_SUMMARY.md","description":"A Clojure project summary document for the project hosting the REPL, this is intended to provide the LLM with important context to start.","mimeType":"text/markdown"},{"uri":"custom://claude","name":"CLAUDE.md","description":"The Claude instructions document for the current project hosting the REPL","mimeType":"text/markdown"},{"uri":"custom://readme","name":"README.md","description":"A README document for the current Clojure project hosting the REPL","mimeType":"text/markdown"},{"uri":"custom://project-info","name":"Clojure Project Info","description":"Information about the current Clojure project structure, attached REPL environment and dependencies","mimeType":"text/markdown"}]}}
{"jsonrpc":"2.0","id":24,"result":{"prompts":[{"name":"ACT/scratch_pad_load","description":"Loads a file into the scratch pad state. Returns status messages and a shallow inspect of the loaded data.","arguments":[{"name":"file_path","description":"Optional file path: default scratch_pad.edn","required":false}]},{"name":"clojure_repl_system_prompt","description":"Provides instructions and guidelines for Clojure development, including style and best practices.","arguments":[]},{"name":"create-update-project-summary","description":"Generates a prompt instructing the LLM to create a summary of a project.","arguments":[]},{"name":"chat-session-summarize","description":"Instructs the assistant to create a summary of the current chat session and store it in the scratch pad. `chat_session_key` is optional and will default to `chat_session_summary`","arguments":[{"name":"chat_session_key","description":"[Optional] key to store the session summary in","required":false}]},{"name":"ACT/scratch_pad_save_as","description":"Saves the current scratch pad state to a specified file.","arguments":[{"name":"file_path","description":"File path: relative to .clojure-mcp/ directory","required":true}]},{"name":"chat-session-resume","description":"Instructs the assistant to resume a previous chat session by loading context from the scratch pad. `chat_session_key` is optional and will default to `chat_session_summary`","arguments":[{"name":"chat_session_key","description":"[Optional] key where session summary is stored","required":false}]},{"name":"ACT/add-dir","description":"Adds a directory to the allowed-directories list, giving the LLM access to it","arguments":[{"name":"directory","description":"Directory path to add (can be relative or absolute)","required":true}]},{"name":"plan-and-execute","description":"Use the scratch pad tool to plan and execute an change","arguments":[]}]}}
{"jsonrpc":"2.0","id":25,"result":{"tools":[{"name":"LS","description":"Returns a recursive tree view of files and directories starting from the specified path. The path parameter must be an absolute path, not a relative path. You should generally prefer the `glob_files` and `fx_grep` tools, if you know which directories to search.","inputSchema":{"type":"object","properties":{"path":{"type":"string"},"max_depth":{"type":"integer","description":"Maximum depth to traverse (optional)"},"limit":{"type":"integer","description":"Maximum number of entries to show (default: 100)"}},"required":["path"]}},{"name":"read_file","description":"Smart file reader with pattern-based exploration for Clojure files.\n   \nFor Clojure files (.clj, .cljc, .cljs, .bb):\n\nThis tool defaults to an expandable collapsed view to quickly grab the information you need from a Clojure file.\nIf called without `name_pattern` or `content_pattern` it will return the file content where \nyou will see only function signatures. This gives you a quick overview of the file.\n\nWhen you want to see more, this tool has a grep functionality where you\ncan give patterns to match the names for top level definitions\n`name_pattern` or match the bodies of top level definitions `content_pattern`.\n\nThe functions that match these patterns will be the only functions expanded in collapsed view.\n\nFor defmethod forms:\n- The name includes both the method name and the dispatch value (e.g., \"area :rectangle\")\n- For vector dispatch values, use the exact pattern (e.g., \"dispatch-with-vector \\[:feet :inches\\]\")\n- For qualified/namespaced multimethod names, include the namespace (e.g., \"tool-system/validate-inputs :clojure-eval\")\n\nFor text files (non-Clojure):\n- When `collapsed: true` and a pattern is provided (`content_pattern` or `name_pattern`), shows only lines matching the pattern with 10 lines of context before and after\n\nFor all other file types:\n- Collapsed view will not be applied and will return the raw contents of the file\n\nParameters:\n- path: Path to the file (required)\n- collapsed: Show collapsed view (default: true)\n\nCollapsed View mode function expansion parameters:\n\n- name_pattern: Regex to match function names (e.g., \"validate.*\")\n- content_pattern: Regex to match function content (e.g., \"try|catch\")\n\nExample usage for defmethod forms:\n- Find all implementations of a multimethod: `name_pattern: \"area\"`\n- Find specific dispatch values: `name_pattern: \"area :circle\"`\n- Find vector dispatch values: `name_pattern: \"convert-length \\\\[:feet :inches\\\\]\"`\n- Find namespace-qualified methods: `name_pattern: \"tool-system/validate-inputs\"`\n\nExample usage for text files:\n- Find error messages: `content_pattern: \"ERROR|WARN\"`\n- Find specific log entries: `content_pattern: \"\\\\[2024-01-15.*ERROR\\\\]\"`\n\nNon collapsed view mode respects these parameters:\n\n- line_offset: Line to start reading from (non-collapsed mode only, default: 0)\n- limit: Maximum lines to read (non-collapsed mode only, default: 2000)\n\nBy default, reads up to 2000 lines, truncating lines longer than 1000 characters.","inputSchema":{"type":"object","properties":{"path":{"type":"string","description":"Path to the file to read"},"collapsed":{"type":"boolean","description":"Whether to show collapsed view for Clojure files (default: true)"},"name_pattern":{"type":"string","description":"Pattern to match function names (e.g., \"validate.*\")"},"content_pattern":{"type":"string","description":"Pattern to match function content (e.g., \"try|catch\")"},"line_offset":{"type":"integer","description":"Line to start reading from for raw mode (default: 0)"},"limit":{"type":"integer","description":"Maximum lines to read (default: 2000)"}},"required":["path"]}},{"name":"grep","description":"Fast content search tool that works with any codebase size.\n- Finds the paths to files that have matching contents using regular expressions.\n- Supports full regex syntax (eg. \"log.*Error\", \"function\\s+\\w+\", etc.).\n- Filter files by pattern with the include parameter (eg. \"*.js\", \"*.{ts,tsx}\").\n- Returns matching file paths sorted by modification time.\n- Use this tool when you need to find files containing specific patterns.\n- When you are doing an open ended search that may require multiple rounds of globbing and grepping, use the `dispatch_agent` tool instead","inputSchema":{"type":"object","properties":{"path":{"type":"string","description":"The directory to search in. Defaults to the current working directory."},"pattern":{"type":"string","description":"The regular expression pattern to search for in file contents"},"include":{"type":"string","description":"File pattern to include in the search (e.g. \"*.clj\", \"*.{clj,cljs}\")"},"max_results":{"type":"integer","description":"Maximum number of results to return (default: 1000)"}},"required":["pattern"]}},{"name":"glob_files","description":"Fast file pattern matching tool that works with any codebase size.\n - Supports glob patterns like \"**/*.clj\" or \"src/**/*.cljs\".\n - Returns matching file paths sorted by modification time (most recent first).\n - Use this tool when you need to find files by name patterns.\n - When you are doing an open ended search that may require multiple rounds of globbing and grepping, use the `dispatch_agent` tool instead","inputSchema":{"type":"object","properties":{"path":{"type":"string","description":"Root directory to start the search from (defaults to current working directory)"},"pattern":{"type":"string","description":"Glob pattern (e.g. \"**/*.clj\", \"src/**/*.tsx\")"},"max_results":{"type":"integer","description":"Maximum number of results to return (default: 1000)"}},"required":["pattern"]}},{"name":"think","description":"Use the tool to think about something. It will not obtain new information or make any changes to the repository, but just log the thought. Use it when complex reasoning or brainstorming is needed. \nCommon use cases:\n* when having difficulty finding/reading the files you need\n* when having difficulty writing out code\n* when having difficulty using the tools or the clojure tools\n* When exploring a repository and discovering the source of a bug, call this tool to brainstorm several unique ways of fixing the bug, and assess which change(s) are likely to be simplest and most effective.\n* After receiving test results, use this tool to brainstorm ways to fix failing tests.\n* When planning a complex refactoring, use this tool to outline different approaches and their tradeoffs.\n* When designing a new feature, use this tool to think through architecture decisions and implementation details.\n* When debugging a complex issue, use this tool to organize your thoughts and hypotheses.\nThe tool simply logs your thought process for better transparency and does not execute any code or make changes.","inputSchema":{"type":"object","properties":{"thought":{"type":"string","description":"The thought to log"}},"required":["thought"]}},{"name":"scratch_pad","description":"A persistent scratch pad for storing structured data between tool calls. Accepts any JSON value (objects, arrays, strings, numbers, booleans, null) and stores them at nested paths using set_path, get_path, delete_path operations.\n\nTHIS IS YOUR GO-TO TOOL FOR PLANNING.\n\nYour persistent workspace for planning, organizing thoughts, and maintaining state across tool invocations.\n\nThis tool can be used to:\n * develop and track multi-step plans\n * maintain task lists and task tracking\n * store intermediate results between operations\n * keep notes about your current approach or strategy\n * maintain a list of files or resources to process\n * build up complex data structures incrementally\n * share context between different tool calls\n * any other persistent storage needs during your work\n\nThe scratch pad is for persistent storage and state management, not for formatting output. Display information directly in your chat responses. However, when the scratch pad contains user-relevant state (like tasks lists or tracked progress), you should retrieve and display updates after modifications.\n\nUse the scratch pad when you need to:\n- Track progress across multiple tool calls\n- Build data structures incrementally  \n- Maintain state between operations\n- Store intermediate results for later use\n\nDon't use the scratch pad to:\n- Format text for display\n- Store static information just to retrieve and show it\n- Replace direct chat responses\n\nCORE OPERATIONS:\n- set_path: Store a value (not null) at a path, returns the parent container\n- get_path: Retrieve a value from a path, returns the value or nil\n- delete_path: Remove only the leaf value from a path, returns a confirmation message\n- inspect: Display the entire structure (or a specific path) with truncation at specified depth\n\nWARNING: null values can not be stored in the scratch pad, if you attempt to store a null value the set_path will fail.\n\nTRACKING PLANS WITH TASK LISTS:\n\nRecommended schema for a Task:\n{\n  task: \"Description of the task\",\n  done: false,\n  priority: \"high\", // optional: \"high\", \"medium\", \"low\"\n  context: \"Additional details\", // optional\n  subtasks: [  // optional: array of subtask objects\n    {task: \"Subtask 1\", done: false},\n    {task: \"Subtask 2\", done: true}\n  ]\n}\n\nFirst add multiple tasks items at once as an array:\n- Entire array:\n  op: set_path\n  path: [\"tasks\"]\n  value: [\n    {task: \"Write tests\", done: false, priority: \"high\"},\n    {task: \"Review PR\", done: false, priority: \"high\"},\n    {task: \"Update docs\", done: false, priority: \"medium\", subtasks: [\n      {task: \"Update API docs\", done: false},\n      {task: \"Update README\", done: false}\n    ]}\n  ]\n  explanation: Adding multiple tasks at once\n\nAdding tasks items:\n- First item:\n  op: set_path\n  path: [\"tasks\", 3]\n  value: {task: \"Run tests\", done: false}\n  explanation: Adding write tests task\n\n- Next item:\n  op: set_path\n  path: [\"tasks\", 4]\n  value: {task: \"Notify user\", done: false, priority: \"high\"}\n  explanation: Adding high priority task\n\nChecking off completed tasks:\n- Mark as done:\n  op: set_path\n  path: [\"tasks\", 0, \"done\"]\n  value: true\n  explanation: Completed writing tests\n\n- Mark subtask as done:\n  op: set_path\n  path: [\"tasks\", 2, \"subtasks\", 0, \"done\"]\n  value: true\n  explanation: Completed API docs update\n\nAdding a new task to the array:\n- Append to array:\n  op: set_path\n  path: [\"tasks\", 3]\n  value: {task: \"Deploy to production\", done: false, priority: \"high\"}\n  explanation: Adding deployment task\n\nViewing tasks:\n- All tasks:\n  op: get_path\n  path: [\"tasks\"]\n  explanation: Get all tasks\n\n- Specific task:\n  op: get_path\n  path: [\"tasks\", 0]\n  explanation: Checking first task details\n\n- View with depth limit:\n  op: inspect\n  path: [\"tasks\"]\n  depth: 2\n  explanation: View tasks with limited nesting","inputSchema":{"type":"object","properties":{"op":{"type":"string","enum":["set_path","get_path","delete_path","inspect"],"description":"The operation to perform:\n * set_path: set a value at a path\n * get_path: retrieve a value at a path\n * delete_path: remove the value at the path from the data structure\n * inspect: view the datastructure (or a specific path within it) up to a certain depth\n"},"path":{"type":"array","items":{"type":"string"},"description":"Path to the data location (array of string or number keys) - used for set_path, get_path, delete_path, and optionally inspect"},"value":{"description":"Value to store (for set_path). Can be ANY JSON value EXCEPT null: object, array, string, number, boolean.","type":"object"},"explanation":{"type":"string","description":"Explanation of why this operation is being performed"},"depth":{"type":"number","description":"(Optional) For inspect operation: Maximum depth to display (default: 5). Must be a positive integer."}},"required":["op","explanation"]}},{"name":"clojure_eval","description":"Takes a Clojure Expression and evaluates it in the current namespace. For example, providing \"(+ 1 2)\" will evaluate to 3.\n\nThis tool is intended to execute Clojure code. This is very helpful for verifying that code is working as expected. It's also helpful for REPL driven development.\n\nIf you send multiple expressions they will all be evaluated individually and their output will be clearly partitioned.\n\nIf the returned value is too long it will be truncated.\n\nIMPORTANT: When using `require` to reload namespaces ALWAYS use `:reload` to ensure you get the latest version of files.\n\nREPL helper functions are automatically loaded in the 'clj-mcp.repl-tools' namespace, providing convenient namespace and symbol exploration:\n\nNamespace/Symbol inspection functions:\n  clj-mcp.repl-tools/list-ns           - List all available namespaces\n  clj-mcp.repl-tools/list-vars         - List all vars in namespace\n  clj-mcp.repl-tools/doc-symbol        - Show documentation for symbol\n  clj-mcp.repl-tools/source-symbol     - Show source code for symbol\n  clj-mcp.repl-tools/find-symbols      - Find symbols matching pattern\n  clj-mcp.repl-tools/complete          - Find completions for prefix\n  clj-mcp.repl-tools/help              - Show this help message\n\nExamples:\n  (clj-mcp.repl-tools/list-ns)                     ; List all namespaces\n  (clj-mcp.repl-tools/list-vars 'clojure.string)   ; List functions in clojure.string\n  (clj-mcp.repl-tools/doc-symbol 'map)             ; Show documentation for map\n  (clj-mcp.repl-tools/source-symbol 'map)          ; Show source code for map\n  (clj-mcp.repl-tools/find-symbols \"seq\")          ; Find symbols containing \"seq\"\n  (clj-mcp.repl-tools/complete \"clojure.string/j\") ; Find completions for prefix","inputSchema":{"type":"object","properties":{"code":{"type":"string","description":"The Clojure code to evaluate."}},"required":["code"]}},{"name":"bash","description":"Execute bash shell commands on the host system.\n\nExamples:\n1. List files: bash(command: \"ls -la\")\n2. Find text in files: bash(command: \"grep -r 'pattern' /path/to/search\")\n3. With working directory: bash(command: \"ls -la\", working_directory: \"/tmp\")\n4. With timeout: bash(command: \"sleep 10\", timeout_ms: 5000)\n5. Git commands \n\nFor long running processes like running tests increase the timeout_ms so that the process can complete.\n\nNote: Non-zero exit codes are NOT treated as tool errors - check exit_code\nin the response to determine command success.","inputSchema":{"type":"object","properties":{"command":{"type":"string","description":"The shell command to execute"},"working_directory":{"type":"string","description":"Directory to run the command in (optional)"},"timeout_ms":{"type":"integer","description":"Maximum execution time in milliseconds (optional, default: 30000)"}},"required":["command"]}},{"name":"clojure_edit","description":"Edits a top-level form (`defn`, `def`, `defmethod`, `ns`, `deftest`) in a Clojure file using the specified operation.\n   \nPREFER this unified tool over generic file editing tools for Clojure files (`.clj` `.cljs` `.cljc` `.bb`)\n\nThis tool MAKES it EASIER to match a definition that exists in the file AS you only have to match the type of definition `form_type` and the complete identifier `form_identifier` of the definition. This prevents the repeated mismatch errors that occur when trying match an entire string of text for replacement.\nThis tool validates the structure of the Clojure code that is being inserted into the file and will provide linting feedback for things such as parenthetical errors.\nThis tool reduces the number of tokens that need to be generated.\n \nWARNING: you will receive errors if the syntax is wrong, the most common error is an extra or missing parenthesis in the `content`, so be careful with parenthesis.\n\n   Operations:\n   - \"replace\": Replaces the form with new content\n   - \"insert_before\": Inserts content before the form\n   - \"insert_after\": Inserts content after the form\n   \n   The form is identified by its type (defn, def, deftest, s/def, ns, defmethod etc.) and complete identifier.\n   \n   Example: Replace a function definition:\n   - file_path: \"/path/to/file.clj\"\n   - form_identifier: \"example-fn\"\n   - form_type: \"defn\"\n   - operation: \"replace\"\n   - content: \"(defn example-fn [x] (* x 2))\"\n   \n   Example: Insert a helper function before a function:\n   - file_path: \"/path/to/file.clj\"\n   - form_identifier: \"example-fn\"\n   - form_type: \"defn\"\n   - operation: \"insert_before\"\n   - content: \"(defn helper-fn [x] (* x 2))\"\n   \n   Example: Insert a test after a function:\n   - file_path: \"/path/to/file.clj\"\n   - form_identifier: \"example-fn\"\n   - form_type: \"defn\"\n   - operation: \"insert_after\"\n   - content: \"(deftest example-fn-test\n  (is (= 4 (example-fn 2))))\"\n   \nNote: For `defmethod` forms, be sure to include the dispatch value (`area :rectangle` or `qualified/area :rectangle`) in the `form_identifier`. Many `defmethod` definitions have qualified names (they include a namespace alias in their identifier like `shape/area`), so it's crucial to use the complete identifier that appears in the file.\n\n   Example: Replace a specific `defmethod` implementation:\n   - file_path: \"/path/to/file.clj\"\n   - form_identifier: \"shape/area :square\"\n   - form_type: \"defmethod\"\n   - operation: \"replace\"\n   - content: \"(defmethod shape/area :square [{:keys [w h]}] (* w h))\"\n\n   Example: Work with vector dispatch values:\n   - file_path: \"/path/to/file.clj\"\n   - form_identifier: \"convert-length [:feet :inches]\"\n   - form_type: \"defmethod\"\n   - operation: \"insert_before\"\n   - content: \"(def inches-per-foot 12)\"\n\n   The tool will find the form, perform the requested operation, and format the result.\n   It returns a diff showing the changes made to the file.","inputSchema":{"type":"object","properties":{"file_path":{"type":"string","description":"Path to the file containing the form to edit"},"form_identifier":{"type":"string","description":"Complete identifier of the form (e.g., function name, \"shape/area\", or \"convert-length [:feet :inches]\")"},"form_type":{"type":"string","description":"Type of the form (e.g., \"defn\", \"def\", \"ns\")"},"operation":{"type":"string","enum":["replace","insert_before","insert_after"],"description":"The editing operation to perform"},"content":{"type":"string","description":"New content to use for the operation"}},"required":["file_path","form_identifier","form_type","operation","content"]}},{"name":"clojure_edit_replace_sexp","description":"Edits a file by finding and replacing specific s-expressions.\n\nUse this tool for targeted edits of sub-expressions within forms. For complete top-level form replacements, prefer specialized tools like `clojure_edit_replace_definition` and friends.\n\nKEY BENEFITS:\n- Syntax-aware matching that understands Clojure code structure\n- Ignores whitespace differences by default, focusing on actual code meaning\n- Matches expressions regardless of formatting, indentation, or spacing\n- Prevents errors from mismatched text or irrelevant formatting differences\n- Can find and replace all occurrences with replace_all: true\n\nCONSTRAINTS:\n- match_form must contain only a SINGLE s-expression (error otherwise)\n- Requires syntactically valid Clojure expressions in both match_form and new_form\n\nWARNING: You will receive errors if the syntax is wrong. The most common error is an extra or missing parenthesis in either match_form or new_form, so count your parentheses carefully!\n\nCOMMON APPLICATIONS:\n- Renaming symbols throughout the file: {\"match_form\": \"old-name\", \"new_form\": \"new-name\", \"replace_all\": true}\n- Editing special forms like if/cond/let/when within functions:\n  * Changing if branches: {\"match_form\": \"(if condition expr1 expr2)\", \"new_form\": \"(if condition (do expr1) expr2)\"}\n  * Enhancing let bindings: {\"match_form\": \"(let [x 10] (+ x 2))\", \"new_form\": \"(let [x 10 y 20] (+ x y))\"}\n  * Converting cond to case: {\"match_form\": \"(cond (= x :a) \\\"A\\\" (= x :b) \\\"B\\\")\", \"new_form\": \"(case x :a \\\"A\\\" :b \\\"B\\\")\"}\n- Modifying nested function calls: {\"match_form\": \"(str (+ a b))\", \"new_form\": \"(str (+ a b c))\"}\n- Changing anonymous function syntax: {\"match_form\": \"#(update % :count inc)\", \"new_form\": \"(fn [x] (update x :count inc))\"}\n\nOther Examples:\n- Replace a calculation: {\"match_form\": \"(+ x 2)\", \"new_form\": \"(+ x 10)\"}\n  * Will match regardless of spaces: (+ x 2), (+   x   2), etc.\n- Delete an expression: {\"match_form\": \"(println debug-info)\", \"new_form\": \"\"}\n- Edit anonymous function: {\"match_form\": \"#(inc %)\", \"new_form\": \"#(+ % 2)\"}\n- Replace multiple occurrences: {\"match_form\": \"(inc x)\", \"new_form\": \"(+ x 1)\", \"replace_all\": true}\n\nReturns a diff showing the changes made to the file.","inputSchema":{"type":"object","properties":{"file_path":{"type":"string","description":"Path to the file to edit"},"match_form":{"type":"string","description":"The s-expression to find and replace (include # for anonymous functions)"},"new_form":{"type":"string","description":"The s-expression to replace with"},"replace_all":{"type":"boolean","description":"Whether to replace all occurrences (default: false)"}},"required":["file_path","match_form","new_form"]}},{"name":"file_edit","description":"Edit a file by replacing a specific text string with a new one. For safety, this tool requires that the string to replace appears exactly once in the file. \n\nFIRST: the clojure_edit tool is prefered because they use precise structural rewrite-clj editing. They also incorporate linting and ensure balance parenthesis.\n\nWHEN the clojure_edit tool won't work or you have a small easy edit \n\nPREFER the file_write tool for replacing more than half a file, this saves on tokens\n\nFor Clojure files (.clj, .cljs, .cljc, .edn):\n- Content will be linted for syntax errors before writing\n- Content will be formatted according to Clojure standards\n- Writing will fail if linting detects syntax errors\n\nTo make a file edit, provide the file_path, old_string (the text to replace), and new_string (the replacement text). The old_string must uniquely identify the specific instance you want to change, so include several lines of context before and after the change point. To create a new file, use file_write instead.","inputSchema":{"type":"object","properties":{"file_path":{"type":"string","description":"The absolute path to the file to modify (must be absolute, not relative)"},"old_string":{"type":"string","description":"The text to replace (must match the file contents exactly, including all whitespace and indentation)."},"new_string":{"type":"string","description":"The edited text to replace the old_string"}},"required":["file_path","old_string","new_string"]}},{"name":"file_write","description":"Write a file to the local filesystem. Overwrites the existing file if there is one.\n\nFor Clojure files (.clj, .cljs, .cljc, .edn):\n- Content will be linted for syntax errors before writing\n- Content will be formatted according to Clojure standards\n- Writing will fail if linting detects syntax errors\n\nFor other file types:\n- Content is written directly without linting or formatting\n\nIMPORTANT SAFETY FEATURE:\n- If the file has been modified since it was last read, writing will fail\n- You must use read_file to get the current content before editing a file\n- This prevents accidental overwrites of external changes\n\nReturns information about whether the file was created or updated, along with a diff \nshowing the changes made.\n\nBefore using this tool:\n1. Use the read_file tool to understand the file's contents and context\n2. Directory Verification (only applicable when creating new files):\n   - Use the list_directory tool to verify the parent directory exists and is the correct location\n3. For Clojure files, ensure code is syntactically correct\n\n# Example:\n# file_write(\n#   file_path: \"/absolute/path/to/file.clj\",\n#   content: \"(ns my.namespace)\\n\\n(defn my-function [x]\\n  (* x 2))\"\n# )","inputSchema":{"type":"object","properties":{"file_path":{"type":"string","description":"The absolute path to the file to write (must be absolute, not relative)"},"content":{"type":"string","description":"The content to write to the file"}},"required":["file_path","content"]}},{"name":"clojure_inspect_project","description":"Analyzes and provides detailed information about a Clojure project's structure, \nincluding dependencies, source files, namespaces, and environment details.\n\nThis tool helps you understand project organization without having to manually \nexplore multiple configuration files. It works with both deps.edn and Leiningen projects.\n\nThe tool provides information about:\n- Project environment (working directory, Clojure version, Java version)\n- Source and test paths\n- Dependencies and their versions\n- Aliases and their configurations\n- Available namespaces\n- Source file structure\n\nUse this tool to quickly get oriented in an unfamiliar Clojure codebase or to \nget a high-level overview of your current project.\n\n# Example:\nclojure_inspect_project()","inputSchema":{"type":"object","properties":{"explanation":{"type":"string","description":"Short explanation why you chose this tool"}},"required":["explanation"]}},{"name":"dispatch_agent","description":"Launch a new agent that has access to read-only tools. When you are searching for a keyword or file and are not confident that you will find the right match on the first try, use the Agent tool to perform the search for you. For example:\n\n- If you are searching for a keyword like \"config\" or \"logger\", the Agent tool is appropriate\n- If you want to read a specific file path, use the read_file or glob_files tool instead of the Agent tool, to find the match more quickly\n- If you are searching for a specific class definition like \"class Foo\", use the glob_files tool instead, to find the match more quickly\n\nUsage notes:\n1. Launch multiple agents concurrently whenever possible, to maximize performance; to do that, use a single message with multiple `agent` tool uses\n2. When the agent is done, it will return a single message back to you. The result returned by the agent is not visible to the user. To show the user the result, you should send a text message back to the user with a concise summary of the result.\n3. Each agent invocation is stateless. You will not be able to send additional messages to the agent, nor will the agent be able to communicate with you outside of its final report. Therefore, your prompt should contain a highly detailed task description for the agent to perform autonomously and you should specify exactly what information the agent should return back to you in its final and only message to you.\n4. The agent's outputs should generally be trusted","inputSchema":{"type":"object","properties":{"prompt":{"type":"string","description":"The prompt to send to the agent"}},"required":["prompt"]}},{"name":"architect","description":"Your go-to tool for any technical or coding task. Analyzes requirements and breaks them down into clear, actionable implementation steps. Use this whenever you need help planning how to implement a feature, solve a technical problem, or structure your code.","inputSchema":{"type":"object","properties":{"prompt":{"type":"string","description":"The technical request or coding task to analyze"},"context":{"type":"string","description":"Optional context from previous conversation or system state"}},"required":["prompt"]}},{"name":"code_critique","description":"Starts an interactive code review conversation that provides constructive feedback on your Clojure code.\n  \n  HOW TO USE THIS TOOL:\n  1. Submit your Clojure code for initial critique\n  2. Review the suggestions and implement improvements\n  3. Test your revised code in the REPL\n  4. Submit the updated code for additional feedback\n  5. Continue this cycle until the critique is satisfied\n  \n  This tool initiates a feedback loop where you:\n  - Receive detailed analysis of your code\n  - Implement suggested improvements\n  - Test and verify changes\n  - Get follow-up critique on your revisions\n  \n  The critique examines:\n  - Adherence to Clojure style conventions\n  - Functional programming best practices\n  - Performance optimizations\n  - Readability and maintainability improvements\n  - Idiomatic Clojure patterns\n  \n  Example conversation flow:\n  - You: Submit initial function implementation\n  - Tool: Provides feedback on style and structure\n  - You: Revise code based on suggestions and test in REPL\n  - Tool: Reviews updates and suggests further refinements\n  - Repeat until code quality goals are achieved\n  \n  Perfect for iterative learning and continuous code improvement.","inputSchema":{"type":"object","properties":{"code":{"type":"string","description":"The Clojure code to analyze and critique"},"context":{"type":"string","description":"Optional context from previous conversation or system state"}},"required":["code"]}}]}}
{"jsonrpc":"2.0","id":26,"result":{"resources":[{"uri":"custom://llm-code-style","name":"LLM_CODE_STYLE.md","description":"Guidelines for writing Clojure code for the current project hosting the REPL","mimeType":"text/markdown"},{"uri":"custom://project-summary","name":"PROJECT_SUMMARY.md","description":"A Clojure project summary document for the project hosting the REPL, this is intended to provide the LLM with important context to start.","mimeType":"text/markdown"},{"uri":"custom://claude","name":"CLAUDE.md","description":"The Claude instructions document for the current project hosting the REPL","mimeType":"text/markdown"},{"uri":"custom://readme","name":"README.md","description":"A README document for the current Clojure project hosting the REPL","mimeType":"text/markdown"},{"uri":"custom://project-info","name":"Clojure Project Info","description":"Information about the current Clojure project structure, attached REPL environment and dependencies","mimeType":"text/markdown"}]}}
{"jsonrpc":"2.0","id":27,"result":{"prompts":[{"name":"ACT/scratch_pad_load","description":"Loads a file into the scratch pad state. Returns status messages and a shallow inspect of the loaded data.","arguments":[{"name":"file_path","description":"Optional file path: default scratch_pad.edn","required":false}]},{"name":"clojure_repl_system_prompt","description":"Provides instructions and guidelines for Clojure development, including style and best practices.","arguments":[]},{"name":"create-update-project-summary","description":"Generates a prompt instructing the LLM to create a summary of a project.","arguments":[]},{"name":"chat-session-summarize","description":"Instructs the assistant to create a summary of the current chat session and store it in the scratch pad. `chat_session_key` is optional and will default to `chat_session_summary`","arguments":[{"name":"chat_session_key","description":"[Optional] key to store the session summary in","required":false}]},{"name":"ACT/scratch_pad_save_as","description":"Saves the current scratch pad state to a specified file.","arguments":[{"name":"file_path","description":"File path: relative to .clojure-mcp/ directory","required":true}]},{"name":"chat-session-resume","description":"Instructs the assistant to resume a previous chat session by loading context from the scratch pad. `chat_session_key` is optional and will default to `chat_session_summary`","arguments":[{"name":"chat_session_key","description":"[Optional] key where session summary is stored","required":false}]},{"name":"ACT/add-dir","description":"Adds a directory to the allowed-directories list, giving the LLM access to it","arguments":[{"name":"directory","description":"Directory path to add (can be relative or absolute)","required":true}]},{"name":"plan-and-execute","description":"Use the scratch pad tool to plan and execute an change","arguments":[]}]}}
{"jsonrpc":"2.0","id":28,"result":{"tools":[{"name":"LS","description":"Returns a recursive tree view of files and directories starting from the specified path. The path parameter must be an absolute path, not a relative path. You should generally prefer the `glob_files` and `fx_grep` tools, if you know which directories to search.","inputSchema":{"type":"object","properties":{"path":{"type":"string"},"max_depth":{"type":"integer","description":"Maximum depth to traverse (optional)"},"limit":{"type":"integer","description":"Maximum number of entries to show (default: 100)"}},"required":["path"]}},{"name":"read_file","description":"Smart file reader with pattern-based exploration for Clojure files.\n   \nFor Clojure files (.clj, .cljc, .cljs, .bb):\n\nThis tool defaults to an expandable collapsed view to quickly grab the information you need from a Clojure file.\nIf called without `name_pattern` or `content_pattern` it will return the file content where \nyou will see only function signatures. This gives you a quick overview of the file.\n\nWhen you want to see more, this tool has a grep functionality where you\ncan give patterns to match the names for top level definitions\n`name_pattern` or match the bodies of top level definitions `content_pattern`.\n\nThe functions that match these patterns will be the only functions expanded in collapsed view.\n\nFor defmethod forms:\n- The name includes both the method name and the dispatch value (e.g., \"area :rectangle\")\n- For vector dispatch values, use the exact pattern (e.g., \"dispatch-with-vector \\[:feet :inches\\]\")\n- For qualified/namespaced multimethod names, include the namespace (e.g., \"tool-system/validate-inputs :clojure-eval\")\n\nFor text files (non-Clojure):\n- When `collapsed: true` and a pattern is provided (`content_pattern` or `name_pattern`), shows only lines matching the pattern with 10 lines of context before and after\n\nFor all other file types:\n- Collapsed view will not be applied and will return the raw contents of the file\n\nParameters:\n- path: Path to the file (required)\n- collapsed: Show collapsed view (default: true)\n\nCollapsed View mode function expansion parameters:\n\n- name_pattern: Regex to match function names (e.g., \"validate.*\")\n- content_pattern: Regex to match function content (e.g., \"try|catch\")\n\nExample usage for defmethod forms:\n- Find all implementations of a multimethod: `name_pattern: \"area\"`\n- Find specific dispatch values: `name_pattern: \"area :circle\"`\n- Find vector dispatch values: `name_pattern: \"convert-length \\\\[:feet :inches\\\\]\"`\n- Find namespace-qualified methods: `name_pattern: \"tool-system/validate-inputs\"`\n\nExample usage for text files:\n- Find error messages: `content_pattern: \"ERROR|WARN\"`\n- Find specific log entries: `content_pattern: \"\\\\[2024-01-15.*ERROR\\\\]\"`\n\nNon collapsed view mode respects these parameters:\n\n- line_offset: Line to start reading from (non-collapsed mode only, default: 0)\n- limit: Maximum lines to read (non-collapsed mode only, default: 2000)\n\nBy default, reads up to 2000 lines, truncating lines longer than 1000 characters.","inputSchema":{"type":"object","properties":{"path":{"type":"string","description":"Path to the file to read"},"collapsed":{"type":"boolean","description":"Whether to show collapsed view for Clojure files (default: true)"},"name_pattern":{"type":"string","description":"Pattern to match function names (e.g., \"validate.*\")"},"content_pattern":{"type":"string","description":"Pattern to match function content (e.g., \"try|catch\")"},"line_offset":{"type":"integer","description":"Line to start reading from for raw mode (default: 0)"},"limit":{"type":"integer","description":"Maximum lines to read (default: 2000)"}},"required":["path"]}},{"name":"grep","description":"Fast content search tool that works with any codebase size.\n- Finds the paths to files that have matching contents using regular expressions.\n- Supports full regex syntax (eg. \"log.*Error\", \"function\\s+\\w+\", etc.).\n- Filter files by pattern with the include parameter (eg. \"*.js\", \"*.{ts,tsx}\").\n- Returns matching file paths sorted by modification time.\n- Use this tool when you need to find files containing specific patterns.\n- When you are doing an open ended search that may require multiple rounds of globbing and grepping, use the `dispatch_agent` tool instead","inputSchema":{"type":"object","properties":{"path":{"type":"string","description":"The directory to search in. Defaults to the current working directory."},"pattern":{"type":"string","description":"The regular expression pattern to search for in file contents"},"include":{"type":"string","description":"File pattern to include in the search (e.g. \"*.clj\", \"*.{clj,cljs}\")"},"max_results":{"type":"integer","description":"Maximum number of results to return (default: 1000)"}},"required":["pattern"]}},{"name":"glob_files","description":"Fast file pattern matching tool that works with any codebase size.\n - Supports glob patterns like \"**/*.clj\" or \"src/**/*.cljs\".\n - Returns matching file paths sorted by modification time (most recent first).\n - Use this tool when you need to find files by name patterns.\n - When you are doing an open ended search that may require multiple rounds of globbing and grepping, use the `dispatch_agent` tool instead","inputSchema":{"type":"object","properties":{"path":{"type":"string","description":"Root directory to start the search from (defaults to current working directory)"},"pattern":{"type":"string","description":"Glob pattern (e.g. \"**/*.clj\", \"src/**/*.tsx\")"},"max_results":{"type":"integer","description":"Maximum number of results to return (default: 1000)"}},"required":["pattern"]}},{"name":"think","description":"Use the tool to think about something. It will not obtain new information or make any changes to the repository, but just log the thought. Use it when complex reasoning or brainstorming is needed. \nCommon use cases:\n* when having difficulty finding/reading the files you need\n* when having difficulty writing out code\n* when having difficulty using the tools or the clojure tools\n* When exploring a repository and discovering the source of a bug, call this tool to brainstorm several unique ways of fixing the bug, and assess which change(s) are likely to be simplest and most effective.\n* After receiving test results, use this tool to brainstorm ways to fix failing tests.\n* When planning a complex refactoring, use this tool to outline different approaches and their tradeoffs.\n* When designing a new feature, use this tool to think through architecture decisions and implementation details.\n* When debugging a complex issue, use this tool to organize your thoughts and hypotheses.\nThe tool simply logs your thought process for better transparency and does not execute any code or make changes.","inputSchema":{"type":"object","properties":{"thought":{"type":"string","description":"The thought to log"}},"required":["thought"]}},{"name":"scratch_pad","description":"A persistent scratch pad for storing structured data between tool calls. Accepts any JSON value (objects, arrays, strings, numbers, booleans, null) and stores them at nested paths using set_path, get_path, delete_path operations.\n\nTHIS IS YOUR GO-TO TOOL FOR PLANNING.\n\nYour persistent workspace for planning, organizing thoughts, and maintaining state across tool invocations.\n\nThis tool can be used to:\n * develop and track multi-step plans\n * maintain task lists and task tracking\n * store intermediate results between operations\n * keep notes about your current approach or strategy\n * maintain a list of files or resources to process\n * build up complex data structures incrementally\n * share context between different tool calls\n * any other persistent storage needs during your work\n\nThe scratch pad is for persistent storage and state management, not for formatting output. Display information directly in your chat responses. However, when the scratch pad contains user-relevant state (like tasks lists or tracked progress), you should retrieve and display updates after modifications.\n\nUse the scratch pad when you need to:\n- Track progress across multiple tool calls\n- Build data structures incrementally  \n- Maintain state between operations\n- Store intermediate results for later use\n\nDon't use the scratch pad to:\n- Format text for display\n- Store static information just to retrieve and show it\n- Replace direct chat responses\n\nCORE OPERATIONS:\n- set_path: Store a value (not null) at a path, returns the parent container\n- get_path: Retrieve a value from a path, returns the value or nil\n- delete_path: Remove only the leaf value from a path, returns a confirmation message\n- inspect: Display the entire structure (or a specific path) with truncation at specified depth\n\nWARNING: null values can not be stored in the scratch pad, if you attempt to store a null value the set_path will fail.\n\nTRACKING PLANS WITH TASK LISTS:\n\nRecommended schema for a Task:\n{\n  task: \"Description of the task\",\n  done: false,\n  priority: \"high\", // optional: \"high\", \"medium\", \"low\"\n  context: \"Additional details\", // optional\n  subtasks: [  // optional: array of subtask objects\n    {task: \"Subtask 1\", done: false},\n    {task: \"Subtask 2\", done: true}\n  ]\n}\n\nFirst add multiple tasks items at once as an array:\n- Entire array:\n  op: set_path\n  path: [\"tasks\"]\n  value: [\n    {task: \"Write tests\", done: false, priority: \"high\"},\n    {task: \"Review PR\", done: false, priority: \"high\"},\n    {task: \"Update docs\", done: false, priority: \"medium\", subtasks: [\n      {task: \"Update API docs\", done: false},\n      {task: \"Update README\", done: false}\n    ]}\n  ]\n  explanation: Adding multiple tasks at once\n\nAdding tasks items:\n- First item:\n  op: set_path\n  path: [\"tasks\", 3]\n  value: {task: \"Run tests\", done: false}\n  explanation: Adding write tests task\n\n- Next item:\n  op: set_path\n  path: [\"tasks\", 4]\n  value: {task: \"Notify user\", done: false, priority: \"high\"}\n  explanation: Adding high priority task\n\nChecking off completed tasks:\n- Mark as done:\n  op: set_path\n  path: [\"tasks\", 0, \"done\"]\n  value: true\n  explanation: Completed writing tests\n\n- Mark subtask as done:\n  op: set_path\n  path: [\"tasks\", 2, \"subtasks\", 0, \"done\"]\n  value: true\n  explanation: Completed API docs update\n\nAdding a new task to the array:\n- Append to array:\n  op: set_path\n  path: [\"tasks\", 3]\n  value: {task: \"Deploy to production\", done: false, priority: \"high\"}\n  explanation: Adding deployment task\n\nViewing tasks:\n- All tasks:\n  op: get_path\n  path: [\"tasks\"]\n  explanation: Get all tasks\n\n- Specific task:\n  op: get_path\n  path: [\"tasks\", 0]\n  explanation: Checking first task details\n\n- View with depth limit:\n  op: inspect\n  path: [\"tasks\"]\n  depth: 2\n  explanation: View tasks with limited nesting","inputSchema":{"type":"object","properties":{"op":{"type":"string","enum":["set_path","get_path","delete_path","inspect"],"description":"The operation to perform:\n * set_path: set a value at a path\n * get_path: retrieve a value at a path\n * delete_path: remove the value at the path from the data structure\n * inspect: view the datastructure (or a specific path within it) up to a certain depth\n"},"path":{"type":"array","items":{"type":"string"},"description":"Path to the data location (array of string or number keys) - used for set_path, get_path, delete_path, and optionally inspect"},"value":{"description":"Value to store (for set_path). Can be ANY JSON value EXCEPT null: object, array, string, number, boolean.","type":"object"},"explanation":{"type":"string","description":"Explanation of why this operation is being performed"},"depth":{"type":"number","description":"(Optional) For inspect operation: Maximum depth to display (default: 5). Must be a positive integer."}},"required":["op","explanation"]}},{"name":"clojure_eval","description":"Takes a Clojure Expression and evaluates it in the current namespace. For example, providing \"(+ 1 2)\" will evaluate to 3.\n\nThis tool is intended to execute Clojure code. This is very helpful for verifying that code is working as expected. It's also helpful for REPL driven development.\n\nIf you send multiple expressions they will all be evaluated individually and their output will be clearly partitioned.\n\nIf the returned value is too long it will be truncated.\n\nIMPORTANT: When using `require` to reload namespaces ALWAYS use `:reload` to ensure you get the latest version of files.\n\nREPL helper functions are automatically loaded in the 'clj-mcp.repl-tools' namespace, providing convenient namespace and symbol exploration:\n\nNamespace/Symbol inspection functions:\n  clj-mcp.repl-tools/list-ns           - List all available namespaces\n  clj-mcp.repl-tools/list-vars         - List all vars in namespace\n  clj-mcp.repl-tools/doc-symbol        - Show documentation for symbol\n  clj-mcp.repl-tools/source-symbol     - Show source code for symbol\n  clj-mcp.repl-tools/find-symbols      - Find symbols matching pattern\n  clj-mcp.repl-tools/complete          - Find completions for prefix\n  clj-mcp.repl-tools/help              - Show this help message\n\nExamples:\n  (clj-mcp.repl-tools/list-ns)                     ; List all namespaces\n  (clj-mcp.repl-tools/list-vars 'clojure.string)   ; List functions in clojure.string\n  (clj-mcp.repl-tools/doc-symbol 'map)             ; Show documentation for map\n  (clj-mcp.repl-tools/source-symbol 'map)          ; Show source code for map\n  (clj-mcp.repl-tools/find-symbols \"seq\")          ; Find symbols containing \"seq\"\n  (clj-mcp.repl-tools/complete \"clojure.string/j\") ; Find completions for prefix","inputSchema":{"type":"object","properties":{"code":{"type":"string","description":"The Clojure code to evaluate."}},"required":["code"]}},{"name":"bash","description":"Execute bash shell commands on the host system.\n\nExamples:\n1. List files: bash(command: \"ls -la\")\n2. Find text in files: bash(command: \"grep -r 'pattern' /path/to/search\")\n3. With working directory: bash(command: \"ls -la\", working_directory: \"/tmp\")\n4. With timeout: bash(command: \"sleep 10\", timeout_ms: 5000)\n5. Git commands \n\nFor long running processes like running tests increase the timeout_ms so that the process can complete.\n\nNote: Non-zero exit codes are NOT treated as tool errors - check exit_code\nin the response to determine command success.","inputSchema":{"type":"object","properties":{"command":{"type":"string","description":"The shell command to execute"},"working_directory":{"type":"string","description":"Directory to run the command in (optional)"},"timeout_ms":{"type":"integer","description":"Maximum execution time in milliseconds (optional, default: 30000)"}},"required":["command"]}},{"name":"clojure_edit","description":"Edits a top-level form (`defn`, `def`, `defmethod`, `ns`, `deftest`) in a Clojure file using the specified operation.\n   \nPREFER this unified tool over generic file editing tools for Clojure files (`.clj` `.cljs` `.cljc` `.bb`)\n\nThis tool MAKES it EASIER to match a definition that exists in the file AS you only have to match the type of definition `form_type` and the complete identifier `form_identifier` of the definition. This prevents the repeated mismatch errors that occur when trying match an entire string of text for replacement.\nThis tool validates the structure of the Clojure code that is being inserted into the file and will provide linting feedback for things such as parenthetical errors.\nThis tool reduces the number of tokens that need to be generated.\n \nWARNING: you will receive errors if the syntax is wrong, the most common error is an extra or missing parenthesis in the `content`, so be careful with parenthesis.\n\n   Operations:\n   - \"replace\": Replaces the form with new content\n   - \"insert_before\": Inserts content before the form\n   - \"insert_after\": Inserts content after the form\n   \n   The form is identified by its type (defn, def, deftest, s/def, ns, defmethod etc.) and complete identifier.\n   \n   Example: Replace a function definition:\n   - file_path: \"/path/to/file.clj\"\n   - form_identifier: \"example-fn\"\n   - form_type: \"defn\"\n   - operation: \"replace\"\n   - content: \"(defn example-fn [x] (* x 2))\"\n   \n   Example: Insert a helper function before a function:\n   - file_path: \"/path/to/file.clj\"\n   - form_identifier: \"example-fn\"\n   - form_type: \"defn\"\n   - operation: \"insert_before\"\n   - content: \"(defn helper-fn [x] (* x 2))\"\n   \n   Example: Insert a test after a function:\n   - file_path: \"/path/to/file.clj\"\n   - form_identifier: \"example-fn\"\n   - form_type: \"defn\"\n   - operation: \"insert_after\"\n   - content: \"(deftest example-fn-test\n  (is (= 4 (example-fn 2))))\"\n   \nNote: For `defmethod` forms, be sure to include the dispatch value (`area :rectangle` or `qualified/area :rectangle`) in the `form_identifier`. Many `defmethod` definitions have qualified names (they include a namespace alias in their identifier like `shape/area`), so it's crucial to use the complete identifier that appears in the file.\n\n   Example: Replace a specific `defmethod` implementation:\n   - file_path: \"/path/to/file.clj\"\n   - form_identifier: \"shape/area :square\"\n   - form_type: \"defmethod\"\n   - operation: \"replace\"\n   - content: \"(defmethod shape/area :square [{:keys [w h]}] (* w h))\"\n\n   Example: Work with vector dispatch values:\n   - file_path: \"/path/to/file.clj\"\n   - form_identifier: \"convert-length [:feet :inches]\"\n   - form_type: \"defmethod\"\n   - operation: \"insert_before\"\n   - content: \"(def inches-per-foot 12)\"\n\n   The tool will find the form, perform the requested operation, and format the result.\n   It returns a diff showing the changes made to the file.","inputSchema":{"type":"object","properties":{"file_path":{"type":"string","description":"Path to the file containing the form to edit"},"form_identifier":{"type":"string","description":"Complete identifier of the form (e.g., function name, \"shape/area\", or \"convert-length [:feet :inches]\")"},"form_type":{"type":"string","description":"Type of the form (e.g., \"defn\", \"def\", \"ns\")"},"operation":{"type":"string","enum":["replace","insert_before","insert_after"],"description":"The editing operation to perform"},"content":{"type":"string","description":"New content to use for the operation"}},"required":["file_path","form_identifier","form_type","operation","content"]}},{"name":"clojure_edit_replace_sexp","description":"Edits a file by finding and replacing specific s-expressions.\n\nUse this tool for targeted edits of sub-expressions within forms. For complete top-level form replacements, prefer specialized tools like `clojure_edit_replace_definition` and friends.\n\nKEY BENEFITS:\n- Syntax-aware matching that understands Clojure code structure\n- Ignores whitespace differences by default, focusing on actual code meaning\n- Matches expressions regardless of formatting, indentation, or spacing\n- Prevents errors from mismatched text or irrelevant formatting differences\n- Can find and replace all occurrences with replace_all: true\n\nCONSTRAINTS:\n- match_form must contain only a SINGLE s-expression (error otherwise)\n- Requires syntactically valid Clojure expressions in both match_form and new_form\n\nWARNING: You will receive errors if the syntax is wrong. The most common error is an extra or missing parenthesis in either match_form or new_form, so count your parentheses carefully!\n\nCOMMON APPLICATIONS:\n- Renaming symbols throughout the file: {\"match_form\": \"old-name\", \"new_form\": \"new-name\", \"replace_all\": true}\n- Editing special forms like if/cond/let/when within functions:\n  * Changing if branches: {\"match_form\": \"(if condition expr1 expr2)\", \"new_form\": \"(if condition (do expr1) expr2)\"}\n  * Enhancing let bindings: {\"match_form\": \"(let [x 10] (+ x 2))\", \"new_form\": \"(let [x 10 y 20] (+ x y))\"}\n  * Converting cond to case: {\"match_form\": \"(cond (= x :a) \\\"A\\\" (= x :b) \\\"B\\\")\", \"new_form\": \"(case x :a \\\"A\\\" :b \\\"B\\\")\"}\n- Modifying nested function calls: {\"match_form\": \"(str (+ a b))\", \"new_form\": \"(str (+ a b c))\"}\n- Changing anonymous function syntax: {\"match_form\": \"#(update % :count inc)\", \"new_form\": \"(fn [x] (update x :count inc))\"}\n\nOther Examples:\n- Replace a calculation: {\"match_form\": \"(+ x 2)\", \"new_form\": \"(+ x 10)\"}\n  * Will match regardless of spaces: (+ x 2), (+   x   2), etc.\n- Delete an expression: {\"match_form\": \"(println debug-info)\", \"new_form\": \"\"}\n- Edit anonymous function: {\"match_form\": \"#(inc %)\", \"new_form\": \"#(+ % 2)\"}\n- Replace multiple occurrences: {\"match_form\": \"(inc x)\", \"new_form\": \"(+ x 1)\", \"replace_all\": true}\n\nReturns a diff showing the changes made to the file.","inputSchema":{"type":"object","properties":{"file_path":{"type":"string","description":"Path to the file to edit"},"match_form":{"type":"string","description":"The s-expression to find and replace (include # for anonymous functions)"},"new_form":{"type":"string","description":"The s-expression to replace with"},"replace_all":{"type":"boolean","description":"Whether to replace all occurrences (default: false)"}},"required":["file_path","match_form","new_form"]}},{"name":"file_edit","description":"Edit a file by replacing a specific text string with a new one. For safety, this tool requires that the string to replace appears exactly once in the file. \n\nFIRST: the clojure_edit tool is prefered because they use precise structural rewrite-clj editing. They also incorporate linting and ensure balance parenthesis.\n\nWHEN the clojure_edit tool won't work or you have a small easy edit \n\nPREFER the file_write tool for replacing more than half a file, this saves on tokens\n\nFor Clojure files (.clj, .cljs, .cljc, .edn):\n- Content will be linted for syntax errors before writing\n- Content will be formatted according to Clojure standards\n- Writing will fail if linting detects syntax errors\n\nTo make a file edit, provide the file_path, old_string (the text to replace), and new_string (the replacement text). The old_string must uniquely identify the specific instance you want to change, so include several lines of context before and after the change point. To create a new file, use file_write instead.","inputSchema":{"type":"object","properties":{"file_path":{"type":"string","description":"The absolute path to the file to modify (must be absolute, not relative)"},"old_string":{"type":"string","description":"The text to replace (must match the file contents exactly, including all whitespace and indentation)."},"new_string":{"type":"string","description":"The edited text to replace the old_string"}},"required":["file_path","old_string","new_string"]}},{"name":"file_write","description":"Write a file to the local filesystem. Overwrites the existing file if there is one.\n\nFor Clojure files (.clj, .cljs, .cljc, .edn):\n- Content will be linted for syntax errors before writing\n- Content will be formatted according to Clojure standards\n- Writing will fail if linting detects syntax errors\n\nFor other file types:\n- Content is written directly without linting or formatting\n\nIMPORTANT SAFETY FEATURE:\n- If the file has been modified since it was last read, writing will fail\n- You must use read_file to get the current content before editing a file\n- This prevents accidental overwrites of external changes\n\nReturns information about whether the file was created or updated, along with a diff \nshowing the changes made.\n\nBefore using this tool:\n1. Use the read_file tool to understand the file's contents and context\n2. Directory Verification (only applicable when creating new files):\n   - Use the list_directory tool to verify the parent directory exists and is the correct location\n3. For Clojure files, ensure code is syntactically correct\n\n# Example:\n# file_write(\n#   file_path: \"/absolute/path/to/file.clj\",\n#   content: \"(ns my.namespace)\\n\\n(defn my-function [x]\\n  (* x 2))\"\n# )","inputSchema":{"type":"object","properties":{"file_path":{"type":"string","description":"The absolute path to the file to write (must be absolute, not relative)"},"content":{"type":"string","description":"The content to write to the file"}},"required":["file_path","content"]}},{"name":"clojure_inspect_project","description":"Analyzes and provides detailed information about a Clojure project's structure, \nincluding dependencies, source files, namespaces, and environment details.\n\nThis tool helps you understand project organization without having to manually \nexplore multiple configuration files. It works with both deps.edn and Leiningen projects.\n\nThe tool provides information about:\n- Project environment (working directory, Clojure version, Java version)\n- Source and test paths\n- Dependencies and their versions\n- Aliases and their configurations\n- Available namespaces\n- Source file structure\n\nUse this tool to quickly get oriented in an unfamiliar Clojure codebase or to \nget a high-level overview of your current project.\n\n# Example:\nclojure_inspect_project()","inputSchema":{"type":"object","properties":{"explanation":{"type":"string","description":"Short explanation why you chose this tool"}},"required":["explanation"]}},{"name":"dispatch_agent","description":"Launch a new agent that has access to read-only tools. When you are searching for a keyword or file and are not confident that you will find the right match on the first try, use the Agent tool to perform the search for you. For example:\n\n- If you are searching for a keyword like \"config\" or \"logger\", the Agent tool is appropriate\n- If you want to read a specific file path, use the read_file or glob_files tool instead of the Agent tool, to find the match more quickly\n- If you are searching for a specific class definition like \"class Foo\", use the glob_files tool instead, to find the match more quickly\n\nUsage notes:\n1. Launch multiple agents concurrently whenever possible, to maximize performance; to do that, use a single message with multiple `agent` tool uses\n2. When the agent is done, it will return a single message back to you. The result returned by the agent is not visible to the user. To show the user the result, you should send a text message back to the user with a concise summary of the result.\n3. Each agent invocation is stateless. You will not be able to send additional messages to the agent, nor will the agent be able to communicate with you outside of its final report. Therefore, your prompt should contain a highly detailed task description for the agent to perform autonomously and you should specify exactly what information the agent should return back to you in its final and only message to you.\n4. The agent's outputs should generally be trusted","inputSchema":{"type":"object","properties":{"prompt":{"type":"string","description":"The prompt to send to the agent"}},"required":["prompt"]}},{"name":"architect","description":"Your go-to tool for any technical or coding task. Analyzes requirements and breaks them down into clear, actionable implementation steps. Use this whenever you need help planning how to implement a feature, solve a technical problem, or structure your code.","inputSchema":{"type":"object","properties":{"prompt":{"type":"string","description":"The technical request or coding task to analyze"},"context":{"type":"string","description":"Optional context from previous conversation or system state"}},"required":["prompt"]}},{"name":"code_critique","description":"Starts an interactive code review conversation that provides constructive feedback on your Clojure code.\n  \n  HOW TO USE THIS TOOL:\n  1. Submit your Clojure code for initial critique\n  2. Review the suggestions and implement improvements\n  3. Test your revised code in the REPL\n  4. Submit the updated code for additional feedback\n  5. Continue this cycle until the critique is satisfied\n  \n  This tool initiates a feedback loop where you:\n  - Receive detailed analysis of your code\n  - Implement suggested improvements\n  - Test and verify changes\n  - Get follow-up critique on your revisions\n  \n  The critique examines:\n  - Adherence to Clojure style conventions\n  - Functional programming best practices\n  - Performance optimizations\n  - Readability and maintainability improvements\n  - Idiomatic Clojure patterns\n  \n  Example conversation flow:\n  - You: Submit initial function implementation\n  - Tool: Provides feedback on style and structure\n  - You: Revise code based on suggestions and test in REPL\n  - Tool: Reviews updates and suggests further refinements\n  - Repeat until code quality goals are achieved\n  \n  Perfect for iterative learning and continuous code improvement.","inputSchema":{"type":"object","properties":{"code":{"type":"string","description":"The Clojure code to analyze and critique"},"context":{"type":"string","description":"Optional context from previous conversation or system state"}},"required":["code"]}}]}}
{"jsonrpc":"2.0","id":29,"result":{"resources":[{"uri":"custom://llm-code-style","name":"LLM_CODE_STYLE.md","description":"Guidelines for writing Clojure code for the current project hosting the REPL","mimeType":"text/markdown"},{"uri":"custom://project-summary","name":"PROJECT_SUMMARY.md","description":"A Clojure project summary document for the project hosting the REPL, this is intended to provide the LLM with important context to start.","mimeType":"text/markdown"},{"uri":"custom://claude","name":"CLAUDE.md","description":"The Claude instructions document for the current project hosting the REPL","mimeType":"text/markdown"},{"uri":"custom://readme","name":"README.md","description":"A README document for the current Clojure project hosting the REPL","mimeType":"text/markdown"},{"uri":"custom://project-info","name":"Clojure Project Info","description":"Information about the current Clojure project structure, attached REPL environment and dependencies","mimeType":"text/markdown"}]}}
{"jsonrpc":"2.0","id":30,"result":{"prompts":[{"name":"ACT/scratch_pad_load","description":"Loads a file into the scratch pad state. Returns status messages and a shallow inspect of the loaded data.","arguments":[{"name":"file_path","description":"Optional file path: default scratch_pad.edn","required":false}]},{"name":"clojure_repl_system_prompt","description":"Provides instructions and guidelines for Clojure development, including style and best practices.","arguments":[]},{"name":"create-update-project-summary","description":"Generates a prompt instructing the LLM to create a summary of a project.","arguments":[]},{"name":"chat-session-summarize","description":"Instructs the assistant to create a summary of the current chat session and store it in the scratch pad. `chat_session_key` is optional and will default to `chat_session_summary`","arguments":[{"name":"chat_session_key","description":"[Optional] key to store the session summary in","required":false}]},{"name":"ACT/scratch_pad_save_as","description":"Saves the current scratch pad state to a specified file.","arguments":[{"name":"file_path","description":"File path: relative to .clojure-mcp/ directory","required":true}]},{"name":"chat-session-resume","description":"Instructs the assistant to resume a previous chat session by loading context from the scratch pad. `chat_session_key` is optional and will default to `chat_session_summary`","arguments":[{"name":"chat_session_key","description":"[Optional] key where session summary is stored","required":false}]},{"name":"ACT/add-dir","description":"Adds a directory to the allowed-directories list, giving the LLM access to it","arguments":[{"name":"directory","description":"Directory path to add (can be relative or absolute)","required":true}]},{"name":"plan-and-execute","description":"Use the scratch pad tool to plan and execute an change","arguments":[]}]}}
{"jsonrpc":"2.0","id":31,"result":{"tools":[{"name":"LS","description":"Returns a recursive tree view of files and directories starting from the specified path. The path parameter must be an absolute path, not a relative path. You should generally prefer the `glob_files` and `fx_grep` tools, if you know which directories to search.","inputSchema":{"type":"object","properties":{"path":{"type":"string"},"max_depth":{"type":"integer","description":"Maximum depth to traverse (optional)"},"limit":{"type":"integer","description":"Maximum number of entries to show (default: 100)"}},"required":["path"]}},{"name":"read_file","description":"Smart file reader with pattern-based exploration for Clojure files.\n   \nFor Clojure files (.clj, .cljc, .cljs, .bb):\n\nThis tool defaults to an expandable collapsed view to quickly grab the information you need from a Clojure file.\nIf called without `name_pattern` or `content_pattern` it will return the file content where \nyou will see only function signatures. This gives you a quick overview of the file.\n\nWhen you want to see more, this tool has a grep functionality where you\ncan give patterns to match the names for top level definitions\n`name_pattern` or match the bodies of top level definitions `content_pattern`.\n\nThe functions that match these patterns will be the only functions expanded in collapsed view.\n\nFor defmethod forms:\n- The name includes both the method name and the dispatch value (e.g., \"area :rectangle\")\n- For vector dispatch values, use the exact pattern (e.g., \"dispatch-with-vector \\[:feet :inches\\]\")\n- For qualified/namespaced multimethod names, include the namespace (e.g., \"tool-system/validate-inputs :clojure-eval\")\n\nFor text files (non-Clojure):\n- When `collapsed: true` and a pattern is provided (`content_pattern` or `name_pattern`), shows only lines matching the pattern with 10 lines of context before and after\n\nFor all other file types:\n- Collapsed view will not be applied and will return the raw contents of the file\n\nParameters:\n- path: Path to the file (required)\n- collapsed: Show collapsed view (default: true)\n\nCollapsed View mode function expansion parameters:\n\n- name_pattern: Regex to match function names (e.g., \"validate.*\")\n- content_pattern: Regex to match function content (e.g., \"try|catch\")\n\nExample usage for defmethod forms:\n- Find all implementations of a multimethod: `name_pattern: \"area\"`\n- Find specific dispatch values: `name_pattern: \"area :circle\"`\n- Find vector dispatch values: `name_pattern: \"convert-length \\\\[:feet :inches\\\\]\"`\n- Find namespace-qualified methods: `name_pattern: \"tool-system/validate-inputs\"`\n\nExample usage for text files:\n- Find error messages: `content_pattern: \"ERROR|WARN\"`\n- Find specific log entries: `content_pattern: \"\\\\[2024-01-15.*ERROR\\\\]\"`\n\nNon collapsed view mode respects these parameters:\n\n- line_offset: Line to start reading from (non-collapsed mode only, default: 0)\n- limit: Maximum lines to read (non-collapsed mode only, default: 2000)\n\nBy default, reads up to 2000 lines, truncating lines longer than 1000 characters.","inputSchema":{"type":"object","properties":{"path":{"type":"string","description":"Path to the file to read"},"collapsed":{"type":"boolean","description":"Whether to show collapsed view for Clojure files (default: true)"},"name_pattern":{"type":"string","description":"Pattern to match function names (e.g., \"validate.*\")"},"content_pattern":{"type":"string","description":"Pattern to match function content (e.g., \"try|catch\")"},"line_offset":{"type":"integer","description":"Line to start reading from for raw mode (default: 0)"},"limit":{"type":"integer","description":"Maximum lines to read (default: 2000)"}},"required":["path"]}},{"name":"grep","description":"Fast content search tool that works with any codebase size.\n- Finds the paths to files that have matching contents using regular expressions.\n- Supports full regex syntax (eg. \"log.*Error\", \"function\\s+\\w+\", etc.).\n- Filter files by pattern with the include parameter (eg. \"*.js\", \"*.{ts,tsx}\").\n- Returns matching file paths sorted by modification time.\n- Use this tool when you need to find files containing specific patterns.\n- When you are doing an open ended search that may require multiple rounds of globbing and grepping, use the `dispatch_agent` tool instead","inputSchema":{"type":"object","properties":{"path":{"type":"string","description":"The directory to search in. Defaults to the current working directory."},"pattern":{"type":"string","description":"The regular expression pattern to search for in file contents"},"include":{"type":"string","description":"File pattern to include in the search (e.g. \"*.clj\", \"*.{clj,cljs}\")"},"max_results":{"type":"integer","description":"Maximum number of results to return (default: 1000)"}},"required":["pattern"]}},{"name":"glob_files","description":"Fast file pattern matching tool that works with any codebase size.\n - Supports glob patterns like \"**/*.clj\" or \"src/**/*.cljs\".\n - Returns matching file paths sorted by modification time (most recent first).\n - Use this tool when you need to find files by name patterns.\n - When you are doing an open ended search that may require multiple rounds of globbing and grepping, use the `dispatch_agent` tool instead","inputSchema":{"type":"object","properties":{"path":{"type":"string","description":"Root directory to start the search from (defaults to current working directory)"},"pattern":{"type":"string","description":"Glob pattern (e.g. \"**/*.clj\", \"src/**/*.tsx\")"},"max_results":{"type":"integer","description":"Maximum number of results to return (default: 1000)"}},"required":["pattern"]}},{"name":"think","description":"Use the tool to think about something. It will not obtain new information or make any changes to the repository, but just log the thought. Use it when complex reasoning or brainstorming is needed. \nCommon use cases:\n* when having difficulty finding/reading the files you need\n* when having difficulty writing out code\n* when having difficulty using the tools or the clojure tools\n* When exploring a repository and discovering the source of a bug, call this tool to brainstorm several unique ways of fixing the bug, and assess which change(s) are likely to be simplest and most effective.\n* After receiving test results, use this tool to brainstorm ways to fix failing tests.\n* When planning a complex refactoring, use this tool to outline different approaches and their tradeoffs.\n* When designing a new feature, use this tool to think through architecture decisions and implementation details.\n* When debugging a complex issue, use this tool to organize your thoughts and hypotheses.\nThe tool simply logs your thought process for better transparency and does not execute any code or make changes.","inputSchema":{"type":"object","properties":{"thought":{"type":"string","description":"The thought to log"}},"required":["thought"]}},{"name":"scratch_pad","description":"A persistent scratch pad for storing structured data between tool calls. Accepts any JSON value (objects, arrays, strings, numbers, booleans, null) and stores them at nested paths using set_path, get_path, delete_path operations.\n\nTHIS IS YOUR GO-TO TOOL FOR PLANNING.\n\nYour persistent workspace for planning, organizing thoughts, and maintaining state across tool invocations.\n\nThis tool can be used to:\n * develop and track multi-step plans\n * maintain task lists and task tracking\n * store intermediate results between operations\n * keep notes about your current approach or strategy\n * maintain a list of files or resources to process\n * build up complex data structures incrementally\n * share context between different tool calls\n * any other persistent storage needs during your work\n\nThe scratch pad is for persistent storage and state management, not for formatting output. Display information directly in your chat responses. However, when the scratch pad contains user-relevant state (like tasks lists or tracked progress), you should retrieve and display updates after modifications.\n\nUse the scratch pad when you need to:\n- Track progress across multiple tool calls\n- Build data structures incrementally  \n- Maintain state between operations\n- Store intermediate results for later use\n\nDon't use the scratch pad to:\n- Format text for display\n- Store static information just to retrieve and show it\n- Replace direct chat responses\n\nCORE OPERATIONS:\n- set_path: Store a value (not null) at a path, returns the parent container\n- get_path: Retrieve a value from a path, returns the value or nil\n- delete_path: Remove only the leaf value from a path, returns a confirmation message\n- inspect: Display the entire structure (or a specific path) with truncation at specified depth\n\nWARNING: null values can not be stored in the scratch pad, if you attempt to store a null value the set_path will fail.\n\nTRACKING PLANS WITH TASK LISTS:\n\nRecommended schema for a Task:\n{\n  task: \"Description of the task\",\n  done: false,\n  priority: \"high\", // optional: \"high\", \"medium\", \"low\"\n  context: \"Additional details\", // optional\n  subtasks: [  // optional: array of subtask objects\n    {task: \"Subtask 1\", done: false},\n    {task: \"Subtask 2\", done: true}\n  ]\n}\n\nFirst add multiple tasks items at once as an array:\n- Entire array:\n  op: set_path\n  path: [\"tasks\"]\n  value: [\n    {task: \"Write tests\", done: false, priority: \"high\"},\n    {task: \"Review PR\", done: false, priority: \"high\"},\n    {task: \"Update docs\", done: false, priority: \"medium\", subtasks: [\n      {task: \"Update API docs\", done: false},\n      {task: \"Update README\", done: false}\n    ]}\n  ]\n  explanation: Adding multiple tasks at once\n\nAdding tasks items:\n- First item:\n  op: set_path\n  path: [\"tasks\", 3]\n  value: {task: \"Run tests\", done: false}\n  explanation: Adding write tests task\n\n- Next item:\n  op: set_path\n  path: [\"tasks\", 4]\n  value: {task: \"Notify user\", done: false, priority: \"high\"}\n  explanation: Adding high priority task\n\nChecking off completed tasks:\n- Mark as done:\n  op: set_path\n  path: [\"tasks\", 0, \"done\"]\n  value: true\n  explanation: Completed writing tests\n\n- Mark subtask as done:\n  op: set_path\n  path: [\"tasks\", 2, \"subtasks\", 0, \"done\"]\n  value: true\n  explanation: Completed API docs update\n\nAdding a new task to the array:\n- Append to array:\n  op: set_path\n  path: [\"tasks\", 3]\n  value: {task: \"Deploy to production\", done: false, priority: \"high\"}\n  explanation: Adding deployment task\n\nViewing tasks:\n- All tasks:\n  op: get_path\n  path: [\"tasks\"]\n  explanation: Get all tasks\n\n- Specific task:\n  op: get_path\n  path: [\"tasks\", 0]\n  explanation: Checking first task details\n\n- View with depth limit:\n  op: inspect\n  path: [\"tasks\"]\n  depth: 2\n  explanation: View tasks with limited nesting","inputSchema":{"type":"object","properties":{"op":{"type":"string","enum":["set_path","get_path","delete_path","inspect"],"description":"The operation to perform:\n * set_path: set a value at a path\n * get_path: retrieve a value at a path\n * delete_path: remove the value at the path from the data structure\n * inspect: view the datastructure (or a specific path within it) up to a certain depth\n"},"path":{"type":"array","items":{"type":"string"},"description":"Path to the data location (array of string or number keys) - used for set_path, get_path, delete_path, and optionally inspect"},"value":{"description":"Value to store (for set_path). Can be ANY JSON value EXCEPT null: object, array, string, number, boolean.","type":"object"},"explanation":{"type":"string","description":"Explanation of why this operation is being performed"},"depth":{"type":"number","description":"(Optional) For inspect operation: Maximum depth to display (default: 5). Must be a positive integer."}},"required":["op","explanation"]}},{"name":"clojure_eval","description":"Takes a Clojure Expression and evaluates it in the current namespace. For example, providing \"(+ 1 2)\" will evaluate to 3.\n\nThis tool is intended to execute Clojure code. This is very helpful for verifying that code is working as expected. It's also helpful for REPL driven development.\n\nIf you send multiple expressions they will all be evaluated individually and their output will be clearly partitioned.\n\nIf the returned value is too long it will be truncated.\n\nIMPORTANT: When using `require` to reload namespaces ALWAYS use `:reload` to ensure you get the latest version of files.\n\nREPL helper functions are automatically loaded in the 'clj-mcp.repl-tools' namespace, providing convenient namespace and symbol exploration:\n\nNamespace/Symbol inspection functions:\n  clj-mcp.repl-tools/list-ns           - List all available namespaces\n  clj-mcp.repl-tools/list-vars         - List all vars in namespace\n  clj-mcp.repl-tools/doc-symbol        - Show documentation for symbol\n  clj-mcp.repl-tools/source-symbol     - Show source code for symbol\n  clj-mcp.repl-tools/find-symbols      - Find symbols matching pattern\n  clj-mcp.repl-tools/complete          - Find completions for prefix\n  clj-mcp.repl-tools/help              - Show this help message\n\nExamples:\n  (clj-mcp.repl-tools/list-ns)                     ; List all namespaces\n  (clj-mcp.repl-tools/list-vars 'clojure.string)   ; List functions in clojure.string\n  (clj-mcp.repl-tools/doc-symbol 'map)             ; Show documentation for map\n  (clj-mcp.repl-tools/source-symbol 'map)          ; Show source code for map\n  (clj-mcp.repl-tools/find-symbols \"seq\")          ; Find symbols containing \"seq\"\n  (clj-mcp.repl-tools/complete \"clojure.string/j\") ; Find completions for prefix","inputSchema":{"type":"object","properties":{"code":{"type":"string","description":"The Clojure code to evaluate."}},"required":["code"]}},{"name":"bash","description":"Execute bash shell commands on the host system.\n\nExamples:\n1. List files: bash(command: \"ls -la\")\n2. Find text in files: bash(command: \"grep -r 'pattern' /path/to/search\")\n3. With working directory: bash(command: \"ls -la\", working_directory: \"/tmp\")\n4. With timeout: bash(command: \"sleep 10\", timeout_ms: 5000)\n5. Git commands \n\nFor long running processes like running tests increase the timeout_ms so that the process can complete.\n\nNote: Non-zero exit codes are NOT treated as tool errors - check exit_code\nin the response to determine command success.","inputSchema":{"type":"object","properties":{"command":{"type":"string","description":"The shell command to execute"},"working_directory":{"type":"string","description":"Directory to run the command in (optional)"},"timeout_ms":{"type":"integer","description":"Maximum execution time in milliseconds (optional, default: 30000)"}},"required":["command"]}},{"name":"clojure_edit","description":"Edits a top-level form (`defn`, `def`, `defmethod`, `ns`, `deftest`) in a Clojure file using the specified operation.\n   \nPREFER this unified tool over generic file editing tools for Clojure files (`.clj` `.cljs` `.cljc` `.bb`)\n\nThis tool MAKES it EASIER to match a definition that exists in the file AS you only have to match the type of definition `form_type` and the complete identifier `form_identifier` of the definition. This prevents the repeated mismatch errors that occur when trying match an entire string of text for replacement.\nThis tool validates the structure of the Clojure code that is being inserted into the file and will provide linting feedback for things such as parenthetical errors.\nThis tool reduces the number of tokens that need to be generated.\n \nWARNING: you will receive errors if the syntax is wrong, the most common error is an extra or missing parenthesis in the `content`, so be careful with parenthesis.\n\n   Operations:\n   - \"replace\": Replaces the form with new content\n   - \"insert_before\": Inserts content before the form\n   - \"insert_after\": Inserts content after the form\n   \n   The form is identified by its type (defn, def, deftest, s/def, ns, defmethod etc.) and complete identifier.\n   \n   Example: Replace a function definition:\n   - file_path: \"/path/to/file.clj\"\n   - form_identifier: \"example-fn\"\n   - form_type: \"defn\"\n   - operation: \"replace\"\n   - content: \"(defn example-fn [x] (* x 2))\"\n   \n   Example: Insert a helper function before a function:\n   - file_path: \"/path/to/file.clj\"\n   - form_identifier: \"example-fn\"\n   - form_type: \"defn\"\n   - operation: \"insert_before\"\n   - content: \"(defn helper-fn [x] (* x 2))\"\n   \n   Example: Insert a test after a function:\n   - file_path: \"/path/to/file.clj\"\n   - form_identifier: \"example-fn\"\n   - form_type: \"defn\"\n   - operation: \"insert_after\"\n   - content: \"(deftest example-fn-test\n  (is (= 4 (example-fn 2))))\"\n   \nNote: For `defmethod` forms, be sure to include the dispatch value (`area :rectangle` or `qualified/area :rectangle`) in the `form_identifier`. Many `defmethod` definitions have qualified names (they include a namespace alias in their identifier like `shape/area`), so it's crucial to use the complete identifier that appears in the file.\n\n   Example: Replace a specific `defmethod` implementation:\n   - file_path: \"/path/to/file.clj\"\n   - form_identifier: \"shape/area :square\"\n   - form_type: \"defmethod\"\n   - operation: \"replace\"\n   - content: \"(defmethod shape/area :square [{:keys [w h]}] (* w h))\"\n\n   Example: Work with vector dispatch values:\n   - file_path: \"/path/to/file.clj\"\n   - form_identifier: \"convert-length [:feet :inches]\"\n   - form_type: \"defmethod\"\n   - operation: \"insert_before\"\n   - content: \"(def inches-per-foot 12)\"\n\n   The tool will find the form, perform the requested operation, and format the result.\n   It returns a diff showing the changes made to the file.","inputSchema":{"type":"object","properties":{"file_path":{"type":"string","description":"Path to the file containing the form to edit"},"form_identifier":{"type":"string","description":"Complete identifier of the form (e.g., function name, \"shape/area\", or \"convert-length [:feet :inches]\")"},"form_type":{"type":"string","description":"Type of the form (e.g., \"defn\", \"def\", \"ns\")"},"operation":{"type":"string","enum":["replace","insert_before","insert_after"],"description":"The editing operation to perform"},"content":{"type":"string","description":"New content to use for the operation"}},"required":["file_path","form_identifier","form_type","operation","content"]}},{"name":"clojure_edit_replace_sexp","description":"Edits a file by finding and replacing specific s-expressions.\n\nUse this tool for targeted edits of sub-expressions within forms. For complete top-level form replacements, prefer specialized tools like `clojure_edit_replace_definition` and friends.\n\nKEY BENEFITS:\n- Syntax-aware matching that understands Clojure code structure\n- Ignores whitespace differences by default, focusing on actual code meaning\n- Matches expressions regardless of formatting, indentation, or spacing\n- Prevents errors from mismatched text or irrelevant formatting differences\n- Can find and replace all occurrences with replace_all: true\n\nCONSTRAINTS:\n- match_form must contain only a SINGLE s-expression (error otherwise)\n- Requires syntactically valid Clojure expressions in both match_form and new_form\n\nWARNING: You will receive errors if the syntax is wrong. The most common error is an extra or missing parenthesis in either match_form or new_form, so count your parentheses carefully!\n\nCOMMON APPLICATIONS:\n- Renaming symbols throughout the file: {\"match_form\": \"old-name\", \"new_form\": \"new-name\", \"replace_all\": true}\n- Editing special forms like if/cond/let/when within functions:\n  * Changing if branches: {\"match_form\": \"(if condition expr1 expr2)\", \"new_form\": \"(if condition (do expr1) expr2)\"}\n  * Enhancing let bindings: {\"match_form\": \"(let [x 10] (+ x 2))\", \"new_form\": \"(let [x 10 y 20] (+ x y))\"}\n  * Converting cond to case: {\"match_form\": \"(cond (= x :a) \\\"A\\\" (= x :b) \\\"B\\\")\", \"new_form\": \"(case x :a \\\"A\\\" :b \\\"B\\\")\"}\n- Modifying nested function calls: {\"match_form\": \"(str (+ a b))\", \"new_form\": \"(str (+ a b c))\"}\n- Changing anonymous function syntax: {\"match_form\": \"#(update % :count inc)\", \"new_form\": \"(fn [x] (update x :count inc))\"}\n\nOther Examples:\n- Replace a calculation: {\"match_form\": \"(+ x 2)\", \"new_form\": \"(+ x 10)\"}\n  * Will match regardless of spaces: (+ x 2), (+   x   2), etc.\n- Delete an expression: {\"match_form\": \"(println debug-info)\", \"new_form\": \"\"}\n- Edit anonymous function: {\"match_form\": \"#(inc %)\", \"new_form\": \"#(+ % 2)\"}\n- Replace multiple occurrences: {\"match_form\": \"(inc x)\", \"new_form\": \"(+ x 1)\", \"replace_all\": true}\n\nReturns a diff showing the changes made to the file.","inputSchema":{"type":"object","properties":{"file_path":{"type":"string","description":"Path to the file to edit"},"match_form":{"type":"string","description":"The s-expression to find and replace (include # for anonymous functions)"},"new_form":{"type":"string","description":"The s-expression to replace with"},"replace_all":{"type":"boolean","description":"Whether to replace all occurrences (default: false)"}},"required":["file_path","match_form","new_form"]}},{"name":"file_edit","description":"Edit a file by replacing a specific text string with a new one. For safety, this tool requires that the string to replace appears exactly once in the file. \n\nFIRST: the clojure_edit tool is prefered because they use precise structural rewrite-clj editing. They also incorporate linting and ensure balance parenthesis.\n\nWHEN the clojure_edit tool won't work or you have a small easy edit \n\nPREFER the file_write tool for replacing more than half a file, this saves on tokens\n\nFor Clojure files (.clj, .cljs, .cljc, .edn):\n- Content will be linted for syntax errors before writing\n- Content will be formatted according to Clojure standards\n- Writing will fail if linting detects syntax errors\n\nTo make a file edit, provide the file_path, old_string (the text to replace), and new_string (the replacement text). The old_string must uniquely identify the specific instance you want to change, so include several lines of context before and after the change point. To create a new file, use file_write instead.","inputSchema":{"type":"object","properties":{"file_path":{"type":"string","description":"The absolute path to the file to modify (must be absolute, not relative)"},"old_string":{"type":"string","description":"The text to replace (must match the file contents exactly, including all whitespace and indentation)."},"new_string":{"type":"string","description":"The edited text to replace the old_string"}},"required":["file_path","old_string","new_string"]}},{"name":"file_write","description":"Write a file to the local filesystem. Overwrites the existing file if there is one.\n\nFor Clojure files (.clj, .cljs, .cljc, .edn):\n- Content will be linted for syntax errors before writing\n- Content will be formatted according to Clojure standards\n- Writing will fail if linting detects syntax errors\n\nFor other file types:\n- Content is written directly without linting or formatting\n\nIMPORTANT SAFETY FEATURE:\n- If the file has been modified since it was last read, writing will fail\n- You must use read_file to get the current content before editing a file\n- This prevents accidental overwrites of external changes\n\nReturns information about whether the file was created or updated, along with a diff \nshowing the changes made.\n\nBefore using this tool:\n1. Use the read_file tool to understand the file's contents and context\n2. Directory Verification (only applicable when creating new files):\n   - Use the list_directory tool to verify the parent directory exists and is the correct location\n3. For Clojure files, ensure code is syntactically correct\n\n# Example:\n# file_write(\n#   file_path: \"/absolute/path/to/file.clj\",\n#   content: \"(ns my.namespace)\\n\\n(defn my-function [x]\\n  (* x 2))\"\n# )","inputSchema":{"type":"object","properties":{"file_path":{"type":"string","description":"The absolute path to the file to write (must be absolute, not relative)"},"content":{"type":"string","description":"The content to write to the file"}},"required":["file_path","content"]}},{"name":"clojure_inspect_project","description":"Analyzes and provides detailed information about a Clojure project's structure, \nincluding dependencies, source files, namespaces, and environment details.\n\nThis tool helps you understand project organization without having to manually \nexplore multiple configuration files. It works with both deps.edn and Leiningen projects.\n\nThe tool provides information about:\n- Project environment (working directory, Clojure version, Java version)\n- Source and test paths\n- Dependencies and their versions\n- Aliases and their configurations\n- Available namespaces\n- Source file structure\n\nUse this tool to quickly get oriented in an unfamiliar Clojure codebase or to \nget a high-level overview of your current project.\n\n# Example:\nclojure_inspect_project()","inputSchema":{"type":"object","properties":{"explanation":{"type":"string","description":"Short explanation why you chose this tool"}},"required":["explanation"]}},{"name":"dispatch_agent","description":"Launch a new agent that has access to read-only tools. When you are searching for a keyword or file and are not confident that you will find the right match on the first try, use the Agent tool to perform the search for you. For example:\n\n- If you are searching for a keyword like \"config\" or \"logger\", the Agent tool is appropriate\n- If you want to read a specific file path, use the read_file or glob_files tool instead of the Agent tool, to find the match more quickly\n- If you are searching for a specific class definition like \"class Foo\", use the glob_files tool instead, to find the match more quickly\n\nUsage notes:\n1. Launch multiple agents concurrently whenever possible, to maximize performance; to do that, use a single message with multiple `agent` tool uses\n2. When the agent is done, it will return a single message back to you. The result returned by the agent is not visible to the user. To show the user the result, you should send a text message back to the user with a concise summary of the result.\n3. Each agent invocation is stateless. You will not be able to send additional messages to the agent, nor will the agent be able to communicate with you outside of its final report. Therefore, your prompt should contain a highly detailed task description for the agent to perform autonomously and you should specify exactly what information the agent should return back to you in its final and only message to you.\n4. The agent's outputs should generally be trusted","inputSchema":{"type":"object","properties":{"prompt":{"type":"string","description":"The prompt to send to the agent"}},"required":["prompt"]}},{"name":"architect","description":"Your go-to tool for any technical or coding task. Analyzes requirements and breaks them down into clear, actionable implementation steps. Use this whenever you need help planning how to implement a feature, solve a technical problem, or structure your code.","inputSchema":{"type":"object","properties":{"prompt":{"type":"string","description":"The technical request or coding task to analyze"},"context":{"type":"string","description":"Optional context from previous conversation or system state"}},"required":["prompt"]}},{"name":"code_critique","description":"Starts an interactive code review conversation that provides constructive feedback on your Clojure code.\n  \n  HOW TO USE THIS TOOL:\n  1. Submit your Clojure code for initial critique\n  2. Review the suggestions and implement improvements\n  3. Test your revised code in the REPL\n  4. Submit the updated code for additional feedback\n  5. Continue this cycle until the critique is satisfied\n  \n  This tool initiates a feedback loop where you:\n  - Receive detailed analysis of your code\n  - Implement suggested improvements\n  - Test and verify changes\n  - Get follow-up critique on your revisions\n  \n  The critique examines:\n  - Adherence to Clojure style conventions\n  - Functional programming best practices\n  - Performance optimizations\n  - Readability and maintainability improvements\n  - Idiomatic Clojure patterns\n  \n  Example conversation flow:\n  - You: Submit initial function implementation\n  - Tool: Provides feedback on style and structure\n  - You: Revise code based on suggestions and test in REPL\n  - Tool: Reviews updates and suggests further refinements\n  - Repeat until code quality goals are achieved\n  \n  Perfect for iterative learning and continuous code improvement.","inputSchema":{"type":"object","properties":{"code":{"type":"string","description":"The Clojure code to analyze and critique"},"context":{"type":"string","description":"Optional context from previous conversation or system state"}},"required":["code"]}}]}}
{"jsonrpc":"2.0","id":32,"result":{"resources":[{"uri":"custom://llm-code-style","name":"LLM_CODE_STYLE.md","description":"Guidelines for writing Clojure code for the current project hosting the REPL","mimeType":"text/markdown"},{"uri":"custom://project-summary","name":"PROJECT_SUMMARY.md","description":"A Clojure project summary document for the project hosting the REPL, this is intended to provide the LLM with important context to start.","mimeType":"text/markdown"},{"uri":"custom://claude","name":"CLAUDE.md","description":"The Claude instructions document for the current project hosting the REPL","mimeType":"text/markdown"},{"uri":"custom://readme","name":"README.md","description":"A README document for the current Clojure project hosting the REPL","mimeType":"text/markdown"},{"uri":"custom://project-info","name":"Clojure Project Info","description":"Information about the current Clojure project structure, attached REPL environment and dependencies","mimeType":"text/markdown"}]}}
{"jsonrpc":"2.0","id":33,"result":{"prompts":[{"name":"ACT/scratch_pad_load","description":"Loads a file into the scratch pad state. Returns status messages and a shallow inspect of the loaded data.","arguments":[{"name":"file_path","description":"Optional file path: default scratch_pad.edn","required":false}]},{"name":"clojure_repl_system_prompt","description":"Provides instructions and guidelines for Clojure development, including style and best practices.","arguments":[]},{"name":"create-update-project-summary","description":"Generates a prompt instructing the LLM to create a summary of a project.","arguments":[]},{"name":"chat-session-summarize","description":"Instructs the assistant to create a summary of the current chat session and store it in the scratch pad. `chat_session_key` is optional and will default to `chat_session_summary`","arguments":[{"name":"chat_session_key","description":"[Optional] key to store the session summary in","required":false}]},{"name":"ACT/scratch_pad_save_as","description":"Saves the current scratch pad state to a specified file.","arguments":[{"name":"file_path","description":"File path: relative to .clojure-mcp/ directory","required":true}]},{"name":"chat-session-resume","description":"Instructs the assistant to resume a previous chat session by loading context from the scratch pad. `chat_session_key` is optional and will default to `chat_session_summary`","arguments":[{"name":"chat_session_key","description":"[Optional] key where session summary is stored","required":false}]},{"name":"ACT/add-dir","description":"Adds a directory to the allowed-directories list, giving the LLM access to it","arguments":[{"name":"directory","description":"Directory path to add (can be relative or absolute)","required":true}]},{"name":"plan-and-execute","description":"Use the scratch pad tool to plan and execute an change","arguments":[]}]}}
{"jsonrpc":"2.0","id":34,"result":{"content":[{"type":"text","text":"# THIS IS A COLLAPSED VIEW /Users/stepbeek/HappyValley/wick/src/example/routes.clj\nSet `collapsed: false` to view the entire file\n*** `/Users/stepbeek/HappyValley/wick/src/example/routes.clj`\n```clojure\n(ns example.routes\n  (:require [clojure.tools.logging :as log]\n            [example.goodbye.routes :as goodbye-routes]\n            [example.hello.routes :as hello-routes]\n            [example.static.routes :as static-routes]\n            [example.system :as-alias system]\n            [hiccup2.core :as hiccup]\n            [reitit.ring :as reitit-ring]))\n\n(defn routes [system] ...)\n\n(defn not-found-handler [_request] ...)\n\n(defn root-handler [...] ...)\n```\n\n## `read_file` Tool Usage Tips\n\n- Use `name_pattern` with regex to match function names (e.g., \"validate.*\")\n- Use `content_pattern` to find code containing specific text (e.g., \"try|catch\")\n- For defmethod forms: Include the dispatch value (e.g., \"area :rectangle\" or \"dispatch-with-vector \\[:feet :inches\\]\")\n- For namespaced methods: Include namespace (e.g., \"tool-system/validate-inputs :clojure-eval\")\n- For spec forms: Pattern match on keywords (e.g., \"::user\" or \":domain/user\")\n- Reader conditionals display with platform syntax: #?(:clj ...)\n- Set `collapsed: false` to view the entire file\n"}],"isError":false}}
{"jsonrpc":"2.0","id":35,"result":{"content":[{"type":"text","text":"### /Users/stepbeek/HappyValley/wick/src/example/routes.clj\n```clj\n(ns example.routes\n  (:require [clojure.tools.logging :as log]\n            [example.goodbye.routes :as goodbye-routes]\n            [example.hello.routes :as hello-routes]\n            [example.static.routes :as static-routes]\n            [example.system :as-alias system]\n            [hiccup2.core :as hiccup]\n            [reitit.ring :as reitit-ring]))\n\n(defn routes\n  [system]\n  [\"\"\n   (static-routes/routes system)\n   (hello-routes/routes system)\n   (goodbye-routes/routes system)\n   [[\"/assets/*\" (reitit-ring/create-resource-handler)]]])\n\n(comment\n  (require '[clojure.java.io :as io])\n  (io/resource \"assets/js/main.js\"))\n\n(defn not-found-handler\n  [_request]\n  {:status 404\n   :headers {\"Content-Type\" \"text/html\"}\n   :body (str\n          (hiccup/html\n           [:html\n            [:body\n             [:h1 \"Not Found\"]]]))})\n\n(defn root-handler\n  ([system request]\n   ((root-handler system) request))\n  ([system]\n   (let [handler (reitit-ring/ring-handler\n                  (reitit-ring/router\n                   (routes system))\n                  #'not-found-handler)]\n     (fn root-handler [request]\n       (log/info (str (:request-method request) \" - \" (:uri request)))\n       (handler request)))))\n\n\n\n```"}],"isError":false}}
{"jsonrpc":"2.0","id":36,"result":{"content":[{"type":"text","text":"# THIS IS A COLLAPSED VIEW /Users/stepbeek/HappyValley/wick/src/example/hello/routes.clj\nSet `collapsed: false` to view the entire file\n*** `/Users/stepbeek/HappyValley/wick/src/example/hello/routes.clj`\n```clojure\n(ns example.hello.routes\n  (:require [example.page-html.core :as page-html]\n            [example.system :as-alias system]\n            [hiccup2.core :as hiccup]\n            [next.jdbc :as jdbc]))\n\n(defn hello-handler [{::system/keys [db]} _request] ...)\n\n(def desired ...)\n\n(defn routes [system] ...)\n```\n\n## `read_file` Tool Usage Tips\n\n- Use `name_pattern` with regex to match function names (e.g., \"validate.*\")\n- Use `content_pattern` to find code containing specific text (e.g., \"try|catch\")\n- For defmethod forms: Include the dispatch value (e.g., \"area :rectangle\" or \"dispatch-with-vector \\[:feet :inches\\]\")\n- For namespaced methods: Include namespace (e.g., \"tool-system/validate-inputs :clojure-eval\")\n- For spec forms: Pattern match on keywords (e.g., \"::user\" or \":domain/user\")\n- Reader conditionals display with platform syntax: #?(:clj ...)\n- Set `collapsed: false` to view the entire file\n"}],"isError":false}}
{"jsonrpc":"2.0","id":37,"result":{"content":[{"type":"text","text":"# THIS IS A COLLAPSED VIEW /Users/stepbeek/HappyValley/wick/src/example/hello/routes.clj\nSet `collapsed: false` to view the entire file\nMatching name_pattern: \"routes\" (2 expanded, 2 collapsed)\n*** `/Users/stepbeek/HappyValley/wick/src/example/hello/routes.clj`\n```clojure\n(ns example.hello.routes\n  (:require [example.page-html.core :as page-html]\n            [example.system :as-alias system]\n            [hiccup2.core :as hiccup]\n            [next.jdbc :as jdbc]))\n\n(defn hello-handler [{::system/keys [db]} _request] ...)\n\n(def desired ...)\n\n(defn routes\n  [system]\n  [[\"/\" {:get {:handler (partial #'hello-handler system)}}]])\n```\n\n## `read_file` Tool Usage Tips\n\n- Use `name_pattern` with regex to match function names (e.g., \"validate.*\")\n- Use `content_pattern` to find code containing specific text (e.g., \"try|catch\")\n- For defmethod forms: Include the dispatch value (e.g., \"area :rectangle\" or \"dispatch-with-vector \\[:feet :inches\\]\")\n- For namespaced methods: Include namespace (e.g., \"tool-system/validate-inputs :clojure-eval\")\n- For spec forms: Pattern match on keywords (e.g., \"::user\" or \":domain/user\")\n- Reader conditionals display with platform syntax: #?(:clj ...)\n- Set `collapsed: false` to view the entire file\n"}],"isError":false}}
{"jsonrpc":"2.0","id":38,"result":{"content":[{"type":"text","text":"# THIS IS A COLLAPSED VIEW /Users/stepbeek/HappyValley/wick/src/example/goodbye/routes.clj\nSet `collapsed: false` to view the entire file\nMatching name_pattern: \"routes\" (2 expanded, 1 collapsed)\n*** `/Users/stepbeek/HappyValley/wick/src/example/goodbye/routes.clj`\n```clojure\n(ns example.goodbye.routes\n  (:require [example.page-html.core :as page-html]\n            [hiccup2.core :as hiccup]))\n\n(defn goodbye-handler [_system _request] ...)\n\n(defn routes\n  [system]\n  [[\"/goodbye\" {:get {:handler (partial #'goodbye-handler system)}}]])\n```\n\n## `read_file` Tool Usage Tips\n\n- Use `name_pattern` with regex to match function names (e.g., \"validate.*\")\n- Use `content_pattern` to find code containing specific text (e.g., \"try|catch\")\n- For defmethod forms: Include the dispatch value (e.g., \"area :rectangle\" or \"dispatch-with-vector \\[:feet :inches\\]\")\n- For namespaced methods: Include namespace (e.g., \"tool-system/validate-inputs :clojure-eval\")\n- For spec forms: Pattern match on keywords (e.g., \"::user\" or \":domain/user\")\n- Reader conditionals display with platform syntax: #?(:clj ...)\n- Set `collapsed: false` to view the entire file\n"}],"isError":false}}
{"jsonrpc":"2.0","id":39,"result":{"content":[{"type":"text","text":"# THIS IS A COLLAPSED VIEW /Users/stepbeek/HappyValley/wick/src/example/routes.clj\nSet `collapsed: false` to view the entire file\nMatching name_pattern: \"not-found-handler\" (1 expanded, 3 collapsed)\n*** `/Users/stepbeek/HappyValley/wick/src/example/routes.clj`\n```clojure\n(ns example.routes\n  (:require [clojure.tools.logging :as log]\n            [example.goodbye.routes :as goodbye-routes]\n            [example.hello.routes :as hello-routes]\n            [example.static.routes :as static-routes]\n            [example.system :as-alias system]\n            [hiccup2.core :as hiccup]\n            [reitit.ring :as reitit-ring]))\n\n(defn routes [system] ...)\n\n(defn not-found-handler\n  [_request]\n  {:status 404\n   :headers {\"Content-Type\" \"text/html\"}\n   :body (str\n          (hiccup/html\n           [:html\n            [:body\n             [:h1 \"Not Found\"]]]))})\n\n(defn root-handler [...] ...)\n```\n\n## `read_file` Tool Usage Tips\n\n- Use `name_pattern` with regex to match function names (e.g., \"validate.*\")\n- Use `content_pattern` to find code containing specific text (e.g., \"try|catch\")\n- For defmethod forms: Include the dispatch value (e.g., \"area :rectangle\" or \"dispatch-with-vector \\[:feet :inches\\]\")\n- For namespaced methods: Include namespace (e.g., \"tool-system/validate-inputs :clojure-eval\")\n- For spec forms: Pattern match on keywords (e.g., \"::user\" or \":domain/user\")\n- Reader conditionals display with platform syntax: #?(:clj ...)\n- Set `collapsed: false` to view the entire file\n"}],"isError":false}}
{"jsonrpc":"2.0","id":40,"result":{"content":[{"type":"text","text":"# THIS IS A COLLAPSED VIEW /Users/stepbeek/HappyValley/wick/src/example/page_html/core.clj\nSet `collapsed: false` to view the entire file\n*** `/Users/stepbeek/HappyValley/wick/src/example/page_html/core.clj`\n```clojure\n(ns example.page-html.core\n  (:require [clojure.walk :as w]\n            [hiccup.util :as hiccup-util]\n            [hiccup2.core :as hiccup]))\n\n(defn view [& {:keys [body title]\n               :or {title \"The Website\"}}] ...)\n\n(defn transform-controller [attr-map] ...)\n\n(defn transform-target [attr-map] ...)\n\n(defn transform-action [attr-map] ...)\n\n(defn transform-attributes [attr-map] ...)\n\n(defn transform-stimulus [template] ...)\n\n(defn s-> [event controller function] ...)\n\n(defn render [template] ...)\n```\n\n## `read_file` Tool Usage Tips\n\n- Use `name_pattern` with regex to match function names (e.g., \"validate.*\")\n- Use `content_pattern` to find code containing specific text (e.g., \"try|catch\")\n- For defmethod forms: Include the dispatch value (e.g., \"area :rectangle\" or \"dispatch-with-vector \\[:feet :inches\\]\")\n- For namespaced methods: Include namespace (e.g., \"tool-system/validate-inputs :clojure-eval\")\n- For spec forms: Pattern match on keywords (e.g., \"::user\" or \":domain/user\")\n- Reader conditionals display with platform syntax: #?(:clj ...)\n- Set `collapsed: false` to view the entire file\n"}],"isError":false}}
{"jsonrpc":"2.0","id":41,"result":{"content":[{"type":"text","text":"# THIS IS A COLLAPSED VIEW /Users/stepbeek/HappyValley/wick/src/example/page_html/core.clj\nSet `collapsed: false` to view the entire file\nMatching name_pattern: \"view\" (1 expanded, 8 collapsed)\n*** `/Users/stepbeek/HappyValley/wick/src/example/page_html/core.clj`\n```clojure\n(ns example.page-html.core\n  (:require [clojure.walk :as w]\n            [hiccup.util :as hiccup-util]\n            [hiccup2.core :as hiccup]))\n\n(defn view [& {:keys [body title]\n               :or {title \"The Website\"}}]\n  [:html\n   [:head\n    [:title title]\n    [:meta {:name \"viewport\"\n            :content \"width=device-width, initial-scale=1.0\"}]\n\n    [:script {:src \"/assets/js/main.js\"}]\n    [:link {:href \"assets/css/main.css\" :rel \"stylesheet\"}]]\n   [:body\n    body]])\n\n(defn transform-controller [attr-map] ...)\n\n(defn transform-target [attr-map] ...)\n\n(defn transform-action [attr-map] ...)\n\n(defn transform-attributes [attr-map] ...)\n\n(defn transform-stimulus [template] ...)\n\n(defn s-> [event controller function] ...)\n\n(defn render [template] ...)\n```\n\n## `read_file` Tool Usage Tips\n\n- Use `name_pattern` with regex to match function names (e.g., \"validate.*\")\n- Use `content_pattern` to find code containing specific text (e.g., \"try|catch\")\n- For defmethod forms: Include the dispatch value (e.g., \"area :rectangle\" or \"dispatch-with-vector \\[:feet :inches\\]\")\n- For namespaced methods: Include namespace (e.g., \"tool-system/validate-inputs :clojure-eval\")\n- For spec forms: Pattern match on keywords (e.g., \"::user\" or \":domain/user\")\n- Reader conditionals display with platform syntax: #?(:clj ...)\n- Set `collapsed: false` to view the entire file\n"}],"isError":false}}
{"jsonrpc":"2.0","id":42,"result":{"content":[{"type":"text","text":"--- original.txt\n+++ revised.txt\n@@ -20,14 +20,35 @@\n   (io/resource \"assets/js/main.js\"))\n \n (defn not-found-handler\n-  [_request]\n+  [request]\n   {:status 404\n    :headers {\"Content-Type\" \"text/html\"}\n    :body (str\n           (hiccup/html\n            [:html\n+            [:head\n+             [:title \"Page Not Found - Wick\"]\n+             [:meta {:name \"viewport\"\n+                     :content \"width=device-width, initial-scale=1.0\"}]\n+             [:script {:src \"/assets/js/main.js\"}]\n+             [:link {:href \"/assets/css/main.css\" :rel \"stylesheet\"}]]\n             [:body\n-             [:h1 \"Not Found\"]]]))})\n+             [:div {:class \"min-h-screen bg-gradient-to-br from-blue-500 via-purple-500 to-pink-500 flex items-center justify-center p-6\"}\n+              [:div {:class \"max-w-md w-full bg-white/10 backdrop-blur-lg rounded-2xl shadow-2xl p-8 text-center text-white\"}\n+               [:div {:class \"mb-6\"}\n+                [:h1 {:class \"text-6xl font-bold mb-2\"} \"404\"]\n+                [:div {:class \"text-2xl font-semibold mb-4\"} \"Page Not Found\"]]\n+               [:div {:class \"mb-8\"}\n+                [:p {:class \"text-lg mb-2\"} \"Oops! The page you're looking for doesn't exist.\"]\n+                [:p {:class \"text-sm opacity-80\"}\n+                 \"The URL \" [:code {:class \"bg-white/20 px-2 py-1 rounded text-xs\"} (:uri request)] \" could not be found on this server.\"]]\n+               [:div {:class \"space-y-4\"}\n+                [:button {:onclick \"window.history.back()\"\n+                          :class \"w-full bg-white/20 hover:bg-white/30 transition-all duration-200 px-6 py-3 rounded-lg font-semibold text-white border border-white/30 hover:border-white/50\"}\n+                 \"← Go Back\"]\n+                [:a {:href \"/\"\n+                     :class \"block w-full bg-blue-600 hover:bg-blue-700 transition-all duration-200 px-6 py-3 rounded-lg font-semibold text-white\"}\n+                 \"🏠 Return Home\"]]]]]]))})\n \n (defn root-handler\n   ([system request]"}],"isError":false}}
{"jsonrpc":"2.0","id":43,"result":{"content":[{"type":"text","text":"Exit code: 1"}],"isError":false}}
{"jsonrpc":"2.0","id":44,"result":{"content":[{"type":"text","text":"Exit code: 0"}],"isError":false}}
{"jsonrpc":"2.0","id":45,"result":{"tools":[{"name":"LS","description":"Returns a recursive tree view of files and directories starting from the specified path. The path parameter must be an absolute path, not a relative path. You should generally prefer the `glob_files` and `fx_grep` tools, if you know which directories to search.","inputSchema":{"type":"object","properties":{"path":{"type":"string"},"max_depth":{"type":"integer","description":"Maximum depth to traverse (optional)"},"limit":{"type":"integer","description":"Maximum number of entries to show (default: 100)"}},"required":["path"]}},{"name":"read_file","description":"Smart file reader with pattern-based exploration for Clojure files.\n   \nFor Clojure files (.clj, .cljc, .cljs, .bb):\n\nThis tool defaults to an expandable collapsed view to quickly grab the information you need from a Clojure file.\nIf called without `name_pattern` or `content_pattern` it will return the file content where \nyou will see only function signatures. This gives you a quick overview of the file.\n\nWhen you want to see more, this tool has a grep functionality where you\ncan give patterns to match the names for top level definitions\n`name_pattern` or match the bodies of top level definitions `content_pattern`.\n\nThe functions that match these patterns will be the only functions expanded in collapsed view.\n\nFor defmethod forms:\n- The name includes both the method name and the dispatch value (e.g., \"area :rectangle\")\n- For vector dispatch values, use the exact pattern (e.g., \"dispatch-with-vector \\[:feet :inches\\]\")\n- For qualified/namespaced multimethod names, include the namespace (e.g., \"tool-system/validate-inputs :clojure-eval\")\n\nFor text files (non-Clojure):\n- When `collapsed: true` and a pattern is provided (`content_pattern` or `name_pattern`), shows only lines matching the pattern with 10 lines of context before and after\n\nFor all other file types:\n- Collapsed view will not be applied and will return the raw contents of the file\n\nParameters:\n- path: Path to the file (required)\n- collapsed: Show collapsed view (default: true)\n\nCollapsed View mode function expansion parameters:\n\n- name_pattern: Regex to match function names (e.g., \"validate.*\")\n- content_pattern: Regex to match function content (e.g., \"try|catch\")\n\nExample usage for defmethod forms:\n- Find all implementations of a multimethod: `name_pattern: \"area\"`\n- Find specific dispatch values: `name_pattern: \"area :circle\"`\n- Find vector dispatch values: `name_pattern: \"convert-length \\\\[:feet :inches\\\\]\"`\n- Find namespace-qualified methods: `name_pattern: \"tool-system/validate-inputs\"`\n\nExample usage for text files:\n- Find error messages: `content_pattern: \"ERROR|WARN\"`\n- Find specific log entries: `content_pattern: \"\\\\[2024-01-15.*ERROR\\\\]\"`\n\nNon collapsed view mode respects these parameters:\n\n- line_offset: Line to start reading from (non-collapsed mode only, default: 0)\n- limit: Maximum lines to read (non-collapsed mode only, default: 2000)\n\nBy default, reads up to 2000 lines, truncating lines longer than 1000 characters.","inputSchema":{"type":"object","properties":{"path":{"type":"string","description":"Path to the file to read"},"collapsed":{"type":"boolean","description":"Whether to show collapsed view for Clojure files (default: true)"},"name_pattern":{"type":"string","description":"Pattern to match function names (e.g., \"validate.*\")"},"content_pattern":{"type":"string","description":"Pattern to match function content (e.g., \"try|catch\")"},"line_offset":{"type":"integer","description":"Line to start reading from for raw mode (default: 0)"},"limit":{"type":"integer","description":"Maximum lines to read (default: 2000)"}},"required":["path"]}},{"name":"grep","description":"Fast content search tool that works with any codebase size.\n- Finds the paths to files that have matching contents using regular expressions.\n- Supports full regex syntax (eg. \"log.*Error\", \"function\\s+\\w+\", etc.).\n- Filter files by pattern with the include parameter (eg. \"*.js\", \"*.{ts,tsx}\").\n- Returns matching file paths sorted by modification time.\n- Use this tool when you need to find files containing specific patterns.\n- When you are doing an open ended search that may require multiple rounds of globbing and grepping, use the `dispatch_agent` tool instead","inputSchema":{"type":"object","properties":{"path":{"type":"string","description":"The directory to search in. Defaults to the current working directory."},"pattern":{"type":"string","description":"The regular expression pattern to search for in file contents"},"include":{"type":"string","description":"File pattern to include in the search (e.g. \"*.clj\", \"*.{clj,cljs}\")"},"max_results":{"type":"integer","description":"Maximum number of results to return (default: 1000)"}},"required":["pattern"]}},{"name":"glob_files","description":"Fast file pattern matching tool that works with any codebase size.\n - Supports glob patterns like \"**/*.clj\" or \"src/**/*.cljs\".\n - Returns matching file paths sorted by modification time (most recent first).\n - Use this tool when you need to find files by name patterns.\n - When you are doing an open ended search that may require multiple rounds of globbing and grepping, use the `dispatch_agent` tool instead","inputSchema":{"type":"object","properties":{"path":{"type":"string","description":"Root directory to start the search from (defaults to current working directory)"},"pattern":{"type":"string","description":"Glob pattern (e.g. \"**/*.clj\", \"src/**/*.tsx\")"},"max_results":{"type":"integer","description":"Maximum number of results to return (default: 1000)"}},"required":["pattern"]}},{"name":"think","description":"Use the tool to think about something. It will not obtain new information or make any changes to the repository, but just log the thought. Use it when complex reasoning or brainstorming is needed. \nCommon use cases:\n* when having difficulty finding/reading the files you need\n* when having difficulty writing out code\n* when having difficulty using the tools or the clojure tools\n* When exploring a repository and discovering the source of a bug, call this tool to brainstorm several unique ways of fixing the bug, and assess which change(s) are likely to be simplest and most effective.\n* After receiving test results, use this tool to brainstorm ways to fix failing tests.\n* When planning a complex refactoring, use this tool to outline different approaches and their tradeoffs.\n* When designing a new feature, use this tool to think through architecture decisions and implementation details.\n* When debugging a complex issue, use this tool to organize your thoughts and hypotheses.\nThe tool simply logs your thought process for better transparency and does not execute any code or make changes.","inputSchema":{"type":"object","properties":{"thought":{"type":"string","description":"The thought to log"}},"required":["thought"]}},{"name":"scratch_pad","description":"A persistent scratch pad for storing structured data between tool calls. Accepts any JSON value (objects, arrays, strings, numbers, booleans, null) and stores them at nested paths using set_path, get_path, delete_path operations.\n\nTHIS IS YOUR GO-TO TOOL FOR PLANNING.\n\nYour persistent workspace for planning, organizing thoughts, and maintaining state across tool invocations.\n\nThis tool can be used to:\n * develop and track multi-step plans\n * maintain task lists and task tracking\n * store intermediate results between operations\n * keep notes about your current approach or strategy\n * maintain a list of files or resources to process\n * build up complex data structures incrementally\n * share context between different tool calls\n * any other persistent storage needs during your work\n\nThe scratch pad is for persistent storage and state management, not for formatting output. Display information directly in your chat responses. However, when the scratch pad contains user-relevant state (like tasks lists or tracked progress), you should retrieve and display updates after modifications.\n\nUse the scratch pad when you need to:\n- Track progress across multiple tool calls\n- Build data structures incrementally  \n- Maintain state between operations\n- Store intermediate results for later use\n\nDon't use the scratch pad to:\n- Format text for display\n- Store static information just to retrieve and show it\n- Replace direct chat responses\n\nCORE OPERATIONS:\n- set_path: Store a value (not null) at a path, returns the parent container\n- get_path: Retrieve a value from a path, returns the value or nil\n- delete_path: Remove only the leaf value from a path, returns a confirmation message\n- inspect: Display the entire structure (or a specific path) with truncation at specified depth\n\nWARNING: null values can not be stored in the scratch pad, if you attempt to store a null value the set_path will fail.\n\nTRACKING PLANS WITH TASK LISTS:\n\nRecommended schema for a Task:\n{\n  task: \"Description of the task\",\n  done: false,\n  priority: \"high\", // optional: \"high\", \"medium\", \"low\"\n  context: \"Additional details\", // optional\n  subtasks: [  // optional: array of subtask objects\n    {task: \"Subtask 1\", done: false},\n    {task: \"Subtask 2\", done: true}\n  ]\n}\n\nFirst add multiple tasks items at once as an array:\n- Entire array:\n  op: set_path\n  path: [\"tasks\"]\n  value: [\n    {task: \"Write tests\", done: false, priority: \"high\"},\n    {task: \"Review PR\", done: false, priority: \"high\"},\n    {task: \"Update docs\", done: false, priority: \"medium\", subtasks: [\n      {task: \"Update API docs\", done: false},\n      {task: \"Update README\", done: false}\n    ]}\n  ]\n  explanation: Adding multiple tasks at once\n\nAdding tasks items:\n- First item:\n  op: set_path\n  path: [\"tasks\", 3]\n  value: {task: \"Run tests\", done: false}\n  explanation: Adding write tests task\n\n- Next item:\n  op: set_path\n  path: [\"tasks\", 4]\n  value: {task: \"Notify user\", done: false, priority: \"high\"}\n  explanation: Adding high priority task\n\nChecking off completed tasks:\n- Mark as done:\n  op: set_path\n  path: [\"tasks\", 0, \"done\"]\n  value: true\n  explanation: Completed writing tests\n\n- Mark subtask as done:\n  op: set_path\n  path: [\"tasks\", 2, \"subtasks\", 0, \"done\"]\n  value: true\n  explanation: Completed API docs update\n\nAdding a new task to the array:\n- Append to array:\n  op: set_path\n  path: [\"tasks\", 3]\n  value: {task: \"Deploy to production\", done: false, priority: \"high\"}\n  explanation: Adding deployment task\n\nViewing tasks:\n- All tasks:\n  op: get_path\n  path: [\"tasks\"]\n  explanation: Get all tasks\n\n- Specific task:\n  op: get_path\n  path: [\"tasks\", 0]\n  explanation: Checking first task details\n\n- View with depth limit:\n  op: inspect\n  path: [\"tasks\"]\n  depth: 2\n  explanation: View tasks with limited nesting","inputSchema":{"type":"object","properties":{"op":{"type":"string","enum":["set_path","get_path","delete_path","inspect"],"description":"The operation to perform:\n * set_path: set a value at a path\n * get_path: retrieve a value at a path\n * delete_path: remove the value at the path from the data structure\n * inspect: view the datastructure (or a specific path within it) up to a certain depth\n"},"path":{"type":"array","items":{"type":"string"},"description":"Path to the data location (array of string or number keys) - used for set_path, get_path, delete_path, and optionally inspect"},"value":{"description":"Value to store (for set_path). Can be ANY JSON value EXCEPT null: object, array, string, number, boolean.","type":"object"},"explanation":{"type":"string","description":"Explanation of why this operation is being performed"},"depth":{"type":"number","description":"(Optional) For inspect operation: Maximum depth to display (default: 5). Must be a positive integer."}},"required":["op","explanation"]}},{"name":"clojure_eval","description":"Takes a Clojure Expression and evaluates it in the current namespace. For example, providing \"(+ 1 2)\" will evaluate to 3.\n\nThis tool is intended to execute Clojure code. This is very helpful for verifying that code is working as expected. It's also helpful for REPL driven development.\n\nIf you send multiple expressions they will all be evaluated individually and their output will be clearly partitioned.\n\nIf the returned value is too long it will be truncated.\n\nIMPORTANT: When using `require` to reload namespaces ALWAYS use `:reload` to ensure you get the latest version of files.\n\nREPL helper functions are automatically loaded in the 'clj-mcp.repl-tools' namespace, providing convenient namespace and symbol exploration:\n\nNamespace/Symbol inspection functions:\n  clj-mcp.repl-tools/list-ns           - List all available namespaces\n  clj-mcp.repl-tools/list-vars         - List all vars in namespace\n  clj-mcp.repl-tools/doc-symbol        - Show documentation for symbol\n  clj-mcp.repl-tools/source-symbol     - Show source code for symbol\n  clj-mcp.repl-tools/find-symbols      - Find symbols matching pattern\n  clj-mcp.repl-tools/complete          - Find completions for prefix\n  clj-mcp.repl-tools/help              - Show this help message\n\nExamples:\n  (clj-mcp.repl-tools/list-ns)                     ; List all namespaces\n  (clj-mcp.repl-tools/list-vars 'clojure.string)   ; List functions in clojure.string\n  (clj-mcp.repl-tools/doc-symbol 'map)             ; Show documentation for map\n  (clj-mcp.repl-tools/source-symbol 'map)          ; Show source code for map\n  (clj-mcp.repl-tools/find-symbols \"seq\")          ; Find symbols containing \"seq\"\n  (clj-mcp.repl-tools/complete \"clojure.string/j\") ; Find completions for prefix","inputSchema":{"type":"object","properties":{"code":{"type":"string","description":"The Clojure code to evaluate."}},"required":["code"]}},{"name":"bash","description":"Execute bash shell commands on the host system.\n\nExamples:\n1. List files: bash(command: \"ls -la\")\n2. Find text in files: bash(command: \"grep -r 'pattern' /path/to/search\")\n3. With working directory: bash(command: \"ls -la\", working_directory: \"/tmp\")\n4. With timeout: bash(command: \"sleep 10\", timeout_ms: 5000)\n5. Git commands \n\nFor long running processes like running tests increase the timeout_ms so that the process can complete.\n\nNote: Non-zero exit codes are NOT treated as tool errors - check exit_code\nin the response to determine command success.","inputSchema":{"type":"object","properties":{"command":{"type":"string","description":"The shell command to execute"},"working_directory":{"type":"string","description":"Directory to run the command in (optional)"},"timeout_ms":{"type":"integer","description":"Maximum execution time in milliseconds (optional, default: 30000)"}},"required":["command"]}},{"name":"clojure_edit","description":"Edits a top-level form (`defn`, `def`, `defmethod`, `ns`, `deftest`) in a Clojure file using the specified operation.\n   \nPREFER this unified tool over generic file editing tools for Clojure files (`.clj` `.cljs` `.cljc` `.bb`)\n\nThis tool MAKES it EASIER to match a definition that exists in the file AS you only have to match the type of definition `form_type` and the complete identifier `form_identifier` of the definition. This prevents the repeated mismatch errors that occur when trying match an entire string of text for replacement.\nThis tool validates the structure of the Clojure code that is being inserted into the file and will provide linting feedback for things such as parenthetical errors.\nThis tool reduces the number of tokens that need to be generated.\n \nWARNING: you will receive errors if the syntax is wrong, the most common error is an extra or missing parenthesis in the `content`, so be careful with parenthesis.\n\n   Operations:\n   - \"replace\": Replaces the form with new content\n   - \"insert_before\": Inserts content before the form\n   - \"insert_after\": Inserts content after the form\n   \n   The form is identified by its type (defn, def, deftest, s/def, ns, defmethod etc.) and complete identifier.\n   \n   Example: Replace a function definition:\n   - file_path: \"/path/to/file.clj\"\n   - form_identifier: \"example-fn\"\n   - form_type: \"defn\"\n   - operation: \"replace\"\n   - content: \"(defn example-fn [x] (* x 2))\"\n   \n   Example: Insert a helper function before a function:\n   - file_path: \"/path/to/file.clj\"\n   - form_identifier: \"example-fn\"\n   - form_type: \"defn\"\n   - operation: \"insert_before\"\n   - content: \"(defn helper-fn [x] (* x 2))\"\n   \n   Example: Insert a test after a function:\n   - file_path: \"/path/to/file.clj\"\n   - form_identifier: \"example-fn\"\n   - form_type: \"defn\"\n   - operation: \"insert_after\"\n   - content: \"(deftest example-fn-test\n  (is (= 4 (example-fn 2))))\"\n   \nNote: For `defmethod` forms, be sure to include the dispatch value (`area :rectangle` or `qualified/area :rectangle`) in the `form_identifier`. Many `defmethod` definitions have qualified names (they include a namespace alias in their identifier like `shape/area`), so it's crucial to use the complete identifier that appears in the file.\n\n   Example: Replace a specific `defmethod` implementation:\n   - file_path: \"/path/to/file.clj\"\n   - form_identifier: \"shape/area :square\"\n   - form_type: \"defmethod\"\n   - operation: \"replace\"\n   - content: \"(defmethod shape/area :square [{:keys [w h]}] (* w h))\"\n\n   Example: Work with vector dispatch values:\n   - file_path: \"/path/to/file.clj\"\n   - form_identifier: \"convert-length [:feet :inches]\"\n   - form_type: \"defmethod\"\n   - operation: \"insert_before\"\n   - content: \"(def inches-per-foot 12)\"\n\n   The tool will find the form, perform the requested operation, and format the result.\n   It returns a diff showing the changes made to the file.","inputSchema":{"type":"object","properties":{"file_path":{"type":"string","description":"Path to the file containing the form to edit"},"form_identifier":{"type":"string","description":"Complete identifier of the form (e.g., function name, \"shape/area\", or \"convert-length [:feet :inches]\")"},"form_type":{"type":"string","description":"Type of the form (e.g., \"defn\", \"def\", \"ns\")"},"operation":{"type":"string","enum":["replace","insert_before","insert_after"],"description":"The editing operation to perform"},"content":{"type":"string","description":"New content to use for the operation"}},"required":["file_path","form_identifier","form_type","operation","content"]}},{"name":"clojure_edit_replace_sexp","description":"Edits a file by finding and replacing specific s-expressions.\n\nUse this tool for targeted edits of sub-expressions within forms. For complete top-level form replacements, prefer specialized tools like `clojure_edit_replace_definition` and friends.\n\nKEY BENEFITS:\n- Syntax-aware matching that understands Clojure code structure\n- Ignores whitespace differences by default, focusing on actual code meaning\n- Matches expressions regardless of formatting, indentation, or spacing\n- Prevents errors from mismatched text or irrelevant formatting differences\n- Can find and replace all occurrences with replace_all: true\n\nCONSTRAINTS:\n- match_form must contain only a SINGLE s-expression (error otherwise)\n- Requires syntactically valid Clojure expressions in both match_form and new_form\n\nWARNING: You will receive errors if the syntax is wrong. The most common error is an extra or missing parenthesis in either match_form or new_form, so count your parentheses carefully!\n\nCOMMON APPLICATIONS:\n- Renaming symbols throughout the file: {\"match_form\": \"old-name\", \"new_form\": \"new-name\", \"replace_all\": true}\n- Editing special forms like if/cond/let/when within functions:\n  * Changing if branches: {\"match_form\": \"(if condition expr1 expr2)\", \"new_form\": \"(if condition (do expr1) expr2)\"}\n  * Enhancing let bindings: {\"match_form\": \"(let [x 10] (+ x 2))\", \"new_form\": \"(let [x 10 y 20] (+ x y))\"}\n  * Converting cond to case: {\"match_form\": \"(cond (= x :a) \\\"A\\\" (= x :b) \\\"B\\\")\", \"new_form\": \"(case x :a \\\"A\\\" :b \\\"B\\\")\"}\n- Modifying nested function calls: {\"match_form\": \"(str (+ a b))\", \"new_form\": \"(str (+ a b c))\"}\n- Changing anonymous function syntax: {\"match_form\": \"#(update % :count inc)\", \"new_form\": \"(fn [x] (update x :count inc))\"}\n\nOther Examples:\n- Replace a calculation: {\"match_form\": \"(+ x 2)\", \"new_form\": \"(+ x 10)\"}\n  * Will match regardless of spaces: (+ x 2), (+   x   2), etc.\n- Delete an expression: {\"match_form\": \"(println debug-info)\", \"new_form\": \"\"}\n- Edit anonymous function: {\"match_form\": \"#(inc %)\", \"new_form\": \"#(+ % 2)\"}\n- Replace multiple occurrences: {\"match_form\": \"(inc x)\", \"new_form\": \"(+ x 1)\", \"replace_all\": true}\n\nReturns a diff showing the changes made to the file.","inputSchema":{"type":"object","properties":{"file_path":{"type":"string","description":"Path to the file to edit"},"match_form":{"type":"string","description":"The s-expression to find and replace (include # for anonymous functions)"},"new_form":{"type":"string","description":"The s-expression to replace with"},"replace_all":{"type":"boolean","description":"Whether to replace all occurrences (default: false)"}},"required":["file_path","match_form","new_form"]}},{"name":"file_edit","description":"Edit a file by replacing a specific text string with a new one. For safety, this tool requires that the string to replace appears exactly once in the file. \n\nFIRST: the clojure_edit tool is prefered because they use precise structural rewrite-clj editing. They also incorporate linting and ensure balance parenthesis.\n\nWHEN the clojure_edit tool won't work or you have a small easy edit \n\nPREFER the file_write tool for replacing more than half a file, this saves on tokens\n\nFor Clojure files (.clj, .cljs, .cljc, .edn):\n- Content will be linted for syntax errors before writing\n- Content will be formatted according to Clojure standards\n- Writing will fail if linting detects syntax errors\n\nTo make a file edit, provide the file_path, old_string (the text to replace), and new_string (the replacement text). The old_string must uniquely identify the specific instance you want to change, so include several lines of context before and after the change point. To create a new file, use file_write instead.","inputSchema":{"type":"object","properties":{"file_path":{"type":"string","description":"The absolute path to the file to modify (must be absolute, not relative)"},"old_string":{"type":"string","description":"The text to replace (must match the file contents exactly, including all whitespace and indentation)."},"new_string":{"type":"string","description":"The edited text to replace the old_string"}},"required":["file_path","old_string","new_string"]}},{"name":"file_write","description":"Write a file to the local filesystem. Overwrites the existing file if there is one.\n\nFor Clojure files (.clj, .cljs, .cljc, .edn):\n- Content will be linted for syntax errors before writing\n- Content will be formatted according to Clojure standards\n- Writing will fail if linting detects syntax errors\n\nFor other file types:\n- Content is written directly without linting or formatting\n\nIMPORTANT SAFETY FEATURE:\n- If the file has been modified since it was last read, writing will fail\n- You must use read_file to get the current content before editing a file\n- This prevents accidental overwrites of external changes\n\nReturns information about whether the file was created or updated, along with a diff \nshowing the changes made.\n\nBefore using this tool:\n1. Use the read_file tool to understand the file's contents and context\n2. Directory Verification (only applicable when creating new files):\n   - Use the list_directory tool to verify the parent directory exists and is the correct location\n3. For Clojure files, ensure code is syntactically correct\n\n# Example:\n# file_write(\n#   file_path: \"/absolute/path/to/file.clj\",\n#   content: \"(ns my.namespace)\\n\\n(defn my-function [x]\\n  (* x 2))\"\n# )","inputSchema":{"type":"object","properties":{"file_path":{"type":"string","description":"The absolute path to the file to write (must be absolute, not relative)"},"content":{"type":"string","description":"The content to write to the file"}},"required":["file_path","content"]}},{"name":"clojure_inspect_project","description":"Analyzes and provides detailed information about a Clojure project's structure, \nincluding dependencies, source files, namespaces, and environment details.\n\nThis tool helps you understand project organization without having to manually \nexplore multiple configuration files. It works with both deps.edn and Leiningen projects.\n\nThe tool provides information about:\n- Project environment (working directory, Clojure version, Java version)\n- Source and test paths\n- Dependencies and their versions\n- Aliases and their configurations\n- Available namespaces\n- Source file structure\n\nUse this tool to quickly get oriented in an unfamiliar Clojure codebase or to \nget a high-level overview of your current project.\n\n# Example:\nclojure_inspect_project()","inputSchema":{"type":"object","properties":{"explanation":{"type":"string","description":"Short explanation why you chose this tool"}},"required":["explanation"]}},{"name":"dispatch_agent","description":"Launch a new agent that has access to read-only tools. When you are searching for a keyword or file and are not confident that you will find the right match on the first try, use the Agent tool to perform the search for you. For example:\n\n- If you are searching for a keyword like \"config\" or \"logger\", the Agent tool is appropriate\n- If you want to read a specific file path, use the read_file or glob_files tool instead of the Agent tool, to find the match more quickly\n- If you are searching for a specific class definition like \"class Foo\", use the glob_files tool instead, to find the match more quickly\n\nUsage notes:\n1. Launch multiple agents concurrently whenever possible, to maximize performance; to do that, use a single message with multiple `agent` tool uses\n2. When the agent is done, it will return a single message back to you. The result returned by the agent is not visible to the user. To show the user the result, you should send a text message back to the user with a concise summary of the result.\n3. Each agent invocation is stateless. You will not be able to send additional messages to the agent, nor will the agent be able to communicate with you outside of its final report. Therefore, your prompt should contain a highly detailed task description for the agent to perform autonomously and you should specify exactly what information the agent should return back to you in its final and only message to you.\n4. The agent's outputs should generally be trusted","inputSchema":{"type":"object","properties":{"prompt":{"type":"string","description":"The prompt to send to the agent"}},"required":["prompt"]}},{"name":"architect","description":"Your go-to tool for any technical or coding task. Analyzes requirements and breaks them down into clear, actionable implementation steps. Use this whenever you need help planning how to implement a feature, solve a technical problem, or structure your code.","inputSchema":{"type":"object","properties":{"prompt":{"type":"string","description":"The technical request or coding task to analyze"},"context":{"type":"string","description":"Optional context from previous conversation or system state"}},"required":["prompt"]}},{"name":"code_critique","description":"Starts an interactive code review conversation that provides constructive feedback on your Clojure code.\n  \n  HOW TO USE THIS TOOL:\n  1. Submit your Clojure code for initial critique\n  2. Review the suggestions and implement improvements\n  3. Test your revised code in the REPL\n  4. Submit the updated code for additional feedback\n  5. Continue this cycle until the critique is satisfied\n  \n  This tool initiates a feedback loop where you:\n  - Receive detailed analysis of your code\n  - Implement suggested improvements\n  - Test and verify changes\n  - Get follow-up critique on your revisions\n  \n  The critique examines:\n  - Adherence to Clojure style conventions\n  - Functional programming best practices\n  - Performance optimizations\n  - Readability and maintainability improvements\n  - Idiomatic Clojure patterns\n  \n  Example conversation flow:\n  - You: Submit initial function implementation\n  - Tool: Provides feedback on style and structure\n  - You: Revise code based on suggestions and test in REPL\n  - Tool: Reviews updates and suggests further refinements\n  - Repeat until code quality goals are achieved\n  \n  Perfect for iterative learning and continuous code improvement.","inputSchema":{"type":"object","properties":{"code":{"type":"string","description":"The Clojure code to analyze and critique"},"context":{"type":"string","description":"Optional context from previous conversation or system state"}},"required":["code"]}}]}}
{"jsonrpc":"2.0","id":46,"result":{"resources":[{"uri":"custom://llm-code-style","name":"LLM_CODE_STYLE.md","description":"Guidelines for writing Clojure code for the current project hosting the REPL","mimeType":"text/markdown"},{"uri":"custom://project-summary","name":"PROJECT_SUMMARY.md","description":"A Clojure project summary document for the project hosting the REPL, this is intended to provide the LLM with important context to start.","mimeType":"text/markdown"},{"uri":"custom://claude","name":"CLAUDE.md","description":"The Claude instructions document for the current project hosting the REPL","mimeType":"text/markdown"},{"uri":"custom://readme","name":"README.md","description":"A README document for the current Clojure project hosting the REPL","mimeType":"text/markdown"},{"uri":"custom://project-info","name":"Clojure Project Info","description":"Information about the current Clojure project structure, attached REPL environment and dependencies","mimeType":"text/markdown"}]}}
{"jsonrpc":"2.0","id":47,"result":{"prompts":[{"name":"ACT/scratch_pad_load","description":"Loads a file into the scratch pad state. Returns status messages and a shallow inspect of the loaded data.","arguments":[{"name":"file_path","description":"Optional file path: default scratch_pad.edn","required":false}]},{"name":"clojure_repl_system_prompt","description":"Provides instructions and guidelines for Clojure development, including style and best practices.","arguments":[]},{"name":"create-update-project-summary","description":"Generates a prompt instructing the LLM to create a summary of a project.","arguments":[]},{"name":"chat-session-summarize","description":"Instructs the assistant to create a summary of the current chat session and store it in the scratch pad. `chat_session_key` is optional and will default to `chat_session_summary`","arguments":[{"name":"chat_session_key","description":"[Optional] key to store the session summary in","required":false}]},{"name":"ACT/scratch_pad_save_as","description":"Saves the current scratch pad state to a specified file.","arguments":[{"name":"file_path","description":"File path: relative to .clojure-mcp/ directory","required":true}]},{"name":"chat-session-resume","description":"Instructs the assistant to resume a previous chat session by loading context from the scratch pad. `chat_session_key` is optional and will default to `chat_session_summary`","arguments":[{"name":"chat_session_key","description":"[Optional] key where session summary is stored","required":false}]},{"name":"ACT/add-dir","description":"Adds a directory to the allowed-directories list, giving the LLM access to it","arguments":[{"name":"directory","description":"Directory path to add (can be relative or absolute)","required":true}]},{"name":"plan-and-execute","description":"Use the scratch pad tool to plan and execute an change","arguments":[]}]}}
{"jsonrpc":"2.0","id":48,"result":{"content":[{"type":"text","text":"=> nil"}],"isError":false}}
{"jsonrpc":"2.0","id":49,"result":{"content":[{"type":"text","text":"{\"chat_session_summary\"\n {\"task\" \"Improved 404 page design and functionality\",\n  \"completed\" true,\n  \"details\"\n  {\"original_issue\"\n   \"Basic 404 page with minimal styling and no navigation\",\n   \"solution\"\n   \"Redesigned 404 page with modern gradient styling, clear messaging, and two navigation options\",\n   \"features_added\"\n   [\"Beautiful gradient background matching homepage design\"\n    \"Clear 404 error messaging with friendly text\"\n    \"Dynamic URL display showing the missing path\"\n    \"Go Back button using browser history\"\n    \"Return Home button linking to homepage\"\n    \"Proper page title and meta tags\"\n    \"Responsive design with Tailwind CSS classes\"\n    \"Glassmorphism effect with backdrop blur\"],\n   \"testing\"\n   {\"playwright_tests_passed\" true,\n    \"go_back_button\" \"Works correctly using window.history.back()\",\n    \"return_home_button\" \"Works correctly navigating to /\",\n    \"visual_design\" \"Modern gradient design matches site branding\",\n    \"responsive\" \"Works well on different screen sizes\"},\n   \"technical_details\"\n   {\"file_modified\" \"src/example/routes.clj\",\n    \"function\" \"not-found-handler\",\n    \"styling_approach\" \"Inline Tailwind CSS classes\",\n    \"navigation_methods\" \"JavaScript history API + direct link\"}}}}\n"}],"isError":false}}
{"jsonrpc":"2.0","id":50,"result":{"content":[{"type":"text","text":"--- original.txt\n+++ revised.txt\n@@ -33,22 +33,22 @@\n              [:script {:src \"/assets/js/main.js\"}]\n              [:link {:href \"/assets/css/main.css\" :rel \"stylesheet\"}]]\n             [:body\n-             [:div {:class \"min-h-screen bg-gradient-to-br from-blue-500 via-purple-500 to-pink-500 flex items-center justify-center p-6\"}\n-              [:div {:class \"max-w-md w-full bg-white/10 backdrop-blur-lg rounded-2xl shadow-2xl p-8 text-center text-white\"}\n+             [:div {:class \"min-h-screen bg-gray-50 flex items-center justify-center p-6\"}\n+              [:div {:class \"max-w-md w-full bg-white rounded-lg shadow-lg border border-gray-200 p-8 text-center\"}\n                [:div {:class \"mb-6\"}\n-                [:h1 {:class \"text-6xl font-bold mb-2\"} \"404\"]\n-                [:div {:class \"text-2xl font-semibold mb-4\"} \"Page Not Found\"]]\n-               [:div {:class \"mb-8\"}\n-                [:p {:class \"text-lg mb-2\"} \"Oops! The page you're looking for doesn't exist.\"]\n-                [:p {:class \"text-sm opacity-80\"}\n-                 \"The URL \" [:code {:class \"bg-white/20 px-2 py-1 rounded text-xs\"} (:uri request)] \" could not be found on this server.\"]]\n-               [:div {:class \"space-y-4\"}\n+                [:h1 {:class \"text-6xl font-bold mb-2 text-gray-800\"} \"404\"]\n+                [:div {:class \"text-2xl font-semibold mb-4 text-gray-700\"} \"Page Not Found\"]]\n+               [:div {:class \"mb-8 text-gray-600\"}\n+                [:p {:class \"text-lg mb-2\"} \"The page you're looking for doesn't exist.\"]\n+                [:p {:class \"text-sm\"}\n+                 \"The URL \" [:code {:class \"bg-gray-100 px-2 py-1 rounded text-xs text-gray-800\"} (:uri request)] \" could not be found.\"]]\n+               [:div {:class \"space-y-3\"}\n                 [:button {:onclick \"window.history.back()\"\n-                          :class \"w-full bg-white/20 hover:bg-white/30 transition-all duration-200 px-6 py-3 rounded-lg font-semibold text-white border border-white/30 hover:border-white/50\"}\n+                          :class \"w-full bg-gray-100 hover:bg-gray-200 transition-colors duration-200 px-6 py-3 rounded-md font-medium text-gray-700 border border-gray-300\"}\n                  \"← Go Back\"]\n                 [:a {:href \"/\"\n-                     :class \"block w-full bg-blue-600 hover:bg-blue-700 transition-all duration-200 px-6 py-3 rounded-lg font-semibold text-white\"}\n-                 \"🏠 Return Home\"]]]]]]))})\n+                     :class \"block w-full bg-gray-800 hover:bg-gray-900 transition-colors duration-200 px-6 py-3 rounded-md font-medium text-white\"}\n+                 \"Return Home\"]]]]]]))})\n \n (defn root-handler\n   ([system request]"}],"isError":false}}
{"jsonrpc":"2.0","id":51,"result":{"content":[{"type":"text","text":"=> nil"}],"isError":false}}
{"jsonrpc":"2.0","id":52,"result":{"content":[{"type":"text","text":"{\"original_issue\"\n \"Basic 404 page with minimal styling and no navigation\",\n \"solution\"\n \"Redesigned 404 page with modern gradient styling, clear messaging, and two navigation options\",\n \"features_added\"\n [\"Beautiful gradient background matching homepage design\"\n  \"Clear 404 error messaging with friendly text\"\n  \"Dynamic URL display showing the missing path\"\n  \"Go Back button using browser history\"\n  \"Return Home button linking to homepage\"\n  \"Proper page title and meta tags\"\n  \"Responsive design with Tailwind CSS classes\"\n  \"Glassmorphism effect with backdrop blur\"],\n \"testing\"\n {\"playwright_tests_passed\" true,\n  \"go_back_button\" \"Works correctly using window.history.back()\",\n  \"return_home_button\" \"Works correctly navigating to /\",\n  \"visual_design\" \"Modern gradient design matches site branding\",\n  \"responsive\" \"Works well on different screen sizes\"},\n \"technical_details\"\n {\"file_modified\" \"src/example/routes.clj\",\n  \"function\" \"not-found-handler\",\n  \"styling_approach\" \"Inline Tailwind CSS classes\",\n  \"navigation_methods\" \"JavaScript history API + direct link\"},\n \"final_design\"\n {\"design_approach\" \"Minimalist and professional\",\n  \"color_scheme\" \"Neutral grays with clean white background\",\n  \"background\" \"Light gray (bg-gray-50) instead of colorful gradient\",\n  \"card_design\" \"White card with subtle shadow and gray border\",\n  \"text_colors\" \"Dark gray headings, medium gray body text\",\n  \"buttons\"\n  {\"go_back\" \"Light gray with hover effect\",\n   \"return_home\" \"Dark gray/charcoal for primary action\"},\n  \"visual_changes_from_colorful\"\n  [\"Removed blue-purple-pink gradient background\"\n   \"Replaced glassmorphism with clean white card\"\n   \"Changed from white text to dark gray text\"\n   \"Simplified button styling\"\n   \"Removed backdrop blur effects\"\n   \"Used standard border radius instead of large rounded corners\"],\n  \"user_feedback\"\n  \"Requested less colorful design - implemented successfully\"}}\n"}],"isError":false}}
{"jsonrpc":"2.0","id":53,"result":{"tools":[{"name":"LS","description":"Returns a recursive tree view of files and directories starting from the specified path. The path parameter must be an absolute path, not a relative path. You should generally prefer the `glob_files` and `fx_grep` tools, if you know which directories to search.","inputSchema":{"type":"object","properties":{"path":{"type":"string"},"max_depth":{"type":"integer","description":"Maximum depth to traverse (optional)"},"limit":{"type":"integer","description":"Maximum number of entries to show (default: 100)"}},"required":["path"]}},{"name":"read_file","description":"Smart file reader with pattern-based exploration for Clojure files.\n   \nFor Clojure files (.clj, .cljc, .cljs, .bb):\n\nThis tool defaults to an expandable collapsed view to quickly grab the information you need from a Clojure file.\nIf called without `name_pattern` or `content_pattern` it will return the file content where \nyou will see only function signatures. This gives you a quick overview of the file.\n\nWhen you want to see more, this tool has a grep functionality where you\ncan give patterns to match the names for top level definitions\n`name_pattern` or match the bodies of top level definitions `content_pattern`.\n\nThe functions that match these patterns will be the only functions expanded in collapsed view.\n\nFor defmethod forms:\n- The name includes both the method name and the dispatch value (e.g., \"area :rectangle\")\n- For vector dispatch values, use the exact pattern (e.g., \"dispatch-with-vector \\[:feet :inches\\]\")\n- For qualified/namespaced multimethod names, include the namespace (e.g., \"tool-system/validate-inputs :clojure-eval\")\n\nFor text files (non-Clojure):\n- When `collapsed: true` and a pattern is provided (`content_pattern` or `name_pattern`), shows only lines matching the pattern with 10 lines of context before and after\n\nFor all other file types:\n- Collapsed view will not be applied and will return the raw contents of the file\n\nParameters:\n- path: Path to the file (required)\n- collapsed: Show collapsed view (default: true)\n\nCollapsed View mode function expansion parameters:\n\n- name_pattern: Regex to match function names (e.g., \"validate.*\")\n- content_pattern: Regex to match function content (e.g., \"try|catch\")\n\nExample usage for defmethod forms:\n- Find all implementations of a multimethod: `name_pattern: \"area\"`\n- Find specific dispatch values: `name_pattern: \"area :circle\"`\n- Find vector dispatch values: `name_pattern: \"convert-length \\\\[:feet :inches\\\\]\"`\n- Find namespace-qualified methods: `name_pattern: \"tool-system/validate-inputs\"`\n\nExample usage for text files:\n- Find error messages: `content_pattern: \"ERROR|WARN\"`\n- Find specific log entries: `content_pattern: \"\\\\[2024-01-15.*ERROR\\\\]\"`\n\nNon collapsed view mode respects these parameters:\n\n- line_offset: Line to start reading from (non-collapsed mode only, default: 0)\n- limit: Maximum lines to read (non-collapsed mode only, default: 2000)\n\nBy default, reads up to 2000 lines, truncating lines longer than 1000 characters.","inputSchema":{"type":"object","properties":{"path":{"type":"string","description":"Path to the file to read"},"collapsed":{"type":"boolean","description":"Whether to show collapsed view for Clojure files (default: true)"},"name_pattern":{"type":"string","description":"Pattern to match function names (e.g., \"validate.*\")"},"content_pattern":{"type":"string","description":"Pattern to match function content (e.g., \"try|catch\")"},"line_offset":{"type":"integer","description":"Line to start reading from for raw mode (default: 0)"},"limit":{"type":"integer","description":"Maximum lines to read (default: 2000)"}},"required":["path"]}},{"name":"grep","description":"Fast content search tool that works with any codebase size.\n- Finds the paths to files that have matching contents using regular expressions.\n- Supports full regex syntax (eg. \"log.*Error\", \"function\\s+\\w+\", etc.).\n- Filter files by pattern with the include parameter (eg. \"*.js\", \"*.{ts,tsx}\").\n- Returns matching file paths sorted by modification time.\n- Use this tool when you need to find files containing specific patterns.\n- When you are doing an open ended search that may require multiple rounds of globbing and grepping, use the `dispatch_agent` tool instead","inputSchema":{"type":"object","properties":{"path":{"type":"string","description":"The directory to search in. Defaults to the current working directory."},"pattern":{"type":"string","description":"The regular expression pattern to search for in file contents"},"include":{"type":"string","description":"File pattern to include in the search (e.g. \"*.clj\", \"*.{clj,cljs}\")"},"max_results":{"type":"integer","description":"Maximum number of results to return (default: 1000)"}},"required":["pattern"]}},{"name":"glob_files","description":"Fast file pattern matching tool that works with any codebase size.\n - Supports glob patterns like \"**/*.clj\" or \"src/**/*.cljs\".\n - Returns matching file paths sorted by modification time (most recent first).\n - Use this tool when you need to find files by name patterns.\n - When you are doing an open ended search that may require multiple rounds of globbing and grepping, use the `dispatch_agent` tool instead","inputSchema":{"type":"object","properties":{"path":{"type":"string","description":"Root directory to start the search from (defaults to current working directory)"},"pattern":{"type":"string","description":"Glob pattern (e.g. \"**/*.clj\", \"src/**/*.tsx\")"},"max_results":{"type":"integer","description":"Maximum number of results to return (default: 1000)"}},"required":["pattern"]}},{"name":"think","description":"Use the tool to think about something. It will not obtain new information or make any changes to the repository, but just log the thought. Use it when complex reasoning or brainstorming is needed. \nCommon use cases:\n* when having difficulty finding/reading the files you need\n* when having difficulty writing out code\n* when having difficulty using the tools or the clojure tools\n* When exploring a repository and discovering the source of a bug, call this tool to brainstorm several unique ways of fixing the bug, and assess which change(s) are likely to be simplest and most effective.\n* After receiving test results, use this tool to brainstorm ways to fix failing tests.\n* When planning a complex refactoring, use this tool to outline different approaches and their tradeoffs.\n* When designing a new feature, use this tool to think through architecture decisions and implementation details.\n* When debugging a complex issue, use this tool to organize your thoughts and hypotheses.\nThe tool simply logs your thought process for better transparency and does not execute any code or make changes.","inputSchema":{"type":"object","properties":{"thought":{"type":"string","description":"The thought to log"}},"required":["thought"]}},{"name":"scratch_pad","description":"A persistent scratch pad for storing structured data between tool calls. Accepts any JSON value (objects, arrays, strings, numbers, booleans, null) and stores them at nested paths using set_path, get_path, delete_path operations.\n\nTHIS IS YOUR GO-TO TOOL FOR PLANNING.\n\nYour persistent workspace for planning, organizing thoughts, and maintaining state across tool invocations.\n\nThis tool can be used to:\n * develop and track multi-step plans\n * maintain task lists and task tracking\n * store intermediate results between operations\n * keep notes about your current approach or strategy\n * maintain a list of files or resources to process\n * build up complex data structures incrementally\n * share context between different tool calls\n * any other persistent storage needs during your work\n\nThe scratch pad is for persistent storage and state management, not for formatting output. Display information directly in your chat responses. However, when the scratch pad contains user-relevant state (like tasks lists or tracked progress), you should retrieve and display updates after modifications.\n\nUse the scratch pad when you need to:\n- Track progress across multiple tool calls\n- Build data structures incrementally  \n- Maintain state between operations\n- Store intermediate results for later use\n\nDon't use the scratch pad to:\n- Format text for display\n- Store static information just to retrieve and show it\n- Replace direct chat responses\n\nCORE OPERATIONS:\n- set_path: Store a value (not null) at a path, returns the parent container\n- get_path: Retrieve a value from a path, returns the value or nil\n- delete_path: Remove only the leaf value from a path, returns a confirmation message\n- inspect: Display the entire structure (or a specific path) with truncation at specified depth\n\nWARNING: null values can not be stored in the scratch pad, if you attempt to store a null value the set_path will fail.\n\nTRACKING PLANS WITH TASK LISTS:\n\nRecommended schema for a Task:\n{\n  task: \"Description of the task\",\n  done: false,\n  priority: \"high\", // optional: \"high\", \"medium\", \"low\"\n  context: \"Additional details\", // optional\n  subtasks: [  // optional: array of subtask objects\n    {task: \"Subtask 1\", done: false},\n    {task: \"Subtask 2\", done: true}\n  ]\n}\n\nFirst add multiple tasks items at once as an array:\n- Entire array:\n  op: set_path\n  path: [\"tasks\"]\n  value: [\n    {task: \"Write tests\", done: false, priority: \"high\"},\n    {task: \"Review PR\", done: false, priority: \"high\"},\n    {task: \"Update docs\", done: false, priority: \"medium\", subtasks: [\n      {task: \"Update API docs\", done: false},\n      {task: \"Update README\", done: false}\n    ]}\n  ]\n  explanation: Adding multiple tasks at once\n\nAdding tasks items:\n- First item:\n  op: set_path\n  path: [\"tasks\", 3]\n  value: {task: \"Run tests\", done: false}\n  explanation: Adding write tests task\n\n- Next item:\n  op: set_path\n  path: [\"tasks\", 4]\n  value: {task: \"Notify user\", done: false, priority: \"high\"}\n  explanation: Adding high priority task\n\nChecking off completed tasks:\n- Mark as done:\n  op: set_path\n  path: [\"tasks\", 0, \"done\"]\n  value: true\n  explanation: Completed writing tests\n\n- Mark subtask as done:\n  op: set_path\n  path: [\"tasks\", 2, \"subtasks\", 0, \"done\"]\n  value: true\n  explanation: Completed API docs update\n\nAdding a new task to the array:\n- Append to array:\n  op: set_path\n  path: [\"tasks\", 3]\n  value: {task: \"Deploy to production\", done: false, priority: \"high\"}\n  explanation: Adding deployment task\n\nViewing tasks:\n- All tasks:\n  op: get_path\n  path: [\"tasks\"]\n  explanation: Get all tasks\n\n- Specific task:\n  op: get_path\n  path: [\"tasks\", 0]\n  explanation: Checking first task details\n\n- View with depth limit:\n  op: inspect\n  path: [\"tasks\"]\n  depth: 2\n  explanation: View tasks with limited nesting","inputSchema":{"type":"object","properties":{"op":{"type":"string","enum":["set_path","get_path","delete_path","inspect"],"description":"The operation to perform:\n * set_path: set a value at a path\n * get_path: retrieve a value at a path\n * delete_path: remove the value at the path from the data structure\n * inspect: view the datastructure (or a specific path within it) up to a certain depth\n"},"path":{"type":"array","items":{"type":"string"},"description":"Path to the data location (array of string or number keys) - used for set_path, get_path, delete_path, and optionally inspect"},"value":{"description":"Value to store (for set_path). Can be ANY JSON value EXCEPT null: object, array, string, number, boolean.","type":"object"},"explanation":{"type":"string","description":"Explanation of why this operation is being performed"},"depth":{"type":"number","description":"(Optional) For inspect operation: Maximum depth to display (default: 5). Must be a positive integer."}},"required":["op","explanation"]}},{"name":"clojure_eval","description":"Takes a Clojure Expression and evaluates it in the current namespace. For example, providing \"(+ 1 2)\" will evaluate to 3.\n\nThis tool is intended to execute Clojure code. This is very helpful for verifying that code is working as expected. It's also helpful for REPL driven development.\n\nIf you send multiple expressions they will all be evaluated individually and their output will be clearly partitioned.\n\nIf the returned value is too long it will be truncated.\n\nIMPORTANT: When using `require` to reload namespaces ALWAYS use `:reload` to ensure you get the latest version of files.\n\nREPL helper functions are automatically loaded in the 'clj-mcp.repl-tools' namespace, providing convenient namespace and symbol exploration:\n\nNamespace/Symbol inspection functions:\n  clj-mcp.repl-tools/list-ns           - List all available namespaces\n  clj-mcp.repl-tools/list-vars         - List all vars in namespace\n  clj-mcp.repl-tools/doc-symbol        - Show documentation for symbol\n  clj-mcp.repl-tools/source-symbol     - Show source code for symbol\n  clj-mcp.repl-tools/find-symbols      - Find symbols matching pattern\n  clj-mcp.repl-tools/complete          - Find completions for prefix\n  clj-mcp.repl-tools/help              - Show this help message\n\nExamples:\n  (clj-mcp.repl-tools/list-ns)                     ; List all namespaces\n  (clj-mcp.repl-tools/list-vars 'clojure.string)   ; List functions in clojure.string\n  (clj-mcp.repl-tools/doc-symbol 'map)             ; Show documentation for map\n  (clj-mcp.repl-tools/source-symbol 'map)          ; Show source code for map\n  (clj-mcp.repl-tools/find-symbols \"seq\")          ; Find symbols containing \"seq\"\n  (clj-mcp.repl-tools/complete \"clojure.string/j\") ; Find completions for prefix","inputSchema":{"type":"object","properties":{"code":{"type":"string","description":"The Clojure code to evaluate."}},"required":["code"]}},{"name":"bash","description":"Execute bash shell commands on the host system.\n\nExamples:\n1. List files: bash(command: \"ls -la\")\n2. Find text in files: bash(command: \"grep -r 'pattern' /path/to/search\")\n3. With working directory: bash(command: \"ls -la\", working_directory: \"/tmp\")\n4. With timeout: bash(command: \"sleep 10\", timeout_ms: 5000)\n5. Git commands \n\nFor long running processes like running tests increase the timeout_ms so that the process can complete.\n\nNote: Non-zero exit codes are NOT treated as tool errors - check exit_code\nin the response to determine command success.","inputSchema":{"type":"object","properties":{"command":{"type":"string","description":"The shell command to execute"},"working_directory":{"type":"string","description":"Directory to run the command in (optional)"},"timeout_ms":{"type":"integer","description":"Maximum execution time in milliseconds (optional, default: 30000)"}},"required":["command"]}},{"name":"clojure_edit","description":"Edits a top-level form (`defn`, `def`, `defmethod`, `ns`, `deftest`) in a Clojure file using the specified operation.\n   \nPREFER this unified tool over generic file editing tools for Clojure files (`.clj` `.cljs` `.cljc` `.bb`)\n\nThis tool MAKES it EASIER to match a definition that exists in the file AS you only have to match the type of definition `form_type` and the complete identifier `form_identifier` of the definition. This prevents the repeated mismatch errors that occur when trying match an entire string of text for replacement.\nThis tool validates the structure of the Clojure code that is being inserted into the file and will provide linting feedback for things such as parenthetical errors.\nThis tool reduces the number of tokens that need to be generated.\n \nWARNING: you will receive errors if the syntax is wrong, the most common error is an extra or missing parenthesis in the `content`, so be careful with parenthesis.\n\n   Operations:\n   - \"replace\": Replaces the form with new content\n   - \"insert_before\": Inserts content before the form\n   - \"insert_after\": Inserts content after the form\n   \n   The form is identified by its type (defn, def, deftest, s/def, ns, defmethod etc.) and complete identifier.\n   \n   Example: Replace a function definition:\n   - file_path: \"/path/to/file.clj\"\n   - form_identifier: \"example-fn\"\n   - form_type: \"defn\"\n   - operation: \"replace\"\n   - content: \"(defn example-fn [x] (* x 2))\"\n   \n   Example: Insert a helper function before a function:\n   - file_path: \"/path/to/file.clj\"\n   - form_identifier: \"example-fn\"\n   - form_type: \"defn\"\n   - operation: \"insert_before\"\n   - content: \"(defn helper-fn [x] (* x 2))\"\n   \n   Example: Insert a test after a function:\n   - file_path: \"/path/to/file.clj\"\n   - form_identifier: \"example-fn\"\n   - form_type: \"defn\"\n   - operation: \"insert_after\"\n   - content: \"(deftest example-fn-test\n  (is (= 4 (example-fn 2))))\"\n   \nNote: For `defmethod` forms, be sure to include the dispatch value (`area :rectangle` or `qualified/area :rectangle`) in the `form_identifier`. Many `defmethod` definitions have qualified names (they include a namespace alias in their identifier like `shape/area`), so it's crucial to use the complete identifier that appears in the file.\n\n   Example: Replace a specific `defmethod` implementation:\n   - file_path: \"/path/to/file.clj\"\n   - form_identifier: \"shape/area :square\"\n   - form_type: \"defmethod\"\n   - operation: \"replace\"\n   - content: \"(defmethod shape/area :square [{:keys [w h]}] (* w h))\"\n\n   Example: Work with vector dispatch values:\n   - file_path: \"/path/to/file.clj\"\n   - form_identifier: \"convert-length [:feet :inches]\"\n   - form_type: \"defmethod\"\n   - operation: \"insert_before\"\n   - content: \"(def inches-per-foot 12)\"\n\n   The tool will find the form, perform the requested operation, and format the result.\n   It returns a diff showing the changes made to the file.","inputSchema":{"type":"object","properties":{"file_path":{"type":"string","description":"Path to the file containing the form to edit"},"form_identifier":{"type":"string","description":"Complete identifier of the form (e.g., function name, \"shape/area\", or \"convert-length [:feet :inches]\")"},"form_type":{"type":"string","description":"Type of the form (e.g., \"defn\", \"def\", \"ns\")"},"operation":{"type":"string","enum":["replace","insert_before","insert_after"],"description":"The editing operation to perform"},"content":{"type":"string","description":"New content to use for the operation"}},"required":["file_path","form_identifier","form_type","operation","content"]}},{"name":"clojure_edit_replace_sexp","description":"Edits a file by finding and replacing specific s-expressions.\n\nUse this tool for targeted edits of sub-expressions within forms. For complete top-level form replacements, prefer specialized tools like `clojure_edit_replace_definition` and friends.\n\nKEY BENEFITS:\n- Syntax-aware matching that understands Clojure code structure\n- Ignores whitespace differences by default, focusing on actual code meaning\n- Matches expressions regardless of formatting, indentation, or spacing\n- Prevents errors from mismatched text or irrelevant formatting differences\n- Can find and replace all occurrences with replace_all: true\n\nCONSTRAINTS:\n- match_form must contain only a SINGLE s-expression (error otherwise)\n- Requires syntactically valid Clojure expressions in both match_form and new_form\n\nWARNING: You will receive errors if the syntax is wrong. The most common error is an extra or missing parenthesis in either match_form or new_form, so count your parentheses carefully!\n\nCOMMON APPLICATIONS:\n- Renaming symbols throughout the file: {\"match_form\": \"old-name\", \"new_form\": \"new-name\", \"replace_all\": true}\n- Editing special forms like if/cond/let/when within functions:\n  * Changing if branches: {\"match_form\": \"(if condition expr1 expr2)\", \"new_form\": \"(if condition (do expr1) expr2)\"}\n  * Enhancing let bindings: {\"match_form\": \"(let [x 10] (+ x 2))\", \"new_form\": \"(let [x 10 y 20] (+ x y))\"}\n  * Converting cond to case: {\"match_form\": \"(cond (= x :a) \\\"A\\\" (= x :b) \\\"B\\\")\", \"new_form\": \"(case x :a \\\"A\\\" :b \\\"B\\\")\"}\n- Modifying nested function calls: {\"match_form\": \"(str (+ a b))\", \"new_form\": \"(str (+ a b c))\"}\n- Changing anonymous function syntax: {\"match_form\": \"#(update % :count inc)\", \"new_form\": \"(fn [x] (update x :count inc))\"}\n\nOther Examples:\n- Replace a calculation: {\"match_form\": \"(+ x 2)\", \"new_form\": \"(+ x 10)\"}\n  * Will match regardless of spaces: (+ x 2), (+   x   2), etc.\n- Delete an expression: {\"match_form\": \"(println debug-info)\", \"new_form\": \"\"}\n- Edit anonymous function: {\"match_form\": \"#(inc %)\", \"new_form\": \"#(+ % 2)\"}\n- Replace multiple occurrences: {\"match_form\": \"(inc x)\", \"new_form\": \"(+ x 1)\", \"replace_all\": true}\n\nReturns a diff showing the changes made to the file.","inputSchema":{"type":"object","properties":{"file_path":{"type":"string","description":"Path to the file to edit"},"match_form":{"type":"string","description":"The s-expression to find and replace (include # for anonymous functions)"},"new_form":{"type":"string","description":"The s-expression to replace with"},"replace_all":{"type":"boolean","description":"Whether to replace all occurrences (default: false)"}},"required":["file_path","match_form","new_form"]}},{"name":"file_edit","description":"Edit a file by replacing a specific text string with a new one. For safety, this tool requires that the string to replace appears exactly once in the file. \n\nFIRST: the clojure_edit tool is prefered because they use precise structural rewrite-clj editing. They also incorporate linting and ensure balance parenthesis.\n\nWHEN the clojure_edit tool won't work or you have a small easy edit \n\nPREFER the file_write tool for replacing more than half a file, this saves on tokens\n\nFor Clojure files (.clj, .cljs, .cljc, .edn):\n- Content will be linted for syntax errors before writing\n- Content will be formatted according to Clojure standards\n- Writing will fail if linting detects syntax errors\n\nTo make a file edit, provide the file_path, old_string (the text to replace), and new_string (the replacement text). The old_string must uniquely identify the specific instance you want to change, so include several lines of context before and after the change point. To create a new file, use file_write instead.","inputSchema":{"type":"object","properties":{"file_path":{"type":"string","description":"The absolute path to the file to modify (must be absolute, not relative)"},"old_string":{"type":"string","description":"The text to replace (must match the file contents exactly, including all whitespace and indentation)."},"new_string":{"type":"string","description":"The edited text to replace the old_string"}},"required":["file_path","old_string","new_string"]}},{"name":"file_write","description":"Write a file to the local filesystem. Overwrites the existing file if there is one.\n\nFor Clojure files (.clj, .cljs, .cljc, .edn):\n- Content will be linted for syntax errors before writing\n- Content will be formatted according to Clojure standards\n- Writing will fail if linting detects syntax errors\n\nFor other file types:\n- Content is written directly without linting or formatting\n\nIMPORTANT SAFETY FEATURE:\n- If the file has been modified since it was last read, writing will fail\n- You must use read_file to get the current content before editing a file\n- This prevents accidental overwrites of external changes\n\nReturns information about whether the file was created or updated, along with a diff \nshowing the changes made.\n\nBefore using this tool:\n1. Use the read_file tool to understand the file's contents and context\n2. Directory Verification (only applicable when creating new files):\n   - Use the list_directory tool to verify the parent directory exists and is the correct location\n3. For Clojure files, ensure code is syntactically correct\n\n# Example:\n# file_write(\n#   file_path: \"/absolute/path/to/file.clj\",\n#   content: \"(ns my.namespace)\\n\\n(defn my-function [x]\\n  (* x 2))\"\n# )","inputSchema":{"type":"object","properties":{"file_path":{"type":"string","description":"The absolute path to the file to write (must be absolute, not relative)"},"content":{"type":"string","description":"The content to write to the file"}},"required":["file_path","content"]}},{"name":"clojure_inspect_project","description":"Analyzes and provides detailed information about a Clojure project's structure, \nincluding dependencies, source files, namespaces, and environment details.\n\nThis tool helps you understand project organization without having to manually \nexplore multiple configuration files. It works with both deps.edn and Leiningen projects.\n\nThe tool provides information about:\n- Project environment (working directory, Clojure version, Java version)\n- Source and test paths\n- Dependencies and their versions\n- Aliases and their configurations\n- Available namespaces\n- Source file structure\n\nUse this tool to quickly get oriented in an unfamiliar Clojure codebase or to \nget a high-level overview of your current project.\n\n# Example:\nclojure_inspect_project()","inputSchema":{"type":"object","properties":{"explanation":{"type":"string","description":"Short explanation why you chose this tool"}},"required":["explanation"]}},{"name":"dispatch_agent","description":"Launch a new agent that has access to read-only tools. When you are searching for a keyword or file and are not confident that you will find the right match on the first try, use the Agent tool to perform the search for you. For example:\n\n- If you are searching for a keyword like \"config\" or \"logger\", the Agent tool is appropriate\n- If you want to read a specific file path, use the read_file or glob_files tool instead of the Agent tool, to find the match more quickly\n- If you are searching for a specific class definition like \"class Foo\", use the glob_files tool instead, to find the match more quickly\n\nUsage notes:\n1. Launch multiple agents concurrently whenever possible, to maximize performance; to do that, use a single message with multiple `agent` tool uses\n2. When the agent is done, it will return a single message back to you. The result returned by the agent is not visible to the user. To show the user the result, you should send a text message back to the user with a concise summary of the result.\n3. Each agent invocation is stateless. You will not be able to send additional messages to the agent, nor will the agent be able to communicate with you outside of its final report. Therefore, your prompt should contain a highly detailed task description for the agent to perform autonomously and you should specify exactly what information the agent should return back to you in its final and only message to you.\n4. The agent's outputs should generally be trusted","inputSchema":{"type":"object","properties":{"prompt":{"type":"string","description":"The prompt to send to the agent"}},"required":["prompt"]}},{"name":"architect","description":"Your go-to tool for any technical or coding task. Analyzes requirements and breaks them down into clear, actionable implementation steps. Use this whenever you need help planning how to implement a feature, solve a technical problem, or structure your code.","inputSchema":{"type":"object","properties":{"prompt":{"type":"string","description":"The technical request or coding task to analyze"},"context":{"type":"string","description":"Optional context from previous conversation or system state"}},"required":["prompt"]}},{"name":"code_critique","description":"Starts an interactive code review conversation that provides constructive feedback on your Clojure code.\n  \n  HOW TO USE THIS TOOL:\n  1. Submit your Clojure code for initial critique\n  2. Review the suggestions and implement improvements\n  3. Test your revised code in the REPL\n  4. Submit the updated code for additional feedback\n  5. Continue this cycle until the critique is satisfied\n  \n  This tool initiates a feedback loop where you:\n  - Receive detailed analysis of your code\n  - Implement suggested improvements\n  - Test and verify changes\n  - Get follow-up critique on your revisions\n  \n  The critique examines:\n  - Adherence to Clojure style conventions\n  - Functional programming best practices\n  - Performance optimizations\n  - Readability and maintainability improvements\n  - Idiomatic Clojure patterns\n  \n  Example conversation flow:\n  - You: Submit initial function implementation\n  - Tool: Provides feedback on style and structure\n  - You: Revise code based on suggestions and test in REPL\n  - Tool: Reviews updates and suggests further refinements\n  - Repeat until code quality goals are achieved\n  \n  Perfect for iterative learning and continuous code improvement.","inputSchema":{"type":"object","properties":{"code":{"type":"string","description":"The Clojure code to analyze and critique"},"context":{"type":"string","description":"Optional context from previous conversation or system state"}},"required":["code"]}}]}}
{"jsonrpc":"2.0","id":54,"result":{"resources":[{"uri":"custom://llm-code-style","name":"LLM_CODE_STYLE.md","description":"Guidelines for writing Clojure code for the current project hosting the REPL","mimeType":"text/markdown"},{"uri":"custom://project-summary","name":"PROJECT_SUMMARY.md","description":"A Clojure project summary document for the project hosting the REPL, this is intended to provide the LLM with important context to start.","mimeType":"text/markdown"},{"uri":"custom://claude","name":"CLAUDE.md","description":"The Claude instructions document for the current project hosting the REPL","mimeType":"text/markdown"},{"uri":"custom://readme","name":"README.md","description":"A README document for the current Clojure project hosting the REPL","mimeType":"text/markdown"},{"uri":"custom://project-info","name":"Clojure Project Info","description":"Information about the current Clojure project structure, attached REPL environment and dependencies","mimeType":"text/markdown"}]}}
{"jsonrpc":"2.0","id":55,"result":{"prompts":[{"name":"ACT/scratch_pad_load","description":"Loads a file into the scratch pad state. Returns status messages and a shallow inspect of the loaded data.","arguments":[{"name":"file_path","description":"Optional file path: default scratch_pad.edn","required":false}]},{"name":"clojure_repl_system_prompt","description":"Provides instructions and guidelines for Clojure development, including style and best practices.","arguments":[]},{"name":"create-update-project-summary","description":"Generates a prompt instructing the LLM to create a summary of a project.","arguments":[]},{"name":"chat-session-summarize","description":"Instructs the assistant to create a summary of the current chat session and store it in the scratch pad. `chat_session_key` is optional and will default to `chat_session_summary`","arguments":[{"name":"chat_session_key","description":"[Optional] key to store the session summary in","required":false}]},{"name":"ACT/scratch_pad_save_as","description":"Saves the current scratch pad state to a specified file.","arguments":[{"name":"file_path","description":"File path: relative to .clojure-mcp/ directory","required":true}]},{"name":"chat-session-resume","description":"Instructs the assistant to resume a previous chat session by loading context from the scratch pad. `chat_session_key` is optional and will default to `chat_session_summary`","arguments":[{"name":"chat_session_key","description":"[Optional] key where session summary is stored","required":false}]},{"name":"ACT/add-dir","description":"Adds a directory to the allowed-directories list, giving the LLM access to it","arguments":[{"name":"directory","description":"Directory path to add (can be relative or absolute)","required":true}]},{"name":"plan-and-execute","description":"Use the scratch pad tool to plan and execute an change","arguments":[]}]}}
{"jsonrpc":"2.0","id":56,"result":{"content":[{"type":"text","text":"### /Users/stepbeek/HappyValley/wick/src/example/hello/routes.clj\n```clj\n(ns example.hello.routes\n  (:require [example.page-html.core :as page-html]\n            [example.system :as-alias system]\n            [hiccup2.core :as hiccup]\n            [next.jdbc :as jdbc]))\n\n(defn hello-handler\n  [{::system/keys [db]} _request]\n  (let [{:keys [planet]} (jdbc/execute-one!\n                          db\n                          [\"SELECT 'earth' as planet\"])]\n    {:status 200\n     :headers {\"Content-Type\" \"text/html\"}\n     :body\n     (page-html/render\n      (page-html/view\n       {:title \"Wick - Modern Clojure Web App\"\n        :body\n        [:div.max-w-4xl.mx-auto.p-8\n         [:header.text-center.mb-12\n          [:h1.text-5xl.font-bold.text-gray-800.mb-4 \"Welcome to Wick\"]\n          [:p.text-xl.text-gray-600 \"A modern full-stack Clojure web application\"]]\n\n         [:section.grid.md:grid-cols-2.gap-8.mb-12\n          [:div.bg-white.p-6.rounded-lg.shadow-md\n           [:h2.text-2xl.font-semibold.text-gray-800.mb-3 \"🚀 Tech Stack\"]\n           [:ul.space-y-2.text-gray-600\n            [:li \"• Ring & Reitit for HTTP routing\"]\n            [:li \"• PostgreSQL with HikariCP pooling\"]\n            [:li \"• ClojureScript + Stimulus frontend\"]\n            [:li \"• Proletarian background jobs\"]\n            [:li \"• Flyway database migrations\"]]]\n\n          [:div.bg-white.p-6.rounded-lg.shadow-md\n           [:h2.text-2xl.font-semibold.text-gray-800.mb-3 \"⚡ Features\"]\n           [:ul.space-y-2.text-gray-600\n            [:li \"• Hot reloading development\"]\n            [:li \"• Interactive nREPL (port 7888)\"]\n            [:li \"• Comprehensive test suite\"]\n            [:li \"• Production-ready configuration\"]\n            [:li \"• Modern CSS with Tailwind\"]]]]\n\n         [:section.bg-gradient-to-r.from-blue-500.to-purple-600.p-8.rounded-lg.text-white.mb-8\n          [:h2.text-3xl.font-bold.mb-4 \"Interactive Demo\"]\n          [:p.mb-6 \"Try out the Stimulus controller integration:\"]\n          [:div {:stimulus/controller \"greet\"}\n           [:div.flex.gap-4.mb-4\n            [:input.px-4.py-2.rounded.text-gray-800\n             {:type \"text\"\n              :stimulus/target {:target \"name\" :controller \"greet\"}\n              :stimulus/action (page-html/s-> \"input\" \"greet\" \"updateName\")\n              :placeholder \"Enter your name...\"\n              :required true}]\n            [:button.bg-white.text-blue-600.px-6.py-2.rounded.font-semibold.hover:bg-gray-100.transition-colors\n             {:type \"button\"\n              :stimulus/action (page-html/s-> \"click\" \"greet\" \"greet\")}\n             \"Greet\"]]\n           [:p.text-lg {:stimulus/target {:target \"output\" :controller \"greet\"}}]]]\n\n         [:section.bg-white.p-6.rounded-lg.shadow-md.mb-8\n          [:h2.text-2xl.font-semibold.text-gray-800.mb-3 \"🌍 System Status\"]\n          [:div.grid.md:grid-cols-3.gap-4.text-center\n           [:div.p-4.bg-green-50.rounded-lg\n            [:div.text-2xl.font-bold.text-green-600 \"✓\"]\n            [:p.text-sm.text-gray-600 \"Database Connected\"]]\n           [:div.p-4.bg-blue-50.rounded-lg\n            [:div.text-2xl.font-bold.text-blue-600 planet]\n            [:p.text-sm.text-gray-600 \"Current Planet\"]]\n           [:div.p-4.bg-purple-50.rounded-lg\n            [:div.text-2xl.font-bold.text-purple-600 \"Ready\"]\n            [:p.text-sm.text-gray-600 \"System Status\"]]]]\n\n         [:footer.text-center.text-gray-500.pt-8.border-t\n          [:p \"Built with ❤️ using Clojure & ClojureScript\"]\n          [:p.text-sm.mt-2 \"Explore the codebase and start building!\"]]]}))}))\n\n(comment (:stimulus/action (page-html/s-> \"click\" \"greet\" \"updateName\")))\n\n(def desired\n  [:div {:stimulus/controller \"greet\"}\n   [:p {:stimulus/greet-target \"output\"}]\n   [:button {:stimulus/greet-action {:event \"input\" :method \"update\"}}]])\n\n(defn routes\n  [system]\n  [[\"/\" {:get {:handler (partial #'hello-handler system)}}]])\n```"}],"isError":false}}
{"jsonrpc":"2.0","id":57,"result":{"content":[{"type":"text","text":"### /Users/stepbeek/HappyValley/wick/src/example/page_html/core.clj\n```clj\n(ns example.page-html.core\n  (:require [clojure.walk :as w]\n            [hiccup.util :as hiccup-util]\n            [hiccup2.core :as hiccup]))\n\n(defn view [& {:keys [body title]\n               :or {title \"The Website\"}}]\n  [:html\n   [:head\n    [:title title]\n    [:meta {:name \"viewport\"\n            :content \"width=device-width, initial-scale=1.0\"}]\n\n    [:script {:src \"/assets/js/main.js\"}]\n    [:link {:href \"assets/css/main.css\" :rel \"stylesheet\"}]]\n   [:body\n    body]])\n\n(defn transform-controller [attr-map]\n  (let [controller (:stimulus/controller attr-map)]\n    (if controller (-> attr-map\n                       (dissoc :stimulus/controller)\n                       (assoc :data-controller controller))\n        attr-map)))\n\n(defn transform-target [attr-map]\n  (let [target-map (:stimulus/target attr-map)\n        {controller :controller target :target} target-map]\n    (when (and target-map (not (and controller target)))\n      (throw (ex-info \"A :stimulus/target was defined without the correct :controller and :target keys in the map.\" {:target-map target-map})))\n\n    (if (and controller target)\n      (-> attr-map\n          (dissoc :stimulus/target)\n          (assoc (keyword (str \"data-\" controller \"-target\")) target))\n      attr-map)))\n\n(defn transform-action [attr-map]\n  (let [action-map (:stimulus/action attr-map)\n        {controller :controller event :event function :function} action-map]\n    (when (and action-map (not (every? identity [controller event function])))\n      (throw (ex-info \"A :stimulus/action attr map was defined without having :controller, :target and :function defined\" {:action-map action-map})))\n    (if (and controller event function)\n      (-> attr-map\n          (dissoc :stimulus/action)\n          (assoc :data-action (hiccup-util/raw-string event \"->\" controller \"#\" function)))\n      attr-map)))\n\n(defn transform-attributes [attr-map]\n  (-> attr-map\n      (transform-controller)\n      (transform-target)\n      (transform-action)))\n\n(comment (transform-attributes {:stimulus/controller \"example\"}))\n\n(defn transform-stimulus [template]\n  \"Takes in a hiccup template and translates any stimulus attributes to their raw string form.\"\n  (w/postwalk\n   (fn [el] (if (map? el) (transform-attributes el) el))\n   template))\n\n(comment (transform-stimulus [:div {:stimulus/controller \"example\"}]))\n\n(defn s-> [event controller function]\n  {:event event\n   :controller controller\n   :function function})\n\n(defn render [template]\n  (-> template\n      (transform-stimulus)\n      (hiccup/html)\n      (str)))\n\n```"}],"isError":false}}
{"jsonrpc":"2.0","id":58,"result":{"content":[{"type":"text","text":"--- original.txt\n+++ revised.txt\n@@ -7,6 +7,7 @@\n                :or {title \"The Website\"}}]\n   [:html\n    [:head\n+    [:meta {:charset \"UTF-8\"}]\n     [:title title]\n     [:meta {:name \"viewport\"\n             :content \"width=device-width, initial-scale=1.0\"}]"}],"isError":false}}
{"jsonrpc":"2.0","id":59,"result":{"content":[{"type":"text","text":"--- original.txt\n+++ revised.txt\n@@ -22,11 +22,12 @@\n (defn not-found-handler\n   [request]\n   {:status 404\n-   :headers {\"Content-Type\" \"text/html\"}\n+   :headers {\"Content-Type\" \"text/html; charset=UTF-8\"}\n    :body (str\n           (hiccup/html\n            [:html\n             [:head\n+             [:meta {:charset \"UTF-8\"}]\n              [:title \"Page Not Found - Wick\"]\n              [:meta {:name \"viewport\"\n                      :content \"width=device-width, initial-scale=1.0\"}]\n@@ -43,8 +44,8 @@\n                 [:p {:class \"text-sm\"}\n                  \"The URL \" [:code {:class \"bg-gray-100 px-2 py-1 rounded text-xs text-gray-800\"} (:uri request)] \" could not be found.\"]]\n                [:div {:class \"space-y-3\"}\n-                [:button {:onclick \"window.history.back()\"\n-                          :class \"w-full bg-gray-100 hover:bg-gray-200 transition-colors duration-200 px-6 py-3 rounded-md font-medium text-gray-700 border border-gray-300\"}\n+                [:button {:onclick \"window.history.back()\"}\n+                 :class \"w-full bg-gray-100 hover:bg-gray-200 transition-colors duration-200 px-6 py-3 rounded-md font-medium text-gray-700 border border-gray-300\"\n                  \"← Go Back\"]\n                 [:a {:href \"/\"\n                      :class \"block w-full bg-gray-800 hover:bg-gray-900 transition-colors duration-200 px-6 py-3 rounded-md font-medium text-white\"}"}],"isError":false}}
{"jsonrpc":"2.0","id":60,"result":{"content":[{"type":"text","text":"--- original.txt\n+++ revised.txt\n@@ -10,7 +10,7 @@\n                           db\n                           [\"SELECT 'earth' as planet\"])]\n     {:status 200\n-     :headers {\"Content-Type\" \"text/html\"}\n+     :headers {\"Content-Type\" \"text/html; charset=UTF-8\"}\n      :body\n      (page-html/render\n       (page-html/view"}],"isError":false}}
{"jsonrpc":"2.0","id":61,"result":{"content":[{"type":"text","text":"=> nil"},{"type":"text","text":"*===============================================*"},{"type":"text","text":"=> nil"},{"type":"text","text":"*===============================================*"},{"type":"text","text":"=> nil"}],"isError":false}}
{"jsonrpc":"2.0","id":62,"result":{"tools":[{"name":"LS","description":"Returns a recursive tree view of files and directories starting from the specified path. The path parameter must be an absolute path, not a relative path. You should generally prefer the `glob_files` and `fx_grep` tools, if you know which directories to search.","inputSchema":{"type":"object","properties":{"path":{"type":"string"},"max_depth":{"type":"integer","description":"Maximum depth to traverse (optional)"},"limit":{"type":"integer","description":"Maximum number of entries to show (default: 100)"}},"required":["path"]}},{"name":"read_file","description":"Smart file reader with pattern-based exploration for Clojure files.\n   \nFor Clojure files (.clj, .cljc, .cljs, .bb):\n\nThis tool defaults to an expandable collapsed view to quickly grab the information you need from a Clojure file.\nIf called without `name_pattern` or `content_pattern` it will return the file content where \nyou will see only function signatures. This gives you a quick overview of the file.\n\nWhen you want to see more, this tool has a grep functionality where you\ncan give patterns to match the names for top level definitions\n`name_pattern` or match the bodies of top level definitions `content_pattern`.\n\nThe functions that match these patterns will be the only functions expanded in collapsed view.\n\nFor defmethod forms:\n- The name includes both the method name and the dispatch value (e.g., \"area :rectangle\")\n- For vector dispatch values, use the exact pattern (e.g., \"dispatch-with-vector \\[:feet :inches\\]\")\n- For qualified/namespaced multimethod names, include the namespace (e.g., \"tool-system/validate-inputs :clojure-eval\")\n\nFor text files (non-Clojure):\n- When `collapsed: true` and a pattern is provided (`content_pattern` or `name_pattern`), shows only lines matching the pattern with 10 lines of context before and after\n\nFor all other file types:\n- Collapsed view will not be applied and will return the raw contents of the file\n\nParameters:\n- path: Path to the file (required)\n- collapsed: Show collapsed view (default: true)\n\nCollapsed View mode function expansion parameters:\n\n- name_pattern: Regex to match function names (e.g., \"validate.*\")\n- content_pattern: Regex to match function content (e.g., \"try|catch\")\n\nExample usage for defmethod forms:\n- Find all implementations of a multimethod: `name_pattern: \"area\"`\n- Find specific dispatch values: `name_pattern: \"area :circle\"`\n- Find vector dispatch values: `name_pattern: \"convert-length \\\\[:feet :inches\\\\]\"`\n- Find namespace-qualified methods: `name_pattern: \"tool-system/validate-inputs\"`\n\nExample usage for text files:\n- Find error messages: `content_pattern: \"ERROR|WARN\"`\n- Find specific log entries: `content_pattern: \"\\\\[2024-01-15.*ERROR\\\\]\"`\n\nNon collapsed view mode respects these parameters:\n\n- line_offset: Line to start reading from (non-collapsed mode only, default: 0)\n- limit: Maximum lines to read (non-collapsed mode only, default: 2000)\n\nBy default, reads up to 2000 lines, truncating lines longer than 1000 characters.","inputSchema":{"type":"object","properties":{"path":{"type":"string","description":"Path to the file to read"},"collapsed":{"type":"boolean","description":"Whether to show collapsed view for Clojure files (default: true)"},"name_pattern":{"type":"string","description":"Pattern to match function names (e.g., \"validate.*\")"},"content_pattern":{"type":"string","description":"Pattern to match function content (e.g., \"try|catch\")"},"line_offset":{"type":"integer","description":"Line to start reading from for raw mode (default: 0)"},"limit":{"type":"integer","description":"Maximum lines to read (default: 2000)"}},"required":["path"]}},{"name":"grep","description":"Fast content search tool that works with any codebase size.\n- Finds the paths to files that have matching contents using regular expressions.\n- Supports full regex syntax (eg. \"log.*Error\", \"function\\s+\\w+\", etc.).\n- Filter files by pattern with the include parameter (eg. \"*.js\", \"*.{ts,tsx}\").\n- Returns matching file paths sorted by modification time.\n- Use this tool when you need to find files containing specific patterns.\n- When you are doing an open ended search that may require multiple rounds of globbing and grepping, use the `dispatch_agent` tool instead","inputSchema":{"type":"object","properties":{"path":{"type":"string","description":"The directory to search in. Defaults to the current working directory."},"pattern":{"type":"string","description":"The regular expression pattern to search for in file contents"},"include":{"type":"string","description":"File pattern to include in the search (e.g. \"*.clj\", \"*.{clj,cljs}\")"},"max_results":{"type":"integer","description":"Maximum number of results to return (default: 1000)"}},"required":["pattern"]}},{"name":"glob_files","description":"Fast file pattern matching tool that works with any codebase size.\n - Supports glob patterns like \"**/*.clj\" or \"src/**/*.cljs\".\n - Returns matching file paths sorted by modification time (most recent first).\n - Use this tool when you need to find files by name patterns.\n - When you are doing an open ended search that may require multiple rounds of globbing and grepping, use the `dispatch_agent` tool instead","inputSchema":{"type":"object","properties":{"path":{"type":"string","description":"Root directory to start the search from (defaults to current working directory)"},"pattern":{"type":"string","description":"Glob pattern (e.g. \"**/*.clj\", \"src/**/*.tsx\")"},"max_results":{"type":"integer","description":"Maximum number of results to return (default: 1000)"}},"required":["pattern"]}},{"name":"think","description":"Use the tool to think about something. It will not obtain new information or make any changes to the repository, but just log the thought. Use it when complex reasoning or brainstorming is needed. \nCommon use cases:\n* when having difficulty finding/reading the files you need\n* when having difficulty writing out code\n* when having difficulty using the tools or the clojure tools\n* When exploring a repository and discovering the source of a bug, call this tool to brainstorm several unique ways of fixing the bug, and assess which change(s) are likely to be simplest and most effective.\n* After receiving test results, use this tool to brainstorm ways to fix failing tests.\n* When planning a complex refactoring, use this tool to outline different approaches and their tradeoffs.\n* When designing a new feature, use this tool to think through architecture decisions and implementation details.\n* When debugging a complex issue, use this tool to organize your thoughts and hypotheses.\nThe tool simply logs your thought process for better transparency and does not execute any code or make changes.","inputSchema":{"type":"object","properties":{"thought":{"type":"string","description":"The thought to log"}},"required":["thought"]}},{"name":"scratch_pad","description":"A persistent scratch pad for storing structured data between tool calls. Accepts any JSON value (objects, arrays, strings, numbers, booleans, null) and stores them at nested paths using set_path, get_path, delete_path operations.\n\nTHIS IS YOUR GO-TO TOOL FOR PLANNING.\n\nYour persistent workspace for planning, organizing thoughts, and maintaining state across tool invocations.\n\nThis tool can be used to:\n * develop and track multi-step plans\n * maintain task lists and task tracking\n * store intermediate results between operations\n * keep notes about your current approach or strategy\n * maintain a list of files or resources to process\n * build up complex data structures incrementally\n * share context between different tool calls\n * any other persistent storage needs during your work\n\nThe scratch pad is for persistent storage and state management, not for formatting output. Display information directly in your chat responses. However, when the scratch pad contains user-relevant state (like tasks lists or tracked progress), you should retrieve and display updates after modifications.\n\nUse the scratch pad when you need to:\n- Track progress across multiple tool calls\n- Build data structures incrementally  \n- Maintain state between operations\n- Store intermediate results for later use\n\nDon't use the scratch pad to:\n- Format text for display\n- Store static information just to retrieve and show it\n- Replace direct chat responses\n\nCORE OPERATIONS:\n- set_path: Store a value (not null) at a path, returns the parent container\n- get_path: Retrieve a value from a path, returns the value or nil\n- delete_path: Remove only the leaf value from a path, returns a confirmation message\n- inspect: Display the entire structure (or a specific path) with truncation at specified depth\n\nWARNING: null values can not be stored in the scratch pad, if you attempt to store a null value the set_path will fail.\n\nTRACKING PLANS WITH TASK LISTS:\n\nRecommended schema for a Task:\n{\n  task: \"Description of the task\",\n  done: false,\n  priority: \"high\", // optional: \"high\", \"medium\", \"low\"\n  context: \"Additional details\", // optional\n  subtasks: [  // optional: array of subtask objects\n    {task: \"Subtask 1\", done: false},\n    {task: \"Subtask 2\", done: true}\n  ]\n}\n\nFirst add multiple tasks items at once as an array:\n- Entire array:\n  op: set_path\n  path: [\"tasks\"]\n  value: [\n    {task: \"Write tests\", done: false, priority: \"high\"},\n    {task: \"Review PR\", done: false, priority: \"high\"},\n    {task: \"Update docs\", done: false, priority: \"medium\", subtasks: [\n      {task: \"Update API docs\", done: false},\n      {task: \"Update README\", done: false}\n    ]}\n  ]\n  explanation: Adding multiple tasks at once\n\nAdding tasks items:\n- First item:\n  op: set_path\n  path: [\"tasks\", 3]\n  value: {task: \"Run tests\", done: false}\n  explanation: Adding write tests task\n\n- Next item:\n  op: set_path\n  path: [\"tasks\", 4]\n  value: {task: \"Notify user\", done: false, priority: \"high\"}\n  explanation: Adding high priority task\n\nChecking off completed tasks:\n- Mark as done:\n  op: set_path\n  path: [\"tasks\", 0, \"done\"]\n  value: true\n  explanation: Completed writing tests\n\n- Mark subtask as done:\n  op: set_path\n  path: [\"tasks\", 2, \"subtasks\", 0, \"done\"]\n  value: true\n  explanation: Completed API docs update\n\nAdding a new task to the array:\n- Append to array:\n  op: set_path\n  path: [\"tasks\", 3]\n  value: {task: \"Deploy to production\", done: false, priority: \"high\"}\n  explanation: Adding deployment task\n\nViewing tasks:\n- All tasks:\n  op: get_path\n  path: [\"tasks\"]\n  explanation: Get all tasks\n\n- Specific task:\n  op: get_path\n  path: [\"tasks\", 0]\n  explanation: Checking first task details\n\n- View with depth limit:\n  op: inspect\n  path: [\"tasks\"]\n  depth: 2\n  explanation: View tasks with limited nesting","inputSchema":{"type":"object","properties":{"op":{"type":"string","enum":["set_path","get_path","delete_path","inspect"],"description":"The operation to perform:\n * set_path: set a value at a path\n * get_path: retrieve a value at a path\n * delete_path: remove the value at the path from the data structure\n * inspect: view the datastructure (or a specific path within it) up to a certain depth\n"},"path":{"type":"array","items":{"type":"string"},"description":"Path to the data location (array of string or number keys) - used for set_path, get_path, delete_path, and optionally inspect"},"value":{"description":"Value to store (for set_path). Can be ANY JSON value EXCEPT null: object, array, string, number, boolean.","type":"object"},"explanation":{"type":"string","description":"Explanation of why this operation is being performed"},"depth":{"type":"number","description":"(Optional) For inspect operation: Maximum depth to display (default: 5). Must be a positive integer."}},"required":["op","explanation"]}},{"name":"clojure_eval","description":"Takes a Clojure Expression and evaluates it in the current namespace. For example, providing \"(+ 1 2)\" will evaluate to 3.\n\nThis tool is intended to execute Clojure code. This is very helpful for verifying that code is working as expected. It's also helpful for REPL driven development.\n\nIf you send multiple expressions they will all be evaluated individually and their output will be clearly partitioned.\n\nIf the returned value is too long it will be truncated.\n\nIMPORTANT: When using `require` to reload namespaces ALWAYS use `:reload` to ensure you get the latest version of files.\n\nREPL helper functions are automatically loaded in the 'clj-mcp.repl-tools' namespace, providing convenient namespace and symbol exploration:\n\nNamespace/Symbol inspection functions:\n  clj-mcp.repl-tools/list-ns           - List all available namespaces\n  clj-mcp.repl-tools/list-vars         - List all vars in namespace\n  clj-mcp.repl-tools/doc-symbol        - Show documentation for symbol\n  clj-mcp.repl-tools/source-symbol     - Show source code for symbol\n  clj-mcp.repl-tools/find-symbols      - Find symbols matching pattern\n  clj-mcp.repl-tools/complete          - Find completions for prefix\n  clj-mcp.repl-tools/help              - Show this help message\n\nExamples:\n  (clj-mcp.repl-tools/list-ns)                     ; List all namespaces\n  (clj-mcp.repl-tools/list-vars 'clojure.string)   ; List functions in clojure.string\n  (clj-mcp.repl-tools/doc-symbol 'map)             ; Show documentation for map\n  (clj-mcp.repl-tools/source-symbol 'map)          ; Show source code for map\n  (clj-mcp.repl-tools/find-symbols \"seq\")          ; Find symbols containing \"seq\"\n  (clj-mcp.repl-tools/complete \"clojure.string/j\") ; Find completions for prefix","inputSchema":{"type":"object","properties":{"code":{"type":"string","description":"The Clojure code to evaluate."}},"required":["code"]}},{"name":"bash","description":"Execute bash shell commands on the host system.\n\nExamples:\n1. List files: bash(command: \"ls -la\")\n2. Find text in files: bash(command: \"grep -r 'pattern' /path/to/search\")\n3. With working directory: bash(command: \"ls -la\", working_directory: \"/tmp\")\n4. With timeout: bash(command: \"sleep 10\", timeout_ms: 5000)\n5. Git commands \n\nFor long running processes like running tests increase the timeout_ms so that the process can complete.\n\nNote: Non-zero exit codes are NOT treated as tool errors - check exit_code\nin the response to determine command success.","inputSchema":{"type":"object","properties":{"command":{"type":"string","description":"The shell command to execute"},"working_directory":{"type":"string","description":"Directory to run the command in (optional)"},"timeout_ms":{"type":"integer","description":"Maximum execution time in milliseconds (optional, default: 30000)"}},"required":["command"]}},{"name":"clojure_edit","description":"Edits a top-level form (`defn`, `def`, `defmethod`, `ns`, `deftest`) in a Clojure file using the specified operation.\n   \nPREFER this unified tool over generic file editing tools for Clojure files (`.clj` `.cljs` `.cljc` `.bb`)\n\nThis tool MAKES it EASIER to match a definition that exists in the file AS you only have to match the type of definition `form_type` and the complete identifier `form_identifier` of the definition. This prevents the repeated mismatch errors that occur when trying match an entire string of text for replacement.\nThis tool validates the structure of the Clojure code that is being inserted into the file and will provide linting feedback for things such as parenthetical errors.\nThis tool reduces the number of tokens that need to be generated.\n \nWARNING: you will receive errors if the syntax is wrong, the most common error is an extra or missing parenthesis in the `content`, so be careful with parenthesis.\n\n   Operations:\n   - \"replace\": Replaces the form with new content\n   - \"insert_before\": Inserts content before the form\n   - \"insert_after\": Inserts content after the form\n   \n   The form is identified by its type (defn, def, deftest, s/def, ns, defmethod etc.) and complete identifier.\n   \n   Example: Replace a function definition:\n   - file_path: \"/path/to/file.clj\"\n   - form_identifier: \"example-fn\"\n   - form_type: \"defn\"\n   - operation: \"replace\"\n   - content: \"(defn example-fn [x] (* x 2))\"\n   \n   Example: Insert a helper function before a function:\n   - file_path: \"/path/to/file.clj\"\n   - form_identifier: \"example-fn\"\n   - form_type: \"defn\"\n   - operation: \"insert_before\"\n   - content: \"(defn helper-fn [x] (* x 2))\"\n   \n   Example: Insert a test after a function:\n   - file_path: \"/path/to/file.clj\"\n   - form_identifier: \"example-fn\"\n   - form_type: \"defn\"\n   - operation: \"insert_after\"\n   - content: \"(deftest example-fn-test\n  (is (= 4 (example-fn 2))))\"\n   \nNote: For `defmethod` forms, be sure to include the dispatch value (`area :rectangle` or `qualified/area :rectangle`) in the `form_identifier`. Many `defmethod` definitions have qualified names (they include a namespace alias in their identifier like `shape/area`), so it's crucial to use the complete identifier that appears in the file.\n\n   Example: Replace a specific `defmethod` implementation:\n   - file_path: \"/path/to/file.clj\"\n   - form_identifier: \"shape/area :square\"\n   - form_type: \"defmethod\"\n   - operation: \"replace\"\n   - content: \"(defmethod shape/area :square [{:keys [w h]}] (* w h))\"\n\n   Example: Work with vector dispatch values:\n   - file_path: \"/path/to/file.clj\"\n   - form_identifier: \"convert-length [:feet :inches]\"\n   - form_type: \"defmethod\"\n   - operation: \"insert_before\"\n   - content: \"(def inches-per-foot 12)\"\n\n   The tool will find the form, perform the requested operation, and format the result.\n   It returns a diff showing the changes made to the file.","inputSchema":{"type":"object","properties":{"file_path":{"type":"string","description":"Path to the file containing the form to edit"},"form_identifier":{"type":"string","description":"Complete identifier of the form (e.g., function name, \"shape/area\", or \"convert-length [:feet :inches]\")"},"form_type":{"type":"string","description":"Type of the form (e.g., \"defn\", \"def\", \"ns\")"},"operation":{"type":"string","enum":["replace","insert_before","insert_after"],"description":"The editing operation to perform"},"content":{"type":"string","description":"New content to use for the operation"}},"required":["file_path","form_identifier","form_type","operation","content"]}},{"name":"clojure_edit_replace_sexp","description":"Edits a file by finding and replacing specific s-expressions.\n\nUse this tool for targeted edits of sub-expressions within forms. For complete top-level form replacements, prefer specialized tools like `clojure_edit_replace_definition` and friends.\n\nKEY BENEFITS:\n- Syntax-aware matching that understands Clojure code structure\n- Ignores whitespace differences by default, focusing on actual code meaning\n- Matches expressions regardless of formatting, indentation, or spacing\n- Prevents errors from mismatched text or irrelevant formatting differences\n- Can find and replace all occurrences with replace_all: true\n\nCONSTRAINTS:\n- match_form must contain only a SINGLE s-expression (error otherwise)\n- Requires syntactically valid Clojure expressions in both match_form and new_form\n\nWARNING: You will receive errors if the syntax is wrong. The most common error is an extra or missing parenthesis in either match_form or new_form, so count your parentheses carefully!\n\nCOMMON APPLICATIONS:\n- Renaming symbols throughout the file: {\"match_form\": \"old-name\", \"new_form\": \"new-name\", \"replace_all\": true}\n- Editing special forms like if/cond/let/when within functions:\n  * Changing if branches: {\"match_form\": \"(if condition expr1 expr2)\", \"new_form\": \"(if condition (do expr1) expr2)\"}\n  * Enhancing let bindings: {\"match_form\": \"(let [x 10] (+ x 2))\", \"new_form\": \"(let [x 10 y 20] (+ x y))\"}\n  * Converting cond to case: {\"match_form\": \"(cond (= x :a) \\\"A\\\" (= x :b) \\\"B\\\")\", \"new_form\": \"(case x :a \\\"A\\\" :b \\\"B\\\")\"}\n- Modifying nested function calls: {\"match_form\": \"(str (+ a b))\", \"new_form\": \"(str (+ a b c))\"}\n- Changing anonymous function syntax: {\"match_form\": \"#(update % :count inc)\", \"new_form\": \"(fn [x] (update x :count inc))\"}\n\nOther Examples:\n- Replace a calculation: {\"match_form\": \"(+ x 2)\", \"new_form\": \"(+ x 10)\"}\n  * Will match regardless of spaces: (+ x 2), (+   x   2), etc.\n- Delete an expression: {\"match_form\": \"(println debug-info)\", \"new_form\": \"\"}\n- Edit anonymous function: {\"match_form\": \"#(inc %)\", \"new_form\": \"#(+ % 2)\"}\n- Replace multiple occurrences: {\"match_form\": \"(inc x)\", \"new_form\": \"(+ x 1)\", \"replace_all\": true}\n\nReturns a diff showing the changes made to the file.","inputSchema":{"type":"object","properties":{"file_path":{"type":"string","description":"Path to the file to edit"},"match_form":{"type":"string","description":"The s-expression to find and replace (include # for anonymous functions)"},"new_form":{"type":"string","description":"The s-expression to replace with"},"replace_all":{"type":"boolean","description":"Whether to replace all occurrences (default: false)"}},"required":["file_path","match_form","new_form"]}},{"name":"file_edit","description":"Edit a file by replacing a specific text string with a new one. For safety, this tool requires that the string to replace appears exactly once in the file. \n\nFIRST: the clojure_edit tool is prefered because they use precise structural rewrite-clj editing. They also incorporate linting and ensure balance parenthesis.\n\nWHEN the clojure_edit tool won't work or you have a small easy edit \n\nPREFER the file_write tool for replacing more than half a file, this saves on tokens\n\nFor Clojure files (.clj, .cljs, .cljc, .edn):\n- Content will be linted for syntax errors before writing\n- Content will be formatted according to Clojure standards\n- Writing will fail if linting detects syntax errors\n\nTo make a file edit, provide the file_path, old_string (the text to replace), and new_string (the replacement text). The old_string must uniquely identify the specific instance you want to change, so include several lines of context before and after the change point. To create a new file, use file_write instead.","inputSchema":{"type":"object","properties":{"file_path":{"type":"string","description":"The absolute path to the file to modify (must be absolute, not relative)"},"old_string":{"type":"string","description":"The text to replace (must match the file contents exactly, including all whitespace and indentation)."},"new_string":{"type":"string","description":"The edited text to replace the old_string"}},"required":["file_path","old_string","new_string"]}},{"name":"file_write","description":"Write a file to the local filesystem. Overwrites the existing file if there is one.\n\nFor Clojure files (.clj, .cljs, .cljc, .edn):\n- Content will be linted for syntax errors before writing\n- Content will be formatted according to Clojure standards\n- Writing will fail if linting detects syntax errors\n\nFor other file types:\n- Content is written directly without linting or formatting\n\nIMPORTANT SAFETY FEATURE:\n- If the file has been modified since it was last read, writing will fail\n- You must use read_file to get the current content before editing a file\n- This prevents accidental overwrites of external changes\n\nReturns information about whether the file was created or updated, along with a diff \nshowing the changes made.\n\nBefore using this tool:\n1. Use the read_file tool to understand the file's contents and context\n2. Directory Verification (only applicable when creating new files):\n   - Use the list_directory tool to verify the parent directory exists and is the correct location\n3. For Clojure files, ensure code is syntactically correct\n\n# Example:\n# file_write(\n#   file_path: \"/absolute/path/to/file.clj\",\n#   content: \"(ns my.namespace)\\n\\n(defn my-function [x]\\n  (* x 2))\"\n# )","inputSchema":{"type":"object","properties":{"file_path":{"type":"string","description":"The absolute path to the file to write (must be absolute, not relative)"},"content":{"type":"string","description":"The content to write to the file"}},"required":["file_path","content"]}},{"name":"clojure_inspect_project","description":"Analyzes and provides detailed information about a Clojure project's structure, \nincluding dependencies, source files, namespaces, and environment details.\n\nThis tool helps you understand project organization without having to manually \nexplore multiple configuration files. It works with both deps.edn and Leiningen projects.\n\nThe tool provides information about:\n- Project environment (working directory, Clojure version, Java version)\n- Source and test paths\n- Dependencies and their versions\n- Aliases and their configurations\n- Available namespaces\n- Source file structure\n\nUse this tool to quickly get oriented in an unfamiliar Clojure codebase or to \nget a high-level overview of your current project.\n\n# Example:\nclojure_inspect_project()","inputSchema":{"type":"object","properties":{"explanation":{"type":"string","description":"Short explanation why you chose this tool"}},"required":["explanation"]}},{"name":"dispatch_agent","description":"Launch a new agent that has access to read-only tools. When you are searching for a keyword or file and are not confident that you will find the right match on the first try, use the Agent tool to perform the search for you. For example:\n\n- If you are searching for a keyword like \"config\" or \"logger\", the Agent tool is appropriate\n- If you want to read a specific file path, use the read_file or glob_files tool instead of the Agent tool, to find the match more quickly\n- If you are searching for a specific class definition like \"class Foo\", use the glob_files tool instead, to find the match more quickly\n\nUsage notes:\n1. Launch multiple agents concurrently whenever possible, to maximize performance; to do that, use a single message with multiple `agent` tool uses\n2. When the agent is done, it will return a single message back to you. The result returned by the agent is not visible to the user. To show the user the result, you should send a text message back to the user with a concise summary of the result.\n3. Each agent invocation is stateless. You will not be able to send additional messages to the agent, nor will the agent be able to communicate with you outside of its final report. Therefore, your prompt should contain a highly detailed task description for the agent to perform autonomously and you should specify exactly what information the agent should return back to you in its final and only message to you.\n4. The agent's outputs should generally be trusted","inputSchema":{"type":"object","properties":{"prompt":{"type":"string","description":"The prompt to send to the agent"}},"required":["prompt"]}},{"name":"architect","description":"Your go-to tool for any technical or coding task. Analyzes requirements and breaks them down into clear, actionable implementation steps. Use this whenever you need help planning how to implement a feature, solve a technical problem, or structure your code.","inputSchema":{"type":"object","properties":{"prompt":{"type":"string","description":"The technical request or coding task to analyze"},"context":{"type":"string","description":"Optional context from previous conversation or system state"}},"required":["prompt"]}},{"name":"code_critique","description":"Starts an interactive code review conversation that provides constructive feedback on your Clojure code.\n  \n  HOW TO USE THIS TOOL:\n  1. Submit your Clojure code for initial critique\n  2. Review the suggestions and implement improvements\n  3. Test your revised code in the REPL\n  4. Submit the updated code for additional feedback\n  5. Continue this cycle until the critique is satisfied\n  \n  This tool initiates a feedback loop where you:\n  - Receive detailed analysis of your code\n  - Implement suggested improvements\n  - Test and verify changes\n  - Get follow-up critique on your revisions\n  \n  The critique examines:\n  - Adherence to Clojure style conventions\n  - Functional programming best practices\n  - Performance optimizations\n  - Readability and maintainability improvements\n  - Idiomatic Clojure patterns\n  \n  Example conversation flow:\n  - You: Submit initial function implementation\n  - Tool: Provides feedback on style and structure\n  - You: Revise code based on suggestions and test in REPL\n  - Tool: Reviews updates and suggests further refinements\n  - Repeat until code quality goals are achieved\n  \n  Perfect for iterative learning and continuous code improvement.","inputSchema":{"type":"object","properties":{"code":{"type":"string","description":"The Clojure code to analyze and critique"},"context":{"type":"string","description":"Optional context from previous conversation or system state"}},"required":["code"]}}]}}
{"jsonrpc":"2.0","id":63,"result":{"resources":[{"uri":"custom://llm-code-style","name":"LLM_CODE_STYLE.md","description":"Guidelines for writing Clojure code for the current project hosting the REPL","mimeType":"text/markdown"},{"uri":"custom://project-summary","name":"PROJECT_SUMMARY.md","description":"A Clojure project summary document for the project hosting the REPL, this is intended to provide the LLM with important context to start.","mimeType":"text/markdown"},{"uri":"custom://claude","name":"CLAUDE.md","description":"The Claude instructions document for the current project hosting the REPL","mimeType":"text/markdown"},{"uri":"custom://readme","name":"README.md","description":"A README document for the current Clojure project hosting the REPL","mimeType":"text/markdown"},{"uri":"custom://project-info","name":"Clojure Project Info","description":"Information about the current Clojure project structure, attached REPL environment and dependencies","mimeType":"text/markdown"}]}}
{"jsonrpc":"2.0","id":64,"result":{"prompts":[{"name":"ACT/scratch_pad_load","description":"Loads a file into the scratch pad state. Returns status messages and a shallow inspect of the loaded data.","arguments":[{"name":"file_path","description":"Optional file path: default scratch_pad.edn","required":false}]},{"name":"clojure_repl_system_prompt","description":"Provides instructions and guidelines for Clojure development, including style and best practices.","arguments":[]},{"name":"create-update-project-summary","description":"Generates a prompt instructing the LLM to create a summary of a project.","arguments":[]},{"name":"chat-session-summarize","description":"Instructs the assistant to create a summary of the current chat session and store it in the scratch pad. `chat_session_key` is optional and will default to `chat_session_summary`","arguments":[{"name":"chat_session_key","description":"[Optional] key to store the session summary in","required":false}]},{"name":"ACT/scratch_pad_save_as","description":"Saves the current scratch pad state to a specified file.","arguments":[{"name":"file_path","description":"File path: relative to .clojure-mcp/ directory","required":true}]},{"name":"chat-session-resume","description":"Instructs the assistant to resume a previous chat session by loading context from the scratch pad. `chat_session_key` is optional and will default to `chat_session_summary`","arguments":[{"name":"chat_session_key","description":"[Optional] key where session summary is stored","required":false}]},{"name":"ACT/add-dir","description":"Adds a directory to the allowed-directories list, giving the LLM access to it","arguments":[{"name":"directory","description":"Directory path to add (can be relative or absolute)","required":true}]},{"name":"plan-and-execute","description":"Use the scratch pad tool to plan and execute an change","arguments":[]}]}}
{"jsonrpc":"2.0","id":65,"result":{"content":[{"type":"text","text":"=> nil"},{"type":"text","text":"*===============================================*"},{"type":"text","text":"=> \"<html><head><meta charset=\\\"UTF-8\\\" /><title>Test</title><meta content=\\\"width=device-width, initial-scale=1.0\\\" name=\\\"viewport\\\" /><script src=\\\"/assets/js/main.js\\\"></script><link href=\\\"assets/css/main.css\\\" rel=\\\"stylesheet\\\" /></head><body><div>Testing UTF-8: 🚀 ⚡ 🌍 ❤️</div></body></html>\""}],"isError":false}}
{"jsonrpc":"2.0","id":66,"result":{"content":[{"type":"text","text":"=> nil"},{"type":"text","text":"*===============================================*"},{"type":"text","text":"=> \"<html><head><meta charset=\\\"UTF-8\\\" /><title>Page Not Found - Wick</title><meta content=\\\"width=device-width, initial-scale=1.0\\\" name=\\\"viewport\\\" /><script src=\\\"/assets/js/main.js\\\"></script><link href=\\\"/assets/css/main.css\\\" rel=\\\"stylesheet\\\" /></head><body><div class=\\\"min-h-screen bg-gray-50 flex items-center justify-center p-6\\\"><div class=\\\"max-w-md w-full bg-white rounded-lg shadow-lg border border-gray-200 p-8 text-center\\\"><div class=\\\"mb-6\\\"><h1 class=\\\"text-6xl font-bold mb-2 text-gray-800\\\">404</h1><div class=\\\"text-2xl font-semibold mb-4 text-gray-700\\\">Page Not Found</div></div><div class=\\\"mb-8 text-gray-600\\\"><p class=\\\"text-lg mb-2\\\">The page you&apos;re looking for doesn&apos;t exist.</p><p class=\\\"text-sm\\\">The URL <code class=\\\"bg-gray-100 px-2 py-1 rounded text-xs text-gray-800\\\">/test</code> could not be found.</p></div><div class=\\\"space-y-3\\\"><button onclick=\\\"window.history.back()\\\">classw-full bg-gray-100 hover:bg-gray-200 transition-colors duration-200 px-6 py-3 rounded-md font-medium text-gray-700 border border-gray-300← Go Back</button><a class=\\\"block w-full bg-gray-800 hover:bg-gray-900 transition-colors duration-200 px-6 py-3 rounded-md font-medium text-white\\\" href=\\\"/\\\">Return Home</a></div></div></div></body></html>\""}],"isError":false}}
{"jsonrpc":"2.0","id":67,"result":{"content":[{"type":"text","text":""}],"isError":false}}
{"jsonrpc":"2.0","id":68,"result":{"content":[{"type":"text","text":"=> nil"}],"isError":false}}
{"jsonrpc":"2.0","id":69,"result":{"content":[{"type":"text","text":"{\"original_issue\"\n \"Basic 404 page with minimal styling and no navigation\",\n \"solution\"\n \"Redesigned 404 page with modern gradient styling, clear messaging, and two navigation options\",\n \"features_added\"\n [\"Beautiful gradient background matching homepage design\"\n  \"Clear 404 error messaging with friendly text\"\n  \"Dynamic URL display showing the missing path\"\n  \"Go Back button using browser history\"\n  \"Return Home button linking to homepage\"\n  \"Proper page title and meta tags\"\n  \"Responsive design with Tailwind CSS classes\"\n  \"Glassmorphism effect with backdrop blur\"],\n \"testing\"\n {\"playwright_tests_passed\" true,\n  \"go_back_button\" \"Works correctly using window.history.back()\",\n  \"return_home_button\" \"Works correctly navigating to /\",\n  \"visual_design\" \"Modern gradient design matches site branding\",\n  \"responsive\" \"Works well on different screen sizes\"},\n \"technical_details\"\n {\"file_modified\" \"src/example/routes.clj\",\n  \"function\" \"not-found-handler\",\n  \"styling_approach\" \"Inline Tailwind CSS classes\",\n  \"navigation_methods\" \"JavaScript history API + direct link\"},\n \"final_design\"\n {\"design_approach\" \"Minimalist and professional\",\n  \"color_scheme\" \"Neutral grays with clean white background\",\n  \"background\" \"Light gray (bg-gray-50) instead of colorful gradient\",\n  \"card_design\" \"White card with subtle shadow and gray border\",\n  \"text_colors\" \"Dark gray headings, medium gray body text\",\n  \"buttons\"\n  {\"go_back\" \"Light gray with hover effect\",\n   \"return_home\" \"Dark gray/charcoal for primary action\"},\n  \"visual_changes_from_colorful\"\n  [\"Removed blue-purple-pink gradient background\"\n   \"Replaced glassmorphism with clean white card\"\n   \"Changed from white text to dark gray text\"\n   \"Simplified button styling\"\n   \"Removed backdrop blur effects\"\n   \"Used standard border radius instead of large rounded corners\"],\n  \"user_feedback\"\n  \"Requested less colorful design - implemented successfully\"},\n \"encoding_fix\"\n {\"issue\"\n  \"Emoji symbols not rendering properly in browser (showing as encoded characters)\",\n  \"root_cause\"\n  \"Missing UTF-8 charset declaration in HTML head and Content-Type headers\",\n  \"solution\"\n  \"Added UTF-8 charset meta tag and updated Content-Type headers\",\n  \"files_modified\"\n  [\"src/example/page_html/core.clj\"\n   \"src/example/routes.clj\"\n   \"src/example/hello/routes.clj\"],\n  \"changes_made\"\n  [\"Added <meta charset=\\\"UTF-8\\\"> to page-html/view function\"\n   \"Updated Content-Type headers to include 'charset=UTF-8'\"\n   \"Fixed syntax error in 404 handler button attributes\"],\n  \"affected_pages\"\n  [\"Homepage (index)\"\n   \"404 error page\"\n   \"All pages using page-html/view function\"],\n  \"test_results\"\n  \"Emojis now properly encoded in HTML output (🚀 ⚡ 🌍 ❤️)\",\n  \"status\" \"Fixed\"}}\n"}],"isError":false}}
{"jsonrpc":"2.0","id":70,"result":{"description":"Create conversation summary for key: chat_session_summary","messages":[{"role":"user","content":{"type":"text","text":"Place in the scratch_pad under the key path [\"chat_session_summary\"] a detailed but concise summary of our conversation above. Focus on information that would be helpful for continuing the conversation, including what we did, what we're doing, which files we're working on, and what we're going to do next."}}]}}
{"jsonrpc":"2.0","id":71,"result":{"content":[{"type":"text","text":"{\"chat_session_summary\"\n {\"files_modified\"\n  {\"src/example/routes.clj\"\n   {\"changes\"\n    \"Completely rewrote not-found-handler with modern styling and navigation\",\n    \"function\" \"not-found-handler\"},\n   \"src/example/page_html/core.clj\"\n   {\"changes\" \"Added UTF-8 charset meta tag to view function\",\n    \"function\" \"view\"},\n   \"src/example/hello/routes.clj\"\n   {\"changes\" \"Updated Content-Type header to include charset=UTF-8\",\n    \"function\" \"hello-handler\"}},\n  \"technical_details\"\n  {\"testing_approach\"\n   \"Playwright browser automation for UI/UX validation\",\n   \"styling_framework\" \"Tailwind CSS with inline classes\",\n   \"character_encoding\" \"UTF-8 properly configured\",\n   \"navigation_methods\" \"JavaScript history API + direct linking\"},\n  \"key_discoveries\"\n  [\"Homepage runs on localhost:9999 successfully\"\n   \"Interactive Stimulus controller integration works correctly\"\n   \"Available routes: / (homepage), /goodbye, static assets\"\n   \"Application uses Tailwind CSS for styling\"\n   \"ClojureScript/Shadow-CLJS integration functional\"],\n  \"project_context\"\n  \"Wick is a full-stack Clojure web app with Ring/Reitit, PostgreSQL, ClojureScript frontend, and modern development tooling\",\n  \"completed_tasks\"\n  [{\"task\" \"Homepage testing with Playwright\",\n    \"description\"\n    \"Used Playwright browser automation to test homepage functionality\",\n    \"results\"\n    \"All features working correctly: page loading, interactive Stimulus controller demo, routing, asset loading\",\n    \"status\" \"✅ Complete\"}\n   {\"task\" \"404 page redesign\",\n    \"description\"\n    \"Redesigned minimal 404 page with modern styling and navigation\",\n    \"changes\"\n    [\"Added gradient background (later changed to minimalist gray)\"\n     \"Implemented Go Back button using browser history\"\n     \"Added Return Home button\"\n     \"Included dynamic URL display\"\n     \"Applied responsive Tailwind CSS styling\"],\n    \"user_feedback\"\n    \"Requested less colorful design - successfully implemented cleaner gray theme\",\n    \"status\" \"✅ Complete\"}\n   {\"task\" \"Character encoding fix\",\n    \"description\"\n    \"Fixed emoji symbols not rendering properly in browser\",\n    \"root_cause\"\n    \"Missing UTF-8 charset meta tag and Content-Type headers\",\n    \"solution\" \"Added UTF-8 support to all HTML pages\",\n    \"status\" \"✅ Complete\"}],\n  \"session_overview\"\n  \"Comprehensive testing and improvement of Wick Clojure web application homepage and 404 page\",\n  \"tools_used\"\n  [\"Playwright MCP for browser testing\"\n   \"Clojure REPL for namespace reloading\"\n   \"Clojure editing tools for code changes\"],\n  \"areas_for_future_work\"\n  [\"Could enhance interactive demo styling/animations\"\n   \"Potential accessibility improvements\"\n   \"Error handling enhancements\"\n   \"Additional route development\"],\n  \"current_state\" \"Wick application fully functional with improved UX\"}}\n"}],"isError":false}}
